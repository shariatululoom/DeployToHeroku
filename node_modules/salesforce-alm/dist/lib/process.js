/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// Node
const net = require('net');
const path = require('path');
// Thirdparty
const bodyParser = require('body-parser');
const Promise = require('bluebird');
const logger = require(path.join(__dirname, 'logApi'));
const _ = require('lodash');
// Local
const almError = require(path.join(__dirname, 'almError'));
const oauthGet = require(path.join(__dirname, 'oauthRequest')).OauthRequestGet;
const _DEFAULT_CLIENT_SOCKET_TIMEOUT = 20000;
/**
 * check and get the socket timeout form what was set in process.env.SFDX_HTTP_SOCKET_TIMEOUT
 * @returns {number} - represents the socket timeout in ms
 * @private
 */
const _getSocketTimeout = function () {
    const socketTimeout = _.toNumber(process.env.SFDX_HTTP_SOCKET_TIMEOUT);
    return _.isInteger(socketTimeout) && socketTimeout > 0 ? socketTimeout : _DEFAULT_CLIENT_SOCKET_TIMEOUT;
};
/**
 * Make sure we can't open a socket on the localhost/host port. It's important because we don't want to send
 * auth tokens to a random strange port listener. We want to make sure we can startup our server first.
 * @param port - default oauth callback port
 * @param host - hostname with localhost default
 * @private
 */
const _checkOsPort = function (port, host = 'localhost') {
    return new Promise((resolve, reject) => {
        const clientConfig = { port, host };
        const socket = new net.Socket();
        socket.setTimeout(_getSocketTimeout(), () => {
            socket.destroy();
        });
        socket.connect(clientConfig, () => {
            socket.destroy();
            // This is just a private rejection error. startOauth rejects with an almError.
            const error = new Error();
            error.code = 'EADDRINUSE';
            error.port = clientConfig.port;
            error.address = clientConfig.host;
            reject(error);
        });
        socket.on('error', () => {
            socket.destroy();
            resolve(port);
        });
    });
};
module.exports.startOauth = function (orgApi, oauthConfig, validateState, type) {
    const _logger = logger.child('webLogin');
    const port = orgApi.config.getOauthLocalPort();
    return _checkOsPort(port)
        .then(() => {
        const express = require('express'); // eslint-disable-line global-require
        const app = express();
        app.use(bodyParser.json()); // to support JSON-encoded bodies
        app.use(bodyParser.urlencoded({
            extended: true
        }));
        const server = app.listen(port, 'localhost');
        const finishedOAuthPromise = new Promise((resolve, reject) => {
            app.get('/OauthRedirect', (request, response) => {
                oauthGet(orgApi, oauthConfig, request, response, validateState, err => {
                    if (err) {
                        // We don't want to shutdown down the auth process if forged requests are sent.
                        // We gate the requests on a randomly generated expected value being returned from the
                        // oauth core login process.
                        if (err.name !== 'urlStateMismatch') {
                            reject(err);
                        }
                        else {
                            if (!server.urlStateMismatchAttempt) {
                                _logger.log(err.message);
                                _.set(server, 'urlStateMismatchAttempt', true);
                            }
                        }
                    }
                    else {
                        resolve();
                    }
                }, type);
            });
        }).then(() => server.close());
        return new Promise((resolve) => {
            server.once('listening', () => {
                resolve({ server, oauthResponse: finishedOAuthPromise });
            });
        });
    })
        .catch((err) => {
        if (err.code === 'EADDRINUSE') {
            throw almError('PortInUse', [err], 'PortInUseAction', [port]);
        }
        else {
            throw err;
        }
    });
};
module.exports.getSocketTimeout = function () {
    return _getSocketTimeout();
};
module.exports.DEFAULT_CLIENT_SOCKET_TIMEOUT = _DEFAULT_CLIENT_SOCKET_TIMEOUT;

//# sourceMappingURL=process.js.map
