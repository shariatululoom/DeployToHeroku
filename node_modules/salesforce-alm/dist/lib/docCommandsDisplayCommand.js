/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
const path = require('path');
// Thirdparty
const Promise = require('bluebird');
const _ = require('lodash');
const spawn = require('child_process').spawn;
// Local
const Config = require(path.join(__dirname, 'configApi')).Config;
const messages = require(path.join(__dirname, 'messages'));
const logger = require(path.join('..', 'lib', 'logApi'));
const main = require(path.join('..', 'index'));
// Post break-up toolbelt, figure out a way to dynamically
// pull in SFDX commands from submodules.
const SFDX_SUB_MODULES = require(path.join('..', 'lib', 'commandRegistry')).SFDX_SUB_MODULES;
/**
 * Command provides help for each SFDX command.  JSON output
 * aggregates all commands into single JSON string.
 */
class DocCommandsDisplayCommand {
    constructor() {
        this.messages = messages(new Config().getLocale());
        this.logger = logger.child('docCommandsDisplayCommand');
        this.cmds = main.commands;
        SFDX_SUB_MODULES.forEach((module) => {
            try {
                // pull module from cli node_modules;
                // try-catch 'cause module may not exist.
                const moduleCmds = require(module).commands; // eslint-disable-line global-require
                if (moduleCmds) {
                    moduleCmds.forEach((moduleCmd) => {
                        this.cmds.push(moduleCmd);
                    });
                }
                else {
                    this.logger.warn(`No commands found in module ${module}`);
                }
            }
            catch (err) {
                this.logger.warn(err.message);
            }
        });
        this.cmds = _.chain(this.cmds)
            .sortBy([function (o) { return o.command ? o.command.toUpperCase() : o.command; }])
            .value();
    }
    validate() {
        return Promise.resolve(null);
    }
    resolveHumanHelp(cmdName) {
        return new Promise((resolve) => {
            const help = spawn('sfdx', [`${cmdName}`, '--help']);
            let helpOut = '';
            help.stdout.on('data', (data) => {
                helpOut += data.toString();
            });
            help.on('close', () => {
                resolve({ cmdName, text: helpOut });
            });
        });
    }
    execute(context) {
        if (!context.flags.json) {
            const promises = [];
            this.cmds.forEach((cmd) => {
                const cmdName = DocCommandsDisplayCommand.getCommandName(cmd);
                promises.push(this.resolveHumanHelp(cmdName));
            });
            return Promise.all(promises).then(values => {
                this.helpOuts = values;
            });
        }
        return Promise.resolve(this.cmds);
    }
    static getCommandName(cmd) {
        if (!_.isNil(cmd)) {
            if (_.isNil(cmd.command)) {
                return `${cmd.topic}`;
            }
            else {
                return `${cmd.topic}:${cmd.command}`;
            }
        }
        return null;
    }
    getHumanSuccessMessage() {
        this.helpOuts.forEach(help => {
            this.logger.styledHeader(this.logger.color.blue(help.cmdName));
            this.logger.log(help.text);
        });
        return '';
    }
}
module.exports = DocCommandsDisplayCommand;

//# sourceMappingURL=docCommandsDisplayCommand.js.map
