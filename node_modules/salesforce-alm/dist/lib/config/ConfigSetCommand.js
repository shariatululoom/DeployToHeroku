/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const varargsCommand_1 = require("../varargsCommand");
// Node
const path = require('path');
// Thirdparty
const _ = require('lodash');
// Local
const Org = require(path.join(__dirname, '..', 'scratchOrgApi'));
const almError = require(path.join(__dirname, '..', 'almError'));
const logger = require(path.join(__dirname, '..', 'logApi'));
const SfdxConfig = require(path.join(__dirname, 'SfdxConfig'));
const messages = require(path.join(__dirname, '..', 'messages'))();
const VALID_CONFIG = {};
function setSfdxConfig(key, value, isGlobal = false) {
    let config;
    try {
        config = new SfdxConfig(isGlobal);
    }
    catch (err) {
        if (err.name === 'InvalidProjectWorkspace') {
            err.message = `${err.message} ${messages.getMessage('globalHelp', [], 'configSetCommand')}`;
        }
        throw err;
    }
    return config.read()
        .then(() => {
        config.setPropertyValue(key, value);
    })
        .then(() => config.write());
}
function setOrgDefault(type, username, isGlobal) {
    if (_.isNil(username)) {
        return setSfdxConfig(type, username, isGlobal);
    }
    else {
        // Ensure the username exits by getting the config.
        return Org.create(username, type).then(() => setSfdxConfig(type, username, isGlobal));
    }
}
// Org types are stored in sfdx-config.json, but set them separate here
// so we go through the org api to check if it is a valid username.
Org.Defaults.list().forEach(type => {
    VALID_CONFIG[type] = setOrgDefault;
});
SfdxConfig.getAllowedProperties().forEach(prop => {
    if (_.isNil(VALID_CONFIG[prop.key])) {
        VALID_CONFIG[prop.key] = setSfdxConfig;
    }
});
// A validator function passed to the Varargs Command that will ensure any key=value pairs
// entered by the user adhere to a whitelist of valid config settings.
const configKeyValidator = (key) => {
    if (!_.isFunction(VALID_CONFIG[key])) {
        throw almError({ keyName: 'UnknownConfigKey', bundle: 'sfdxConfig' }, [key]);
    }
};
class SetCommand extends varargsCommand_1.default {
    constructor() {
        super('config:set', [configKeyValidator]);
        this.successes = [];
        this.failures = [];
    }
    execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
            let promise = Promise.resolve();
            Object.keys(this.keyValuePairs).forEach(name => {
                const value = this.keyValuePairs[name];
                promise = promise.then(() => VALID_CONFIG[name](name, value, context.flags.global))
                    .then(() => {
                    this.successes.push({ name, value });
                })
                    .catch(err => {
                    this.failures.push({ name, message: err.message });
                });
            });
            return promise.then(() => ({ successes: this.successes, failures: this.failures }));
        });
    }
    getHumanSuccessMessage() {
        if (this.successes.length > 0) {
            this.logger.styledHeader(this.logger.color.blue('Set Config'));
            this.logger.table(this.successes, { columns: [
                    { key: 'name', label: 'Name' },
                    { key: 'value', label: 'Value' }
                ] });
        }
        if (this.failures.length > 0) {
            if (this.successes.length > 0) {
                this.logger.log('');
            }
            this.logger.styledHeader(this.logger.color.red('Failures'));
            this.logger.table(this.failures, { columns: [
                    { key: 'name', label: 'Name' },
                    { key: 'message', label: 'Message' }
                ] });
        }
        return '';
    }
}
module.exports = SetCommand;

//# sourceMappingURL=ConfigSetCommand.js.map
