/*
 * Copyright, 1999-2016, salesforce.com
 * All Rights Reserved
 * Company Confidential
 */
'use strict';
// Node
const path = require('path');
// Local
const messages = require(path.join(__dirname, '..', 'messages'))();
const NOT_FOUND_MESSAGE = 'The requested resource does not exist';
const INVALID_TYPE_REGEX = /[\w]*(sObject type '[A-Za-z]*Package[2]?[A-Za-z]*' is not supported)[\w]*/im;
const ID_REGISTRY = [
    {
        prefix: '0Ho',
        label: 'Package2 Id'
    },
    {
        prefix: '05i',
        label: 'Package2 Version Id'
    },
    {
        prefix: '08c',
        label: 'Package2 Version Create Request Id'
    },
    {
        prefix: '04t',
        label: 'Subscriber Package2 Version Id'
    }
];
const LATEST_BUILD_NUMBER_TOKEN = 'LATEST';
const NEXT_BUILD_NUMBER_TOKEN = 'NEXT';
module.exports = {
    BY_PREFIX: (function () {
        const byIds = {};
        ID_REGISTRY.forEach((id) => {
            byIds[id.prefix] = id;
        });
        return byIds;
    })(),
    BY_LABEL: (function () {
        const byLabels = {};
        ID_REGISTRY.forEach((id) => {
            byLabels[id.label.replace(/ /g, '_').toUpperCase()] = id;
        });
        return byLabels;
    })(),
    validateId(idObj, value) {
        if (!value || (value.length !== 15 && value.length !== 18) || !value.startsWith(idObj.prefix)) {
            throw new Error(messages.getMessage('invalidId', [idObj.label, value, idObj.prefix], 'package2'));
        }
    },
    validateVersionNumber(versionNumberString, supportsNext) {
        if (!versionNumberString) {
            throw new Error(messages.getMessage('errorMissingVersionNumber', versionNumberString, 'package2'));
        }
        // split into array of [major, minor, patch, build]
        const versionNumber = versionNumberString.split('.');
        if (versionNumber.length !== 4) {
            throw new Error(messages.getMessage('errorInvalidVersionNumber', versionNumberString, 'package2'));
        }
        if (Number.isNaN(parseInt(versionNumber[3]))) {
            if (supportsNext) {
                if (versionNumber[3] !== NEXT_BUILD_NUMBER_TOKEN) {
                    throw new Error(messages.getMessage('errorInvalidBuildNumber', [versionNumberString, NEXT_BUILD_NUMBER_TOKEN], 'package2'));
                }
            }
            else if (versionNumber[3] !== LATEST_BUILD_NUMBER_TOKEN) {
                throw new Error(messages.getMessage('errorInvalidBuildNumber', [versionNumberString, LATEST_BUILD_NUMBER_TOKEN], 'package2'));
            }
        }
        // Allow non-zero values when patch numbers are supported
        const patch = parseInt(versionNumber[2]);
        if (Number.isNaN(patch) || parseInt(patch) !== 0) {
            throw new Error(messages.getMessage('errorInvalidPatchNumber', versionNumberString, 'package2'));
        }
        if (Number.isNaN(parseInt(versionNumber[1]))) {
            throw new Error(messages.getMessage('errorInvalidMajorMinorNumber', [versionNumberString, 'minor'], 'package2'));
        }
        if (Number.isNaN(parseInt(versionNumber[0]))) {
            throw new Error(messages.getMessage('errorInvalidMajorMinorNumber', [versionNumberString, 'major'], 'package2'));
        }
        return versionNumber;
    },
    // applies actions to common package2 errors
    applyErrorAction(err) {
        // append when actions already exist
        const actions = [];
        // include existing actions
        if (err.action) {
            actions.push(err.action);
        }
        // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
        if ((err.name === 'INVALID_TYPE' && INVALID_TYPE_REGEX.test(err.message))
            || (err.name === 'NOT_FOUND' && err.message === NOT_FOUND_MESSAGE)) {
            // contact sfdc customer service
            actions.push(messages.getMessage('package2NotEnabledAction', [], 'package2'));
        }
        if (actions.length > 0) {
            err.action = actions.join('\n');
        }
        return err;
    },
    /**
     * Given a package descriptor, return the ancestor ID.
     * @param packageDescriptorJson JSON for packageDirectories element in sfdx-project.json
     * @param force For tooling query
     * @param org For tooling query
     */
    getAncestorId(packageDescriptorJson, force, org) {
        return Promise.resolve().then(() => {
            if (!packageDescriptorJson.ancestorVersion) {
                return packageDescriptorJson.ancestorId ? packageDescriptorJson.ancestorId : '';
            }
            else {
                const versionNumber = packageDescriptorJson.ancestorVersion.split('.');
                if (versionNumber.length < 2 || versionNumber.length > 4) {
                    throw new Error(messages.getMessage('errorInvalidAncestorVersionFormat', packageDescriptorJson.ancestorVersion, 'package2'));
                }
                const query = 'SELECT Id FROM Package2Version ' +
                    `WHERE Package2Id = '${packageDescriptorJson.id}' AND IsBeta = false AND MajorVersion = ${versionNumber[0]} AND MinorVersion = ${versionNumber[1]}`;
                return force.toolingQuery(org, query)
                    .then((queryResult) => {
                    if (!queryResult || !queryResult.size) {
                        throw new Error(messages.getMessage('errorNoMatchingAncestor', [packageDescriptorJson.ancestorVersion, packageDescriptorJson.id], 'package2'));
                    }
                    const ancestorId = queryResult.records[0].Id;
                    if (Object.prototype.hasOwnProperty.call(packageDescriptorJson, 'ancestorId') && packageDescriptorJson.ancestorId !== ancestorId) {
                        throw new Error(messages.getMessage('errorAncestorIdVersionMismatch', [packageDescriptorJson.ancestorVersion, packageDescriptorJson.ancestorId], 'package2'));
                    }
                    return ancestorId;
                });
            }
        });
    },
    LATEST_BUILD_NUMBER_TOKEN
};

//# sourceMappingURL=package2Utils.js.map
