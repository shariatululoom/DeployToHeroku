/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// 3pp
const Promise = require('bluebird');
// Node
const path = require('path');
const util = require('util');
const fsx = require('fs-extra');
const parser = require('gitignore-parser');
// Local
const SourceWorkspaceAdapter = require(path.join(__dirname, 'sourceWorkspaceAdapter'));
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil.js'));
const sourceState = require(path.join(__dirname, 'sourceState.js'));
const AggregateSourceElement = require(path.join(__dirname, 'aggregateSourceElement')).AggregateSourceElement;
const TypeDefUtil = require(path.join(__dirname, 'typeDefUtil')).TypeDefUtil;
class SrcStatusApi {
    constructor(scratchOrg, swa) {
        this.scratchOrg = scratchOrg;
        this.force = scratchOrg.force;
        const appConfig = this.force.getConfig().getAppConfig();
        const usingMdapi = true;
        this.swa = swa || new SourceWorkspaceAdapter(this.scratchOrg, appConfig.defaultPackagePath, usingMdapi, MetadataRegistry);
        this.maxRevisionFile = this.scratchOrg.getMaxRevision();
        this.locallyChangedWorkspaceElements = [];
        this.localChanges = [];
        this.remoteChanges = [];
        try {
            this.forceIgnore = parser.compile(fsx.readFileSync(path.join(this.scratchOrg.config.getProjectPath(), '.forceignore'), 'utf8'));
        }
        catch (err) {
            this.forceIgnore = null;
        }
    }
    doStatus(options) {
        return Promise.resolve()
            .then(() => this._populateLocalChanges(options))
            .then(() => this._populateServerChanges(options))
            .then(() => this._markConflicts(options));
    }
    _populateLocalChanges(options) {
        if (!options.local) {
            return [];
        }
        const localSourceElementsMap = this.swa.changedSourceElementsCache;
        return localSourceElementsMap.forEach((value) => {
            value.getWorkspaceElements().forEach((workspaceElement) => {
                value.validateIfDeletedWorkspaceElement(workspaceElement);
                if (options.local && !options.remote) {
                    const localChange = {
                        state: workspaceElement.getState(),
                        fullName: workspaceElement.getFullName(),
                        type: workspaceElement.getTypeDef().metadataName,
                        filePath: workspaceElement.getSourcePath(),
                        isStandardMember: workspaceElement.getIsStandardMember()
                    };
                    this.localChanges.push(localChange);
                }
                else {
                    // if we want to find source conflicts between the workspace and the server,
                    // then pass along the locally changed workspace elements and
                    // populate this.localChanges during the _markConflicts() step
                    this.locallyChangedWorkspaceElements.push(workspaceElement);
                }
            });
        });
    }
    _populateServerChanges(options) {
        if (!options.remote) {
            return [];
        }
        return srcDevUtil.getMaxRevision(this.maxRevisionFile.path)
            .then((maxRevision) => this.force.toolingFind(this.scratchOrg, 'SourceMember', { RevisionNum: { $gt: maxRevision } }, ['MemberType', 'MemberName', 'IsNameObsolete']))
            .then((sourceMembers) => {
            sourceMembers.forEach(sourceMember => {
                sourceMember.MemberName = sourceMember.MemberName.replace(/\//g, path.sep);
                const metadataRegistry = this.swa.metadataRegistry;
                if (this.forceIgnore != null) {
                    // if user wants to ignore a permissionset with fullname abc then we check if forceignore denies abc.permissionset
                    const typeDef = metadataRegistry.getTypeDefinitionByMetadataName(sourceMember.MemberType);
                    if (!util.isNullOrUndefined(typeDef)) {
                        const filename = `${sourceMember.MemberName}.${typeDef.ext}`;
                        if (this.forceIgnore.denies(filename)) {
                            return;
                        }
                    }
                }
                const sourceElement = {};
                sourceElement.fullName = sourceMember.MemberName;
                sourceElement.type = sourceMember.MemberType;
                metadataRegistry.handleIfSharingRuleElement(sourceElement);
                this._setPathIfTypeExistsLocally(sourceElement);
                if (sourceMember.IsNameObsolete) {
                    sourceElement.state = sourceState.DELETED;
                }
                else if (!util.isNullOrUndefined(sourceElement.filePaths) && sourceElement.filePaths.length > 0) {
                    sourceElement.state = sourceState.CHANGED;
                }
                else {
                    sourceElement.state = sourceState.NEW;
                }
                // Convert individually tracked members to the appropriate container.
                // All deletions become changes of the container.
                let memberType = sourceElement.type;
                if (sourceMember.MemberType === 'CustomLabel') {
                    memberType = 'CustomLabels';
                }
                else if (sourceMember.MemberType === 'AutoResponseRule' || sourceMember.MemberType === 'AssignmentRule' || sourceMember.MemberType === 'EscalationRule' || sourceMember.MemberType === 'MatchingRule') {
                    memberType = `${memberType}s`;
                }
                // check if the entity is a supported type
                if ((this.swa.metadataRegistry.isSupported(memberType) || memberType === 'AuraDefinition') && !(memberType === 'AuraDefinitionBundle')) {
                    if (sourceElement.type === 'AuraDefinition') {
                        sourceElement.type = 'AuraDefinitionBundle';
                    }
                    // CustomObjectTranslations are only coarsely tracked so we only want to report that a COT has generally changed rather than reporting each associated filePath
                    if (!util.isNullOrUndefined(sourceElement.filePaths) && sourceElement.filePaths.length > 0 && memberType !== 'CustomObjectTranslation') {
                        sourceElement.filePaths.forEach(filePath => {
                            this.remoteChanges.push({
                                state: sourceElement.state,
                                fullName: sourceElement.fullName,
                                type: sourceElement.type,
                                filePath
                            });
                        });
                    }
                    else {
                        this.remoteChanges.push(sourceElement);
                    }
                }
            });
        })
            .then(() => {
            this.remoteChanges = this.remoteChanges.filter(sm => !(sm.state === sourceState.DELETED && util.isNullOrUndefined(sm.filePath)));
        });
    }
    _setPathIfTypeExistsLocally(sourceElement) {
        const allLocalAggregateElements = this.swa.getAggregateSourceElements(false);
        if (!util.isNullOrUndefined(allLocalAggregateElements)) {
            let sourceMemberTypeDef = this.swa.metadataRegistry.getTypeDefinitionByMetadataName(sourceElement.type);
            // Components of an AuraDefinitionBundle have the MemberType 'AuraDefinition'
            if (util.isNullOrUndefined(sourceMemberTypeDef) && sourceElement.type === 'AuraDefinition') {
                sourceMemberTypeDef = this.swa.metadataRegistry.typeDefs.AuraDefinitionBundle;
            }
            if (!util.isNullOrUndefined(sourceMemberTypeDef)) {
                const aggregateFullName = TypeDefUtil.getAggregateFullNameFromSourceMemberName(this.swa.metadataRegistry, sourceMemberTypeDef, sourceElement.fullName);
                const aggregateTypeDef = !util.isNullOrUndefined(sourceMemberTypeDef.parent) ? sourceMemberTypeDef.parent : sourceMemberTypeDef;
                const key = AggregateSourceElement.getKeyFromMetadataNameAndFullName(aggregateTypeDef.metadataName, aggregateFullName);
                const localAggregateSourceElement = allLocalAggregateElements.get(key);
                if (!util.isNullOrUndefined(localAggregateSourceElement)) {
                    const workspaceElements = localAggregateSourceElement.getWorkspaceElements();
                    if (workspaceElements.length > 0) {
                        sourceElement.filePaths = workspaceElements.filter(workspaceElement => this._remoteFullNameMatchesLocalFullName(sourceElement.fullName, workspaceElement))
                            .map(workspaceElement => workspaceElement.getSourcePath());
                    }
                }
            }
        }
    }
    _markConflicts(options) {
        if (options.local && options.remote) {
            return this.locallyChangedWorkspaceElements.forEach(workspaceElement => {
                // a metadata element with same name and type modified both locally and in the server is considered a conflict
                const localChange = {
                    state: workspaceElement.getState(),
                    fullName: workspaceElement.getFullName(),
                    type: workspaceElement.getTypeDef().metadataName,
                    filePath: workspaceElement.getSourcePath(),
                    isStandardMember: workspaceElement.getIsStandardMember()
                };
                const remoteChanges = this.remoteChanges.filter(r => {
                    // Waiting on W-4389673 to support fine-grained push and pull of AuraDefinitionBundle components
                    // Until they are supported, we will mark conflicts for aura at the bundle level
                    if (workspaceElement.getTypeDef().metadataName === this.swa.metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
                        return TypeDefUtil.getAggregateFullNameFromSourceMemberName(this.swa.metadataRegistry, this.swa.metadataRegistry.typeDefs.AuraDefinitionBundle, r.fullName) ===
                            TypeDefUtil.getAggregateFullNameFromWorkspaceFullName(this.swa.metadataRegistry, workspaceElement.getTypeDef(), workspaceElement.getFullName());
                    }
                    let remoteTypeMatchesLocalType;
                    if (workspaceElement.getTypeDef().isSourceTracked) {
                        remoteTypeMatchesLocalType = r.type === workspaceElement.getTypeDef().metadataName;
                    }
                    else if (!util.isNullOrUndefined(workspaceElement.getTypeDef().parent)) {
                        remoteTypeMatchesLocalType = r.type === workspaceElement.getTypeDef().parent.metadataName;
                    }
                    else {
                        remoteTypeMatchesLocalType = false;
                    }
                    return this._remoteFullNameMatchesLocalFullName(r.fullName, workspaceElement) && remoteTypeMatchesLocalType;
                });
                if (!util.isNullOrUndefined(remoteChanges) && remoteChanges.length > 0) {
                    localChange.isConflict = true;
                    remoteChanges.forEach(remoteChange => { remoteChange.isConflict = true; });
                }
                this.localChanges.push(localChange);
            });
        }
        else {
            return [];
        }
    }
    getLocalChanges() {
        return this.localChanges;
    }
    getRemoteChanges() {
        return this.remoteChanges;
    }
    getLocalConflicts() {
        const conflictingAuraBundles = new Set();
        return this.localChanges.filter(item => {
            // Waiting on W-4389673 to support fine-grained push and pull of AuraDefinitionBundle components
            // Until they are supported, we only want to report one conflict entry per bundle
            if (item.type === this.swa.metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName &&
                item.isConflict) {
                const aggregateFullName = TypeDefUtil.getAggregateFullNameFromWorkspaceFullName(this.swa.metadataRegistry, this.swa.metadataRegistry.typeDefs.AuraDefinitionBundle, item.fullName);
                if (!conflictingAuraBundles.has(aggregateFullName)) {
                    conflictingAuraBundles.add(aggregateFullName);
                    return true;
                }
                return false;
            }
            return item.isConflict;
        }).map(item => {
            // Since we are only printing one conflict per bundle, print the path to the bundle and aggregate fullName
            if (item.type === this.swa.metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
                return {
                    state: item.state,
                    fullName: TypeDefUtil.getAggregateFullNameFromWorkspaceFullName(this.swa.metadataRegistry, this.swa.metadataRegistry.typeDefs.AuraDefinitionBundle, item.fullName),
                    type: item.type,
                    filePath: path.dirname(item.filePath),
                    isStandardMember: item.isStandardMember
                };
            }
            return item;
        });
    }
    /**
     * The level of granularity of source tracking differs between the server and the workspace
     * Returns whether or not a sourceMember fullName corresponds to a local workspace element
     * @param sourceMemberFullName
     * @param workspaceElement
     * @returns {boolean}
     * @private
     */
    _remoteFullNameMatchesLocalFullName(sourceMemberFullName, workspaceElement) {
        const workspaceElementFullName = workspaceElement.getFullName();
        if (workspaceElement.getTypeDef().isSourceTracked) {
            return workspaceElementFullName === sourceMemberFullName;
        }
        else {
            const aggregateElementFullName = TypeDefUtil.getAggregateFullNameFromWorkspaceFullName(this.swa.metadataRegistry, workspaceElement.getTypeDef(), workspaceElementFullName);
            return aggregateElementFullName === sourceMemberFullName;
        }
    }
}
module.exports = SrcStatusApi;

//# sourceMappingURL=srcStatusApi.js.map
