/*
 * Copyright (c) 2017, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require('path');
const MetadataRegistry = require('./metadataRegistry');
/**
 * Workspace decomposition strategy where metadata files do not require decomposition
 */
class NonDecomposedWorkspaceStrategy {
    constructor(decompositionConfig) {
        this.decompositionConfig = decompositionConfig;
    }
    /**
     * Returns null because this strategy has no decompositions
     * @param annotation
     * @param decomposedSubtypeConfig
     * @returns {null}
     */
    getDecomposedFileName(annotation, decomposedSubtypeConfig) {
        return null;
    }
    /**
     * For non-decomposed source, the metadata file path is also the container path
     * @param metadataFilePath
     * @param ext
     * @returns {any}
     */
    getContainerPath(metadataFilePath, ext) {
        return metadataFilePath;
    }
    /**
     * Returns an empty map because this strategy has no decompositions
     * @param metadataFilePath
     * @param ext
     * @returns {Map<DecomposedSubtypeConfig, string[]>}
     */
    findDecomposedPaths(metadataFilePath, ext) {
        return new Map();
    }
    /**
     * Returns null because this strategy has no decompositions
     * @param metadataFilePath
     * @param ext
     * @param decomposedSubtypeConfig
     * @returns {null}
     */
    getDecomposedSubtypeDirFromMetadataFile(metadataFilePath, ext, decomposedSubtypeConfig) {
        return null;
    }
    /**
     * Returns the path to the nondecomposed file, in this case the metadata file path
     * @param decomposedPath
     * @param typeDef
     * @returns {any}
     */
    getNondecomposedFilePath(decomposedPath, typeDef) {
        // The workspace strategy should technically only deal with metadata files in the workspace
        // and should only be used in AggregateSourceElement. However, this method is currently being
        // exploited in TypeDefUtil until typeDefs become first class
        // TODO: Remove handling of non -meta.xml files when the typeDefs become first class
        if (!decomposedPath.endsWith(MetadataRegistry.getMetadataFileExt())) {
            decomposedPath = `${decomposedPath}${MetadataRegistry.getMetadataFileExt()}`;
        }
        return decomposedPath;
    }
}
exports.NonDecomposedWorkspaceStrategy = NonDecomposedWorkspaceStrategy;

//# sourceMappingURL=nonDecomposedWorkspaceStrategy.js.map
