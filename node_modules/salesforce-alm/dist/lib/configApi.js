/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
// Node
const fs = require('fs');
const util = require('util');
const path = require('path');
// Thirdparty
const optional = require('optional-js');
const Promise = require('bluebird');
const _ = require('lodash');
// Local module object.
const SfdxConfig = require(path.join(__dirname, 'config', 'SfdxConfig'));
const errors = require(path.join(__dirname, 'errors'));
const messages = require(path.join(__dirname, 'messages'));
const almError = require(path.join('..', 'lib', 'almError'));
const projectDirectory = require(path.join(__dirname, 'projectDir'));
const pjson = require(path.join('..', '..', 'package.json'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const consts = require(path.join(__dirname, 'constants'));
const importSfdxProjectSchema = path.join(__dirname, '..', '..', 'schemas', 'sfdxProjectSchema.json');
const SchemaValidator = require(path.join(__dirname, 'schema', 'schemaValidator'));
const logApi = require(path.join(__dirname, 'logApi'));
const _DEFAULT_PORT = 1717;
const fsWriteFile = Promise.promisify(fs.writeFile);
const checkHiddenStateFolder = function (projectDir) {
    const stateFolderPath = path.join(projectDir, srcDevUtil.getWorkspaceStateFolderName());
    if (!srcDevUtil.pathExistsSync(stateFolderPath)) {
        try {
            // Make sure state folder exists in the root of the workspace.
            // @todo Fix sync.
            fs.mkdirSync(stateFolderPath);
        }
        catch (err) {
            // Rethrow the error if it's something other than directory already exists.
            if (err.code !== 'EEXIST') {
                throw err;
            }
        }
    }
};
// constructor
module.exports.Config = function (projectDir) {
    this.projectDir = projectDir;
    this.pjson = pjson;
    this.validator = new SchemaValidator(logApi, importSfdxProjectSchema);
};
const _throwUnexpectedVersionFormat = function (incorrectVersion) {
    const errorName = 'UnexpectedVersionFormat';
    throw srcDevUtil.getError(messages().getMessage(errorName, [incorrectVersion], 'versionCommand'), errorName);
};
/**
 * Return the salesforce toolbelt api version:
 *
 * How we find the version number:
 * 1) see if it's defined in $HOME/.sfdx/sfdx-project.json
 * 2) Otherwise get it from package.json.
 *
 * @returns {string}
 */
module.exports.Config.prototype.getApiVersion = function () {
    // If we already stored an api version return it.
    if (!util.isNullOrUndefined(this.apiVersion)) {
        return this.apiVersion;
    }
    try {
        // Attempt to get the apiVersion from $HOME/.sfdx/sfdx-config.json
        // This should not use SfdxAggregator because we only allow apiVersion
        // at the global level.
        const globalConfig = new SfdxConfig(true).readSync();
        let localConfig;
        try {
            localConfig = new SfdxConfig(false).readSync();
        }
        catch (e) {
            // This could be a non-project directory;    
        }
        // local takes precedence; also sfdx config defaults to returning an empty object when
        // no config is defined.
        const _config = _.merge({}, globalConfig, localConfig);
        const apiVersionRegEx = /\bv?(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)/;
        if (apiVersionRegEx.test(_config.apiVersion)) {
            this.apiVersion = _config.apiVersion;
        }
        else if (!util.isNullOrUndefined(_config.apiVersion)) {
            _throwUnexpectedVersionFormat(_config.apiVersion);
        }
        // else proceed
    }
    catch (e) {
        if (e.code !== 'ENOENT') {
            throw e;
        }
    }
    // Not globally defined so the apiVersion comes off of package.json version.
    if (util.isNullOrUndefined(this.apiVersion)) {
        // No version specified in pjson - unlikely but...
        if (util.isNullOrUndefined(this.pjson.version)) {
            const errorName = 'MissingVersionAttribute';
            throw srcDevUtil.getError(messages().getMessage(errorName, null, 'versionCommand'), errorName);
        }
        const versionTrimmed = this.pjson.version.trim();
        const sfdxValidVersionRegEx = /\bv?(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)(?:-[\da-z\-]+(?:\.[\da-z\-]+)*)?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?\b/ig;
        if (sfdxValidVersionRegEx.test(versionTrimmed)) {
            this.apiVersion = `${versionTrimmed.split('.')[0]}.0`;
        }
        else {
            _throwUnexpectedVersionFormat(versionTrimmed);
        }
    }
    return this.apiVersion;
};
module.exports.Config.prototype.getProjectPath = function () {
    if (util.isNullOrUndefined(this.projectDir)) {
        this.projectDir = projectDirectory.getPath();
        checkHiddenStateFolder(this.projectDir);
    }
    return this.projectDir;
};
// The toolbelt only supports us english.
module.exports.Config.prototype.getLocale = function () {
    return messages().getLocale();
};
/**
 * Users may override the oauth port used for the http server.
 * @returns {number} 1717 is the default listen port number
 */
module.exports.Config.prototype.getOauthLocalPort = function () {
    const configPort = Number(optional.ofNullable(this.getAppConfigIfInWorkspace().OauthLocalPort).orElse(_DEFAULT_PORT));
    if (Number.isNaN(configPort) || configPort < 1 || configPort > (Math.pow(2, 16) - 1)) {
        const error = new Error(messages(this.getLocale()).getMessage('invalidPortNumber', configPort));
        error.name = 'InvalidOAuthRedirectUrlPort';
        throw error;
    }
    return configPort;
};
/**
 * @returns {string} The App Cloud standard Connected App Callback URL.
 */
module.exports.Config.prototype.getOauthCallbackUrl = function () {
    return `http://localhost:${this.getOauthLocalPort()}/OauthRedirect`;
};
/**
 * Reads the app config from disk and caches it.
 * @returns {*} A key value.
 */
module.exports.Config.prototype.getAppConfig = function () {
    if (util.isNullOrUndefined(this.appConfig)) {
        this.appConfig = this.getConfigContent();
    }
    return this.appConfig;
};
/**
 * Reads the workspace app config, if we are in a workspace.
 * @param {object} force The force object
 * @returns {object} the workspace config object, or an empty object if not in a workspace
 */
module.exports.Config.prototype.getAppConfigIfInWorkspace = function () {
    try {
        return this.getAppConfig();
    }
    catch (e) {
        if (e.name !== 'InvalidProjectWorkspace') {
            throw e;
        }
    }
    return {};
};
module.exports.Config.prototype.getGlobalHiddenFolder = function () {
    return srcDevUtil.getGlobalHiddenFolder();
};
module.exports.Config.prototype.getWorkspaceConfigFilename = function () {
    return consts.WORKSPACE_CONFIG_FILENAME;
};
module.exports.Config.prototype.getOldAndBustedWorkspaceConfigFilename = function () {
    return consts.OLD_WORKSPACE_CONFIG_FILENAME;
};
module.exports.Config.prototype.setWorkspaceTypeDefault = function (type, username) {
    const config = {};
    config[type] = username;
    _.assign(this.getAppConfig(), config);
    return this.setWorkspaceOrgConfigContent(this.getProjectPath(), config);
};
/**
 * Copy the artifact paths out of the sfdx-project.json, if they exist.
 *
 * @param messagesLocale This is for unit tests to solve a dependency issue
 * @param configObject The app config object
 * @param workspaceConfig The JSON representation of the workspace config file.
 * @param projectDir The root workspace directory
 * @returns {*} An array representing the artifact paths.
 */
const _extractPackageDirPaths = function (messagesLocale, configObject, workspaceConfig, projectDir) {
    const pathsArray = [];
    const packageDirectories = workspaceConfig.packageDirectories;
    if (!util.isNullOrUndefined(packageDirectories) && packageDirectories.length !== 0) {
        packageDirectories.forEach((packageDir) => {
            if (!util.isNullOrUndefined(packageDir.path)) {
                if (path.isAbsolute(packageDir.path)) {
                    const error = new Error(messagesLocale.getMessage('InvalidAbsolutePath', packageDir.path));
                    error.name = 'InvalidProjectWorkspace';
                    throw error;
                }
                pathsArray.push(path.resolve(projectDir, packageDir.path));
            }
            if (!util.isNullOrUndefined(packageDir.default)) {
                if (typeof (packageDir.default) !== 'boolean') {
                    const error = new Error(messagesLocale.getMessage('InvalidValueForDefaultPath'));
                    error.name = 'InvalidProjectWorkspace';
                    throw error;
                }
                if (packageDir.default === true) {
                    if (util.isNullOrUndefined(configObject.defaultPackagePath)) {
                        configObject.defaultPackagePath = packageDir.path;
                    }
                    else {
                        const error = new Error(messagesLocale.getMessage('MultipleDefaultPaths'));
                        error.name = 'InvalidProjectWorkspace';
                        throw error;
                    }
                }
            }
            else if (packageDirectories.length === 1) {
                configObject.defaultPackagePath = packageDir.path;
            }
        });
    }
    if (util.isNullOrUndefined(configObject.defaultPackagePath)) {
        const error = new Error(messagesLocale.getMessage('MissingDefaultPath'));
        error.name = 'InvalidProjectWorkspace';
        throw error;
    }
    return pathsArray;
};
module.exports.Config.prototype._getConfigContent = function (projectDir, workspaceConfigObject) {
    let configObject;
    try {
        // get sfdx-project.json from the ~/.sfdx directory
        configObject = srcDevUtil.getGlobalConfigSync(this.getWorkspaceConfigFilename());
        // Verify that the configObject does not have upper case keys; throw if it does.  Must be heads down camelcase.
        const upperCaseKey = srcDevUtil.findUpperCaseKeys(configObject);
        if (upperCaseKey) {
            throw almError('InvalidJsonCasing', [upperCaseKey, JSON.stringify(configObject, null, 4)]);
        }
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            configObject = {};
        }
        else {
            throw e;
        }
    }
    // Add additional fields from the workspace sfdx-project.json
    const projectConfigDotJsonPath = path.join(projectDir, this.getWorkspaceConfigFilename());
    try {
        // Verify that the workspaceConfigObject does not have upper case keys; throw if it does.  Must be heads down camelcase.
        const upperCaseKey = srcDevUtil.findUpperCaseKeys(workspaceConfigObject);
        if (upperCaseKey) {
            throw almError('InvalidJsonCasing', [upperCaseKey, JSON.stringify(workspaceConfigObject, null, 4)]);
        }
        const defaultConfig = {
            packageDirectoryPaths: _extractPackageDirPaths(messages(this.getLocale()), configObject, workspaceConfigObject, projectDir),
            sfdcLoginUrl: 'https://login.salesforce.com',
            defaultSrcWaitMinutes: consts.DEFAULT_SRC_WAIT_MINUTES,
            defaultSrcWaitMs: consts.DEFAULT_SRC_WAIT_MINUTES * 60000,
            defaultMdapiPollIntervalMinutes: consts.DEFAULT_MDAPI_POLL_INTERVAL_MINUTES,
            defaultMdapiPollIntervalMs: consts.DEFAULT_MDAPI_POLL_INTERVAL_MINUTES * 60000,
            defaultMdapiWaitMinutes: consts.DEFAULT_MDAPI_WAIT_MINUTES
        };
        _.defaults(configObject, workspaceConfigObject, defaultConfig);
        // TODO move to SfdxAggregator when this method is converted to async
        // Add fields in sfdx-config.json
        const workspaceOrgConfigPath = srcDevUtil.getWorkspaceOrgConfigPath(projectDir);
        if (srcDevUtil.pathExistsSync(workspaceOrgConfigPath)) {
            try {
                const fileContents = fs.readFileSync(workspaceOrgConfigPath, 'utf8');
                if (fileContents.length) {
                    _.assign(configObject, JSON.parse(fileContents));
                }
            }
            catch (e) {
                throw srcDevUtil.processReadAndParseJsonFileError(e, workspaceOrgConfigPath);
            }
        }
        // Allow override of sfdcLoginUrl via env var FORCE_SFDC_LOGIN_URL
        if (process.env.FORCE_SFDC_LOGIN_URL) {
            configObject.sfdcLoginUrl = process.env.FORCE_SFDC_LOGIN_URL;
        }
        return configObject;
    }
    catch (e) {
        throw srcDevUtil.processReadAndParseJsonFileError(e, projectConfigDotJsonPath);
    }
};
const _getWorkspaceConfigObject = function (projectConfigDotJsonPath) {
    if (srcDevUtil.pathExistsSync(projectConfigDotJsonPath)) {
        return JSON.parse(fs.readFileSync(projectConfigDotJsonPath, 'utf8'));
    }
    else {
        throw new errors.MissingAppConfig();
    }
};
// Get the sfdx-project.json file from the workspace
module.exports.Config.prototype.getConfigContentWithValidation = function (projectDir = this.getProjectPath()) {
    const projectConfigDotJsonPath = path.join(projectDir, this.getWorkspaceConfigFilename());
    const workspaceConfigObject = _getWorkspaceConfigObject(projectConfigDotJsonPath);
    return this.validator.validate(workspaceConfigObject)
        .then(() => this._getConfigContent(projectDir, workspaceConfigObject))
        .catch((err) => {
        if (err.name === 'ValidationSchemaFieldErrors') {
            throw almError({
                bundle: 'configGetCommand',
                keyName: 'sfdxProjectValidationFailure'
            }, ['sfdx-project.json', err.message]);
        }
        throw err;
    });
};
module.exports.Config.prototype.getConfigContent = function (projectDir = this.getProjectPath()) {
    const projectConfigDotJsonPath = path.join(projectDir, this.getWorkspaceConfigFilename());
    const workspaceConfigObject = _getWorkspaceConfigObject(projectConfigDotJsonPath);
    return this._getConfigContent(projectDir, workspaceConfigObject);
};
/**
 * Updates a config object on disk.
 * @param config The object to save.
 * @param projectDir The absolute path to the directory containing the workspace.
 */
module.exports.Config.prototype.setWorkspaceOrgConfigContent = function (projectDir, config) {
    if (!util.isNullOrUndefined(config)) {
        srcDevUtil.ensureDirectoryExistsSync(path.join(projectDir, srcDevUtil.getWorkspaceStateFolderName()));
        let promise = Promise.resolve({});
        if (srcDevUtil.pathExistsSync(srcDevUtil.getWorkspaceOrgConfigPath(projectDir))) {
            promise = srcDevUtil.readJSON(srcDevUtil.getWorkspaceOrgConfigPath(projectDir));
        }
        return promise.then(existingConfig => _.assign(existingConfig, config))
            .then(newConfig => 
        // file is customer-editable, so write w/ spaces for readability
        fsWriteFile(srcDevUtil.getWorkspaceOrgConfigPath(projectDir), JSON.stringify(newConfig, null, 4), { flag: 'w', encoding: 'utf-8' }));
    }
    else {
        throw new errors.MissingRequiredParameter(config);
    }
};
module.exports.Config.defaultSrcWaitMinutes = consts.DEFAULT_SRC_WAIT_MINUTES;
module.exports.Config.defaultSrcWaitMs = consts.DEFAULT_SRC_WAIT_MINUTES * 60000;
module.exports.Config.defaultMdapiPollIntervalMinutes = consts.DEFAULT_MDAPI_POLL_INTERVAL_MINUTES;
module.exports.Config.defaultMdapiPollIntervalMs = consts.DEFAULT_MDAPI_POLL_INTERVAL_MINUTES * 60000;
module.exports.Config.defaultMdapiWaitMinutes = consts.DEFAULT_MDAPI_WAIT_MINUTES;

//# sourceMappingURL=configApi.js.map
