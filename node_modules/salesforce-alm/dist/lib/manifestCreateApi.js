/*
* Copyright (c) 2016, salesforce.com, inc.
* All rights reserved.
* Licensed under the BSD 3-Clause license.
* For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
*/
"use strict";
// Node
const path = require('path');
const fs = require('fs');
const util = require('util');
// Thirdparty
const optional = require('optional-js');
const Promise = require('bluebird');
const xml2js = require('xml2js');
const _ = require('lodash');
// Local
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const logApi = require(path.join(__dirname, 'logApi'));
const almError = require(path.join(__dirname, 'almError'));
// Promisify
const fsStat = Promise.promisify(fs.stat);
const fsWriteFile = Promise.promisify(fs.writeFile);
const fsReaddir = Promise.promisify(fs.readdir);
const fsMkdir = Promise.promisify(fs.mkdir);
const objectSnowflakes = [
    { component: 'fields', manifestName: 'CustomField' },
    { component: 'compactLayouts', manifestName: 'CompactLayout' },
    { component: 'listViews', manifestName: 'ListView' },
    { component: 'validationRules', manifestName: 'ValidationRule' },
    { component: 'webLinks', manifestName: 'WebLink' },
    { component: 'recordTypes', manifestName: 'RecordType' },
    { component: 'fieldSets', manifestName: 'FieldSet' }
];
function createOutputXmlManifestFile(fileName, packageManifestJson) {
    const xmlBuilder = new xml2js.Builder({ xmldec: { version: '1.0', encoding: 'UTF-8' } });
    const xml = xmlBuilder.buildObject(packageManifestJson);
    return fsWriteFile(fileName, xml)
        .then(() => ({ file: fileName, manifest: packageManifestJson }));
}
function generateMetadataManifestJson(packageName, typesAsKeyValuePairsArray, apiVersion) {
    const MdapiPackage = require(path.join(__dirname, 'mdapiPackage')); // eslint-disable-line global-require
    const mdPackage = new MdapiPackage();
    mdPackage.setVersion(apiVersion);
    if (!util.isNullOrUndefined(packageName)) {
        mdPackage.setPackageName(packageName);
    }
    typesAsKeyValuePairsArray.forEach((typeNamePair) => {
        mdPackage.addMember(typeNamePair.name, typeNamePair.type);
    });
    return mdPackage.getPackage();
}
function processMetadataFile(dir, file, childLogger, metadataRegistry) {
    const filePath = path.resolve(dir, file);
    const typeDef = metadataRegistry.getTypeDefinitionByFileName(filePath);
    let fileInfo = null;
    if (!util.isNullOrUndefined(typeDef)) {
        const fullName = srcDevUtil.getFqnForPath(typeDef, filePath, true, metadataRegistry);
        if (!util.isNullOrUndefined(fullName)) {
            fileInfo = { type: typeDef.metadataName, name: fullName };
        }
    }
    if (fileInfo === null) {
        childLogger.info(`WARNING: Error parsing metadata file.  Ignoring - ${filePath}`);
    }
    return Promise.resolve(fileInfo);
}
function isExcluded(typeDef, name) {
    return (typeDef === 'CustomObject' && !name.includes('__c') && !name.includes('__mdt'))
        || (typeDef === 'CustomLabels');
}
function readMetadataDirectoryContent(dir) {
    return fsReaddir(dir)
        .then((files) => Promise.map(files, (file) => fsStat(path.resolve(dir, file))
        .then((stats) => ({ name: file, isDirectory: stats.isDirectory() }))))
        .then((fileInfoArray) => {
        const dirContent = { metadataFiles: [], dirs: [] };
        fileInfoArray.forEach((fileInfo) => {
            if (fileInfo.isDirectory) {
                dirContent.dirs.push(fileInfo.name);
            }
            else if (fileInfo.name.endsWith(MetadataRegistry.getMetadataFileExt())) {
                dirContent.metadataFiles.push(fileInfo.name);
            }
        });
        return dirContent;
    });
}
function processMetadataFileManifestCreate(dir, file, childLogger, metadataRegistry) {
    const filePath = path.resolve(dir, file);
    // normally this maps a decomposed component to the parent is was decomposed from.  For manifest creation we
    // want to keep the actual type.
    const typeDef = metadataRegistry.getTypeDefinitionByFileName(filePath, true);
    const fileInfo = [];
    const fullName = !util.isNullOrUndefined(typeDef)
        ? srcDevUtil.getFqnForPath(typeDef, filePath, true, metadataRegistry, true) : null;
    const isCustomObject = path.basename(filePath)
        .endsWith(metadataRegistry.typeDefs.CustomObject.ext + metadataRegistry.metadataFileExt);
    const isLabel = path.basename(filePath)
        .endsWith(metadataRegistry.typeDefs.CustomLabels.ext + metadataRegistry.metadataFileExt);
    if (isCustomObject || isLabel) {
        const parser = new xml2js.Parser();
        parser.parseString(fs.readFileSync(filePath, 'utf8'), (err, result) => {
            const json = JSON.parse(JSON.stringify(result));
            if (isCustomObject) {
                objectSnowflakes.forEach((key) => {
                    const components = json.CustomObject[key.component];
                    if (!_.isNil(components)) {
                        components.forEach((component) => fileInfo.push({ type: key.manifestName, name: `${fullName}.${component.fullName[0]}` }));
                    }
                });
            }
            else {
                const components = json.CustomLabels.labels;
                if (!_.isNil(components)) {
                    components.forEach((component) => fileInfo.push({ type: 'CustomLabel', name: component.fullName[0] }));
                }
            }
        });
    }
    if (!_.isNil(fullName) && !isExcluded(typeDef.metadataName, fullName)) {
        const typeName = isLabel ? 'CustomLabel' : typeDef.metadataName;
        fileInfo.push({ type: typeName, name: fullName });
    }
    if (fileInfo === null) {
        childLogger.info(`WARNING: Error parsing metadata file.  Ignoring - ${filePath}`);
    }
    return Promise.resolve(fileInfo);
}
function processMetadataDirectory(dir, childLogger, metadataRegistry, manifestcreate) {
    return readMetadataDirectoryContent(dir)
        .then((entriesToBeProcessed) => Promise.map(entriesToBeProcessed.metadataFiles, file => 
    // The manifestcreate param was added to indicate whether or not this processing is for generating a
    // package2 manifest file. If so, it requires special behavior: introspecting metadata files,
    // renaming for snowflake components, and special handling to use child instead of parent types
    // in a decomposed workspace.
    (!_.isNil(manifestcreate)
        ? processMetadataFileManifestCreate(dir, file, childLogger, metadataRegistry)
        : processMetadataFile(dir, file, childLogger, metadataRegistry)))
        .then((resultFromFiles) => Promise.all([resultFromFiles,
        Promise.map(entriesToBeProcessed.dirs, (childDir) => processMetadataDirectory(path.resolve(dir, childDir), childLogger, metadataRegistry, manifestcreate))])))
        .then((resultAsKeyValuePairs) => {
        // Flatten result from previous step which contains multi-level arrays due
        // to the way promise combines results from files in current directory and files
        // in child directory.
        const elementsToProcess = [];
        const flattenedResultObj = [];
        elementsToProcess.push(resultAsKeyValuePairs);
        while (elementsToProcess.length > 0) {
            const nextElement = elementsToProcess[0];
            if (Array.isArray(nextElement)) {
                if (nextElement.length > 0) {
                    for (const element of nextElement) {
                        if (element) {
                            elementsToProcess.push(element);
                        }
                    }
                }
            }
            else if (nextElement) {
                flattenedResultObj.push(nextElement);
            }
            elementsToProcess.shift();
        }
        return flattenedResultObj;
    });
}
/**
 * API object to create manifest file.
 *
 * @constructor
 */
const manifestCreate = function (org, beforeManifestGenerationHook) {
    this.org = org;
    this.config = this.org.config;
    this.apiVersion = this.config.getApiVersion();
    this.logger = logApi.child('manifest-create');
    this._fsStat = fsStat;
    this._fsMkdir = fsMkdir;
    this.beforeManifestGenerationHook = beforeManifestGenerationHook;
};
manifestCreate.prototype.execute = function execute(context) {
    const projectDirectory = this.config.getProjectPath();
    const appConfig = this.config.getAppConfig();
    // use defaultArtifact which is root dir of source (if set, prepend project dir)
    const defaultSourceDirectory = !util.isNullOrUndefined(appConfig.defaultPackagePath) ?
        path.join(projectDirectory, appConfig.defaultPackagePath) : projectDirectory;
    const rootDirectory = optional.ofNullable(context.sourcedir).orElse(defaultSourceDirectory);
    this.outputDirectory = optional.ofNullable(context.outputdir).orElse(projectDirectory);
    const outputFile = path.resolve(this.outputDirectory, 'package.xml');
    const apiVersion = this.apiVersion;
    const orgApi = this.org;
    return this._validateDirectory(rootDirectory, almError('InvalidArgumentDirectoryPath', ['sourcedir', rootDirectory]))
        .then(() => this._createDirIfNotExists(this.outputDirectory))
        .then(() => this._validateDirectory(this.outputDirectory, almError('InvalidArgumentDirectoryPath', ['outputdir', this.outputDirectory])))
        .then(() => MetadataRegistry.initializeMetadataTypeInfos(orgApi))
        .then(() => {
        this.metadataRegistry = new MetadataRegistry(orgApi);
        return processMetadataDirectory(rootDirectory, this.logger, this.metadataRegistry);
    })
        .then((resultAsKeyValuePairs) => {
        if (this.beforeManifestGenerationHook) {
            resultAsKeyValuePairs = this.beforeManifestGenerationHook(resultAsKeyValuePairs);
        }
        if (context.exclusions) {
            resultAsKeyValuePairs = resultAsKeyValuePairs.filter(element => _.isNil(context.exclusions.find(exclusion => exclusion.type === element.type && exclusion.name === element.name)));
        }
        const packageManifestJson = generateMetadataManifestJson(context.packageName, resultAsKeyValuePairs, apiVersion);
        return createOutputXmlManifestFile(outputFile, packageManifestJson);
    });
};
manifestCreate.prototype.createManifest = function (context, packageName, typeFullNamePairs) {
    const outputDir = optional.ofNullable(context.outputdir).orElse(this.config.getProjectPath());
    const outputFile = path.resolve(outputDir, optional.ofNullable(context.outputfile).orElse('package.xml'));
    const sourceApiVersion = !util.isNullOrUndefined(context.sourceApiVersion) ? context.sourceApiVersion : this.apiVersion;
    const packageManifestJson = generateMetadataManifestJson(packageName, typeFullNamePairs, sourceApiVersion);
    return createOutputXmlManifestFile(outputFile, packageManifestJson);
};
/**
 * Creates an mdapi compatible package.xml manifest from an mdapiPackage
 * @param {object} context - looking for context.outputdir; location for writing the package.xml
 * @param {object} mdapiPackage - The mdapi package
 */
manifestCreate.prototype.createManifestForMdapiPackage = function (context, mdapiPackage, metadataRegistry) {
    const outputFile = path.resolve(optional.ofNullable(context.outputdir).orElse(this.config.getProjectPath()), 'package.xml');
    return createOutputXmlManifestFile(outputFile, mdapiPackage.getPackage(metadataRegistry));
};
manifestCreate.prototype._validateDirectory = function (dir, failWithErr) {
    return this._fsStat(dir)
        .then((dirStats) => {
        if (!dirStats.isDirectory()) {
            return Promise.reject(failWithErr);
        }
        return Promise.resolve();
    })
        .catch((err) => {
        if (err.code === 'ENOENT') {
            return Promise.reject(almError('PathDoesNotExist', dir));
        }
        return Promise.reject(err);
    });
};
manifestCreate.prototype._createDirIfNotExists = function (dir) {
    return this._fsStat(dir).then(() => { })
        .catch((err) => {
        if (err.code === 'ENOENT') {
            return this._fsMkdir(dir);
        }
        return Promise.reject(err);
    });
};
module.exports = manifestCreate;

//# sourceMappingURL=manifestCreateApi.js.map
