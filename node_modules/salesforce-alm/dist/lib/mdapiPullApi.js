/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// 3pp
const Promise = require('bluebird');
// Node
const path = require('path');
const fs = Promise.promisifyAll(require('fs-extra'));
const os = require('os');
const util = require('util');
// Local
const logger = require(path.join('..', 'lib', 'logApi'));
const MdapiRetrieveApi = require(path.join(__dirname, 'mdapiRetrieveApi'));
const SourceWorkspaceAdapter = require(path.join(__dirname, 'sourceWorkspaceAdapter'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const ManifestCreateApi = require(path.join(__dirname, 'manifestCreateApi'));
const SourceMetadataMemberRetrieveHelper = require(path.join(__dirname, 'sourceMetadataMemberRetrieveHelper'));
const syncCommandHelper = require(path.join(__dirname, 'syncCommandHelper'));
const messagesApi = require(path.join(__dirname, 'messages'));
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const srcStatusApi = require(path.join(__dirname, 'srcStatusApi'));
class MdapiPullApi {
    constructor(scratchOrg) {
        this.scratchOrg = scratchOrg;
        this.force = scratchOrg.force;
        this.logger = logger.child('md-pull');
        const usingMdapi = true;
        this.swa = new SourceWorkspaceAdapter(this.scratchOrg, this.force.getConfig().getAppConfig().defaultPackagePath, usingMdapi, MetadataRegistry);
        this.maxRevisionFile = this.scratchOrg.getMaxRevision();
        this.smmHelper = new SourceMetadataMemberRetrieveHelper(this.swa.metadataRegistry);
        this.messages = messagesApi(this.force.config.getLocale());
        this.obsoleteNames = [];
    }
    doPull(options) {
        // Remove this when pull has been modified to support the new mdapi wait functionality;
        if (isNaN(options.wait)) {
            options.wait = this.force.config.getConfigContent().defaultSrcWaitMinutes;
        }
        return Promise.resolve()
            .then(() => this._checkForConflicts(options))
            .then(() => MdapiPullApi._createAndConfigureRetrieveTarget(options))
            .then(() => srcDevUtil.getMaxRevision(this.maxRevisionFile.path))
            .then((maxRevision) => this.smmHelper.getRevisionsAsPackage(maxRevision, this.obsoleteNames))
            .then((pkg) => this._createPackageManifest(options, pkg))
            .then((manifest) => {
            if (manifest.empty) {
                if (this.obsoleteNames.length > 0) {
                    return Promise.resolve({ fileProperties: [], success: true, status: 'Succeeded' });
                }
                else {
                    return Promise.resolve();
                }
            }
            options.unpackaged = manifest.file;
            options.manifest = manifest.manifest;
            return this._mdapiPull(options);
        })
            .then((result) => this._postRetrieve(result, options));
    }
    static _createAndConfigureRetrieveTarget(options) {
        options.retrievetargetdir = path.join(os.tmpdir(), `sdx_pull_${Date.now()}`);
        options.outputdir = options.retrievetargetdir;
        return Promise.resolve().then(() => srcDevUtil.ensureDirectoryExistsSync(options.retrievetargetdir));
    }
    _createPackageManifest(options, pkg) {
        if (pkg.isEmpty()) {
            return Promise.resolve({ empty: true });
        }
        if (util.isNullOrUndefined(options.packageXml) || !options.debug) {
            const configSourceApiVersion = this.force.getConfig().getAppConfig().sourceApiVersion;
            const sourceApiVersion = !util.isNullOrUndefined(configSourceApiVersion) ? configSourceApiVersion : this.force.getConfig().getApiVersion();
            pkg.setVersion(sourceApiVersion);
            return Promise.resolve(new ManifestCreateApi(this.force).createManifestForMdapiPackage(options, pkg, this.smmHelper.metadataRegistry));
        }
        else {
            return Promise.resolve({ file: options.packageXml });
        }
    }
    _mdapiPull(options) {
        // Push the source
        options.autoUpdatePackage = true;
        options.rollbackOnError = true;
        options.runTest = false;
        options.unzip = true;
        // Use the retrieve call like an api and disable logging to the console. Also I want these attributes to be
        // exclusive to the retrieve call only. Maybe we should seal the command line options?
        const mdapiOptions = Object.assign({}, options);
        mdapiOptions.disableLogging = true;
        mdapiOptions.json = true;
        return new MdapiRetrieveApi(this.scratchOrg).retrieve(mdapiOptions).catch((err) => err.result);
    }
    static _didRetrieveSucceed(result) {
        return !util.isNullOrUndefined(result) &&
            result.success && result.status === 'Succeeded' &&
            util.isNullOrUndefined(result.messages) &&
            !util.isNullOrUndefined(result.fileProperties) && Array.isArray(result.fileProperties);
    }
    _postRetrieve(result, options) {
        let changedSourceElements;
        let promise;
        if (MdapiPullApi._didRetrieveSucceed(result)) {
            promise = Promise.resolve()
                .then(() => this._syncDownSource(result, options, this.swa))
                .then((sourceElements) => {
                changedSourceElements = sourceElements;
                return this._updateMaxRevision();
            });
        }
        else {
            promise = Promise.resolve();
        }
        return promise
            .then(() => MdapiPullApi._cleanUpTemp(options.retrievetargetdir, options.debug))
            .then(() => this._processResults(result, changedSourceElements));
    }
    _syncDownSource(result, options, swa) {
        const changedSourceElements = new Map();
        // Each Aura bundle has a definition file that has one of the suffixes: .app, .cmp, .design, .evt, etc.
        // In order to associate each sub-component of an aura bundle (e.g. controller, style, etc.) with
        // its parent aura definition type, we must find its parent's file properties
        // and pass those along to processMdapiFileProperty
        const auraDefinitionFileFileProperties = result.fileProperties.filter(fileProperty => {
            if (fileProperty.type === 'AuraDefinitionBundle') {
                const lightningDefType = this.swa.metadataRegistry.getLightningDefByFileName(fileProperty.fileName);
                if (!util.isNullOrUndefined(lightningDefType)) {
                    return lightningDefType.hasMetadata;
                }
            }
            return false;
        });
        result.fileProperties.forEach((fileProperty) => {
            if (fileProperty.type === 'Package') {
                return;
            }
            // After retrieving, switch back to path separators (for Windows)
            fileProperty.fullName = fileProperty.fullName.replace(/\//g, path.sep);
            this.swa.processMdapiFileProperty(changedSourceElements, options.retrievetargetdir, fileProperty, auraDefinitionFileFileProperties);
        });
        this.obsoleteNames.forEach((obsoleteName) => {
            this.swa.handleObsoleteSource(changedSourceElements, obsoleteName.fullName, obsoleteName.type);
        });
        return swa.updateSource(changedSourceElements, this.force, this.scratchOrg, options.manifest, false /** check for duplicates **/, options.unsupportedMimeTypes);
    }
    static _cleanUpTemp(retrievetargetdir, debug) {
        return debug ? Promise.resolve() : Promise.resolve(fs.removeAsync(retrievetargetdir));
    }
    _updateMaxRevision() {
        return this.smmHelper.getLatestSourceRevisionCount()
            .then((newMaxRev) => Promise.resolve(this.maxRevisionFile.write(parseInt(newMaxRev))));
    }
    _processResults(result, changedSourceElements) {
        if (util.isNullOrUndefined(result)) {
            return Promise.resolve();
        }
        else if (MdapiPullApi._didRetrieveSucceed(result)) {
            const changedFiles = [...changedSourceElements.values()]
                .reduce((allChanges, sourceElement) => allChanges.concat(sourceElement.getWorkspaceElements()), [])
                .map(workspaceElement => ({
                state: workspaceElement.getState(),
                fullName: workspaceElement.getFullName(),
                type: workspaceElement.getTypeDef().metadataName,
                filePath: workspaceElement.getSourcePath(),
                isStandardMember: workspaceElement.getIsStandardMember()
            }));
            return Promise.resolve({ inboundFiles: changedFiles });
        }
        else {
            const retrieveFailed = new Error(syncCommandHelper.getRetrieveFailureMessage(result, this.messages));
            retrieveFailed.name = 'RetrieveFailed';
            return Promise.reject(retrieveFailed);
        }
    }
    _checkForConflicts(options) {
        if (options.forceoverwrite) {
            return [];
        }
        const statusApi = new srcStatusApi(this.scratchOrg, this.swa);
        return statusApi.doStatus({ local: true, remote: true }) // rely on status so that we centralize the logic
            .then(() => statusApi.getLocalConflicts())
            .then((conflicts) => {
            if (conflicts.length > 0) {
                const error = new Error('Conflicts found during sync down');
                error.name = 'SourceConflict';
                error.sourceConflictElements = conflicts;
                throw error;
            }
        });
    }
}
module.exports = MdapiPullApi;

//# sourceMappingURL=mdapiPullApi.js.map
