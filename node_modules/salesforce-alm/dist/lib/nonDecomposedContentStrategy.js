/*
 * Copyright (c) 2017, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require('fs-extra');
const path = require('path');
const MetadataRegistry = require('./metadataRegistry');
const srcDevUtil = require('./srcDevUtil');
const typeDefUtil_1 = require("./typeDefUtil");
/**
 *  Content strategy for content files that do not require decomposition e.g. ApexClass
 */
class NonDecomposedContentStrategy {
    constructor(typeDef, metadataRegistry, workspaceVersion) {
        this.typeDef = typeDef;
        this.metadataRegistry = metadataRegistry;
    }
    getContentPaths(metadataFilePath) {
        const aggregateFullName = typeDefUtil_1.TypeDefUtil.getAggregateFullNameForFilePath(this.metadataRegistry, this.typeDef, metadataFilePath);
        const workspaceDir = path.dirname(metadataFilePath);
        const directoryItems = srcDevUtil.getDirectoryItems(workspaceDir);
        return directoryItems.filter(directoryItem => {
            const itemFullName = typeDefUtil_1.TypeDefUtil.getAggregateFullNameForFilePath(this.metadataRegistry, this.typeDef, directoryItem);
            return !directoryItem.startsWith('.') && !directoryItem.endsWith(MetadataRegistry.getMetadataFileExt())
                && aggregateFullName === itemFullName;
        });
    }
    saveContent(metadataFilePath, retrievedContentFilePaths, retrievedMetadataFilePath, createDuplicates, unsupportedMimeTypes) {
        const newPaths = [];
        const updatedPaths = [];
        const deletedPaths = [];
        const dupPaths = [];
        retrievedContentFilePaths.forEach(retrievedContentFilePath => {
            const workspaceContentFilePath = this.getWorkspaceContentFilePath(metadataFilePath, retrievedContentFilePath);
            if (srcDevUtil.pathExistsSync(workspaceContentFilePath)) {
                if (!NonDecomposedContentStrategy.filesAreEqual(retrievedContentFilePath, workspaceContentFilePath)) {
                    if (createDuplicates) {
                        const dupPath = workspaceContentFilePath + '.dup';
                        fs.copySync(retrievedContentFilePath, dupPath);
                        dupPaths.push(dupPath);
                    }
                    else {
                        fs.copySync(retrievedContentFilePath, workspaceContentFilePath);
                        updatedPaths.push(workspaceContentFilePath);
                    }
                }
            }
            else {
                fs.copySync(retrievedContentFilePath, workspaceContentFilePath);
                newPaths.push(workspaceContentFilePath);
            }
        });
        return [newPaths, updatedPaths, deletedPaths, dupPaths];
    }
    getWorkspaceContentFilePath(metadataFilePath, retrievedContentFilePath) {
        const workspaceDir = path.dirname(metadataFilePath);
        const fileName = path.basename(retrievedContentFilePath);
        return path.join(workspaceDir, fileName);
    }
    static filesAreEqual(filePathA, filePathB) {
        const contentA = fs.readFileSync(filePathA);
        const contentB = fs.readFileSync(filePathB);
        const contentHashA = srcDevUtil.getContentHash(contentA);
        const contentHashB = srcDevUtil.getContentHash(contentB);
        return contentHashA === contentHashB;
    }
}
exports.NonDecomposedContentStrategy = NonDecomposedContentStrategy;

//# sourceMappingURL=nonDecomposedContentStrategy.js.map
