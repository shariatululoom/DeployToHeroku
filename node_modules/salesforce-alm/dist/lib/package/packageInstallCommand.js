/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
/**
 * Contains config details and operations meant for package subscriber orgs.
 * This could potentially include test orgs used by CI process for testing packages,
 * and target subscriber orgs.
 **/
const path = require('path');
const Promise = require('bluebird');
const _ = require('lodash');
const util = require('util');
const logger = require(path.join('..', 'logApi'));
const messages = require(path.join(__dirname, '..', 'messages'))();
const DEFAULT_POLL_INTERVAL_MILLIS = 5000;
const REPLICATION_POLLING_INTERVAL_MILLIS = 10000;
const DEFAULT_MAX_RETRIES = 0;
const RETRY_MINUTES_IN_MILLIS = 60000;
const DEFAULT_PUBLISH_WAIT_MIN = 0;
/**
 * Private utility to parse out errors from PackageInstallRequest as a user-readable string.
 */
const readInstallErrorsAsString = function (request) {
    if (request.Errors && request.Errors.errors) {
        const errorsArray = request.Errors.errors;
        const len = errorsArray.length;
        if (len > 0) {
            let errorMessage = 'Installation errors: ';
            for (let i = 0; i < len; i++) {
                errorMessage += `\n${(i + 1)}) ${errorsArray[i].message}`;
            }
            return errorMessage;
        }
    }
    return '<empty>';
};
class PackageInstallCommand {
    constructor() {
        this.pollIntervalMillis = DEFAULT_POLL_INTERVAL_MILLIS;
        this.maxRetries = DEFAULT_MAX_RETRIES;
        this.allPackageVersionId = null;
        this.installationKey = null;
        this.publishwait = DEFAULT_PUBLISH_WAIT_MIN;
        this.logger = logger.child('PackageInstallCommand');
    }
    poll(context, id, retries) {
        this.org = context.org;
        this.configApi = this.org.config;
        this.force = this.org.force;
        return this.force.toolingRetrieve(this.org, 'PackageInstallRequest', id).then((request) => {
            switch (request.Status) {
                case 'SUCCESS':
                    return request;
                case 'ERROR': {
                    const err = readInstallErrorsAsString(request);
                    this.logger.error('Encountered errors installing the package!', err);
                    throw new Error(err);
                }
                default:
                    if (retries > 0) {
                        // Request still in progress.  Just log a message and move on. Server will be polled again.
                        this.logger.log(messages.getMessage('installStatus', request.Status, 'package2'));
                        return Promise.delay(this.pollIntervalMillis).then(() => (this.poll(context, id, retries - 1)));
                    }
                    else {
                        // timed out
                    }
            }
            return request;
        });
    }
    _waitForApvReplication(remainingRetries) {
        const QUERY = `SELECT Id, SubscriberPackageId FROM SubscriberPackageVersion WHERE Id='${this.allPackageVersionId}'`;
        return this.force.toolingQuery(this.org, util.format(QUERY))
            .then((result) => {
            const records = result.records;
            if (records && records.length > 0) {
                return records[0];
            }
            if (remainingRetries <= 0) {
                throw new Error(messages.getMessage('errorApvIdNotPublished', [], 'package_install'));
            }
            return Promise.delay(REPLICATION_POLLING_INTERVAL_MILLIS).then(() => {
                this.logger.log(messages.getMessage('publishWaitProgress', [], 'package_install'));
                return this._waitForApvReplication(remainingRetries - 1);
            });
        });
    }
    /**
     * This installs a package version into a target org.
     * @param context: heroku context
     * @returns {*|promise}
     */
    execute(context) {
        this.org = context.org;
        this.configApi = this.org.config;
        this.force = this.org.force;
        this.allPackageVersionId = context.flags.id;
        this.maxRetries = _.isNil(context.flags.wait) ? this.maxRetries : ((RETRY_MINUTES_IN_MILLIS / this.pollIntervalMillis) * context.flags.wait);
        // Be careful with the fact that cmd line flags are NOT camel cased: flags.installationkey
        this.installationKey = _.isNil(context.flags.installationkey) ? this.installationKey : context.flags.installationkey;
        this.publishwait = _.isNil(context.flags.publishwait) ? this.publishwait : context.flags.publishwait;
        const apiVersion = this.configApi.getApiVersion();
        if (apiVersion < 36) {
            throw new Error('This command is supported only on API versions 36.0 and higher');
        }
        const publishWaitRetries = Math.ceil((parseInt(this.publishwait) * 60 * 1000) / parseInt(REPLICATION_POLLING_INTERVAL_MILLIS));
        return this._waitForApvReplication(publishWaitRetries)
            .then(() => {
            // Construct PackageInstallRequest sobject used to trigger package version install.
            const packageInstallRequest = {};
            packageInstallRequest.subscriberPackageVersionKey = this.allPackageVersionId;
            packageInstallRequest.password = this.installationKey; // W-3980736 in the future we hope to change "Password" to "InstallationKey" on the server
            // Add default parameters to input object.
            packageInstallRequest.securityType = 'Full';
            packageInstallRequest.nameConflictResolution = 'Block';
            packageInstallRequest.packageInstallSource = 'U';
            return this.force.toolingCreate(this.org, 'PackageInstallRequest', packageInstallRequest)
                .then((result) => {
                const packageInstallRequestId = result.id;
                if (_.isNil(packageInstallRequestId)) {
                    throw new Error(`Failed to create PackageInstallRequest for: ${this.allPackageVersionId}`);
                }
                return this.poll(context, packageInstallRequestId, this.maxRetries);
            });
        });
    }
    /**
     * returns a human readable message for a cli output
     * @returns {string}
     */
    getHumanSuccessMessage(result) {
        const arg = result.Status === 'SUCCESS' ?
            [result.SubscriberPackageVersionKey] : [result.Id, this.org.name];
        return messages.getMessage(result.Status, arg, 'package_install_get');
    }
}
module.exports = PackageInstallCommand;

//# sourceMappingURL=packageInstallCommand.js.map
