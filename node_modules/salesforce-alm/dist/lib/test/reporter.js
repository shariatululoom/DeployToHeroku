/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
const util = require('util');
const _ = require('lodash');
const path = require('path');
const logger = require(path.join(__dirname, '..', 'logApi'));
/**
 * A Reporter outputs progress and results to stdout and, optionally, different
 * streams. This is an abstract class. Different implementations can specify
 * the output format hey want to report for the command.
 *
 * Many events can call into a reporter, which means that async events on
 * a progress event may not finish before the next event is sent in. For example:
 *    1. a client (like streaming) is listening for events
 *    2. a progress event comes in and emits progress on the reporter and waits
 *    3. a finish event comes in and emits finish on the reporter and waits
 *
 * Even though the #2 is waiting, node will still hit #3 because the way events
 * work in node. Therefore, if any part of the reporter needs to preform an async
 * operation, it must be added to the operations array.
 *    this.operations.push(promise);
 *
 * Finish will wait for all operations to finish before returning.
 */
class Reporter {
    constructor(parentLogger) {
        this.logger = parentLogger || logger.child('reporter');
        this.streams = [];
        this.operations = [];
    }
    /**
     * We must pipe stdout to the stream while this reporter lives because
     * there are several calls to logger (like table) which does a lot of logic
     * before writing directly to stdout.
     */
    addStream(stream) {
        if (stream) {
            this.streams.push(stream);
        }
    }
    log(msg) {
        this.logger.log(msg);
        this.logToStreams(msg);
    }
    logToStreams(msg) {
        this.streams.forEach(stream => stream.write(`${msg}\n`));
    }
    /**
     * Log some test information to the console, but only log when json is not
     * specified. Otherwise the only output should be in json format which will
     * print to the console when the command returns on the command handler.
     * @param {string} header The header for the table OR a string if no table
     *    (object) is specified.
     * @param {object|array} data The data to display in the table. Data will be
     *    converted to an array if an object is passed in.
     * @param {array} columns An array of column information, such as key, label,
     * and formatter.
     */
    logTable(header, data, columns) {
        let rows = data;
        // Tables require arrays, so convert objects to arrays
        if (util.isObject(data) && !util.isArray(data)) {
            rows = [];
            Object.keys(data).forEach(key => {
                // Turn keys into titles; i.e. testRunId to Test Run Id
                const title = _.map(_.kebabCase(key).split('-'), _.capitalize).join(' ');
                rows.push({ key: title, value: `${data[key]} ` });
            });
        }
        this.log(`=== ${this.logger.color.blue(header)}`);
        this.logger.table(rows, {
            columns,
            printLine: (...args) => {
                this.log(...args);
            }
        });
        this.log('');
    }
    onStart() {
        // noop
    }
    /**
     * Does this Reporter need progress information.
     */
    get progressRequired() {
        return util.isFunction(this.onProgress);
    }
    /**
     * Determine if this is a specific Reporter type instance.
     *
     * @param {class} type The type of Reporter to check if this is an instanceof.
     */
    isType(type) {
        return this instanceof type;
    }
    /**
     * The function to call when the command has finished.
     *
     * @param {Object} results The completed results
     */
    // Adding data here so prevent typescript errors when including data
    // in onFinished.
    onFinished(data) {
        this.streams.forEach(stream => stream.close());
        let promise = Promise.resolve();
        this.operations.forEach(op => {
            promise = promise.then(() => op);
        });
        return promise;
    }
    /**
     * The type of output this reporter produces, like the file format which
     * makes this useful for file extensions.
     * i.e. xml, json, txt, etc.
     *
     * This method must be implemented.
     *
     * @param {Object} results The completed results
     */
    getFormat() {
        throw new Error('NOT IMPLEMENTED');
    }
    emit(event, data) {
        const funcName = `on${_.capitalize(event)}`;
        if (_.isFunction(this[funcName])) {
            return this[funcName](data);
        }
        return Promise.resolve();
    }
}
/**
 * Output the test results in a human readable way
 */
class HumanReporter extends Reporter {
    onFinished(testResults) {
        this.logTable('Test Results', testResults.tests, [
            { key: 'FullName', label: 'Test Name' },
            { key: 'Outcome',
                label: 'Outcome',
                format: outcome => {
                    if (outcome === 'Pass') {
                        return this.logger.color.green(outcome);
                    }
                    return this.logger.color.red(outcome);
                } },
            { key: 'Message',
                label: 'Message',
                format: msg => {
                    if (util.isString(msg)) {
                        return this.logger.color.red(JSON.stringify(msg));
                    }
                    return '';
                } },
            { key: 'RunTime', label: 'Runtime (ms)' }
        ]);
        this.logTable('Test Summary', testResults.summary, [
            { key: 'key', label: 'Name' },
            { key: 'value', label: 'Value' }
        ]);
        super.onFinished(testResults);
    }
    getFormat() {
        return 'txt';
    }
}
/**
 * This is a special reporter that only logs to streams. This is because the CLI has
 * a global 'json' flag that outputs JSON to stdout, and requires that the JSON
 * be returned from the command. So we do not log to stdout here so we don't print JSON
 * twice.
 */
class JsonReporter extends Reporter {
    onFinished(testResults) {
        // We can only log to streams because the CLI process logs the json to stdout.
        this.logToStreams(JSON.stringify(testResults.toJson()));
        super.onFinished(testResults);
    }
    log(msg) { } // eslint-disable-line no-unused-vars
    logTable(header, data, columns) { } // eslint-disable-line no-unused-vars
    getFormat() {
        return 'json';
    }
}
/**
 * No-op report, but does provide logging utility.
 */
class NoOpReporter extends Reporter {
    addStream() { }
}
/**
 * Outputs test results in JUnit format, particularly useful for CI tools.
 */
class JUnitReporter extends Reporter {
    onFinished(testResults) {
        // Log the junit to all streams
        super.log(testResults.generateJunit());
        super.onFinished(testResults);
    }
    log() {
        // We print all junit at the end of the run
    }
    getFormat() {
        return 'xml';
    }
}
/**
 * A TAP reporter. https://testanything.org
 *
 * TAP is specifically useful for streaming results to the client, so this
 * reporter listens for test progress.
 */
class TapReporter extends Reporter {
    constructor(parentLogger) {
        super(parentLogger);
        this.counter = 1;
    }
    /**
     * Logs messages that are ignored by TAP parsing, eg directives, comments,
     * and general log lines.
     *
     * Use logTap to log parsable TAP output.
     *
     * @param msg
     */
    log(msg) {
        super.log(`# ${msg}`);
    }
    logTap(msg) {
        super.log(msg);
    }
    // table not support in TAP
    logTable(header, data, columns) { } // eslint-disable-line no-unused-vars
    // logs 1..<given num of tests>
    logTapStart(testCnt) {
        this.logTap(`1..${testCnt}`);
    }
    /**
     * Receive notifications on progress to output TAP lines as the tests finish.
     * NOTE: This will use more API calls since it will query the queue items every
     *  streaming event.
     */
    onProgress() {
    }
    /**
     * Construct TAP formatted line.
     *
     * @param testResult
     */
    logTapResult(testResult) {
        // First time we have heard from this result, so print
        let output = '';
        if (testResult.Outcome !== 'Pass') {
            output += 'not ';
        }
        output += `ok ${this.counter++} ${this.getFullTestName(testResult)}`;
        this.logTap(output);
        if (testResult.Outcome !== 'Pass') {
            if (testResult.Message) {
                const startsWithNewlineRegex = new RegExp(/^[/\r\n|\r|\n][\w]*/igm);
                if (startsWithNewlineRegex.test(testResult.Message)) {
                    // lightning tests return newline delimited messages
                    testResult.Message.split(/\r\n|\r|\n/g).forEach((msg) => {
                        if (msg && msg.length > 0) {
                            this.log(msg.trim());
                        }
                    });
                }
                else {
                    this.log(testResult.Message);
                }
            }
            else {
                this.log('Unknown error');
            }
            if (testResult.StackTrace) {
                testResult.StackTrace.split('\n').forEach(line => {
                    this.log(line);
                });
            }
        }
    }
    getFullTestName(testResult) {
        throw new Error('EXPECTED IMPLEMENTATION');
    }
    getFormat() {
        return 'txt';
    }
}
module.exports = { Reporter, JsonReporter, HumanReporter, JUnitReporter, TapReporter, NoOpReporter };

//# sourceMappingURL=reporter.js.map
