"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const Display = require("../../lib/force-cli-display");
const Config = require("../../lib/force-cli-config");
const Messages = require("../../lib/force-cli-messages");
const logApi = require("../logApi");
const reporter_1 = require("../../lib/test/reporter");
let logger;
class QueryReporter extends reporter_1.Reporter {
}
class HumanReporter extends QueryReporter {
    onFinished(queryResults) {
        // print table
        let attributeNames = exports.getAllAttributesNames(queryResults[0]);
        Display.soqlQuery(attributeNames, queryResults);
        return super.onFinished(queryResults);
    }
    getFormat() {
        return 'txt';
    }
}
exports.HumanReporter = HumanReporter;
const EOL = require('os').EOL;
const SEPARATOR = ',';
const DOUBLE_QUOTE = '"';
const SHOULD_QUOTE_REGEXP = new RegExp(`[${SEPARATOR}${DOUBLE_QUOTE}${EOL}]`);
class CsvReporter extends QueryReporter {
    /**
     * Escape a value to be placed in a CSV row. We follow rfc 4180
     * https://tools.ietf.org/html/rfc4180#section-2 and will not surround the
     * value in quotes if it doesn't contain the separator, double quote, or EOL.
     * @param value The escaped value
     */
    escape(value) {
        if (value && _.isFunction(value.match) && value.match(SHOULD_QUOTE_REGEXP)) {
            return `"${value.replace(/"/gi, '""')}"`;
        }
        return value;
    }
    onFinished(queryResults) {
        let attributeNames = exports.getAllAttributesNames(queryResults[0]);
        this.log(attributeNames.map(name => {
            return this.escape(name);
        }).join(SEPARATOR));
        queryResults.forEach(row => {
            const values = attributeNames.map(name => {
                return this.escape(_.get(row, name));
            });
            this.log(values.join(SEPARATOR));
        });
        return super.onFinished(queryResults);
    }
    getFormat() {
        return 'csv';
    }
}
exports.CsvReporter = CsvReporter;
class JsonReporter extends QueryReporter {
    onFinished(queryResults) {
        // We can only log to streams because the CLI process logs the json to stdout.
        this.logToStreams(JSON.stringify(queryResults));
        return super.onFinished(queryResults);
    }
    log(msg) { }
    logTable(header, data, columns) { }
    getFormat() {
        return 'json';
    }
}
exports.JsonReporter = JsonReporter;
/**
 * A list of the accepted reporter types
 */
exports.FormatTypes = {
    human: HumanReporter,
    csv: CsvReporter,
    json: JsonReporter
};
class DataSoqlQueryCommand {
    constructor() {
        logger = logApi.child('data:soql:query');
    }
    validate(context) {
        if (context.flags.json) {
            context.flags.resultformat = 'json';
        }
        else if (context.flags.resultformat === 'json') {
            // If the result format is json, make sure the context is too
            context.flags.json = true;
        }
        return context;
    }
    execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const resultFormat = context.flags.resultformat || 'human';
            if (!exports.FormatTypes[resultFormat]) {
                throw Error(Messages.get('DataSOQLQueryInvalidReporter', Object.keys(exports.FormatTypes)));
            }
            const reporter = new exports.FormatTypes[resultFormat]();
            if (context.flags.query) {
                let conn = yield Config.getActiveConnection(context);
                if (context.flags.usetoolingapi) {
                    return yield conn.tooling.query(context.flags.query, function (err, result) {
                        return __awaiter(this, void 0, void 0, function* () {
                            return yield handleResults(conn, err, result, reporter);
                        });
                    });
                }
                else {
                    return yield conn.query(context.flags.query, function (err, result) {
                        return __awaiter(this, void 0, void 0, function* () {
                            return yield handleResults(conn, err, result, reporter);
                        });
                    });
                }
            }
            else {
                throw Error(context.command);
            }
        });
    }
}
exports.DataSoqlQueryCommand = DataSoqlQueryCommand;
/**
 * get attribute names from record object structure
 * exposed for unit testing
 * @param {Object} record - any single record to get the attribute structure from
 * @param {string} relationshipName - optional attribute prefix
 * @returns {string[]}
 */
exports.getAllAttributesNames = function (record, relationshipName) {
    let attributes = [];
    if (record) {
        for (let propertyKey in record) {
            if (record.hasOwnProperty(propertyKey)) {
                let property = record[propertyKey];
                if (propertyKey === 'attributes') {
                    // skip metadata object
                }
                else if (property && typeof property === 'object') {
                    if (relationshipName) {
                        propertyKey = relationshipName + '.' + propertyKey;
                    }
                    // need null check because attributes can have null value but need to go to else condition
                    // relationship name for attribute prefix
                    attributes = attributes.concat(exports.getAllAttributesNames(property, propertyKey));
                }
                else {
                    if (relationshipName) {
                        attributes.push(relationshipName + '.' + propertyKey);
                    }
                    else {
                        // no relationship name for top level attributes
                        attributes.push(propertyKey);
                    }
                }
            }
        }
    }
    return attributes;
};
let handleResults = function (conn, err, result, reporter) {
    return __awaiter(this, void 0, void 0, function* () {
        if (err) {
            throw Error(err.message);
        }
        if (result.totalSize > 0 && result.records) {
            // get all result batches
            let moreResults = result;
            while (!moreResults.done) {
                if (moreResults.nextRecordsUrl) {
                    moreResults = yield conn.queryMore(moreResults.nextRecordsUrl);
                    if (moreResults.records) {
                        result.records = result.records.concat(moreResults.records);
                    }
                    else {
                        throw Error(Messages.get('DataSOQLQueryMoreMissingRecords'));
                    }
                }
                else {
                    throw Error(Messages.get('DataSOQLQueryMoreMissingUrl'));
                }
            }
            if (result.records) {
                reporter.emit('finished', result.records);
            }
            else {
                throw Error(Messages.get('DataSOQLQueryMoreMissingRecords'));
            }
        }
        else if (!(reporter instanceof JsonReporter)) {
            Display.info(Messages.get('DataSOQLQueryNoResults'));
        }
        // Clean result for consumer
        delete result.nextRecordsUrl;
        result.done = true;
        return result;
    });
};

//# sourceMappingURL=dataSoqlQueryCommand.js.map
