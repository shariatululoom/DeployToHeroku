/*
 * Copyright (c) 2017, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require('path');
const util = require('util');
const _ = require('lodash');
const glob = require('glob');
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const decompositionStrategyFactory_1 = require("./decompositionStrategyFactory");
const staticResource_1 = require("./staticResource");
/**
 * Temporary class to get information for specific entity types
 * This class should go away once TypeDefs become first class
 */
class TypeDefUtil {
    /**
     * Gets the fullname for the workspace element represented by the filePath
     * For a filePath to a decomposed workspace element such as CustomField, the fullName
     * would be 'CustomObjectName__c.CustomFieldName__c'
     * @param metadataRegistry
     * @param typeDef
     * @param filePath
     * @returns {string}
     */
    static getFullNameForFilePath(metadataRegistry, typeDef, filePath) {
        const filePathWithoutMetadataExt = filePath.replace(MetadataRegistry.getMetadataFileExt(), '');
        // For decomposed CustomObject and CustomObjectTranslation subtypes
        if (!_.isNil(typeDef.parent)) {
            let parentName;
            let fileName;
            // Subtype of CustomObjectTranslation
            if (typeDef.metadataName === metadataRegistry.typeDefs.CustomFieldTranslation.metadataName) {
                parentName = path.basename(path.dirname(filePathWithoutMetadataExt));
                fileName = path.basename(filePathWithoutMetadataExt, path.extname(filePathWithoutMetadataExt));
            }
            else {
                parentName = path.basename(path.dirname(path.dirname(filePathWithoutMetadataExt)));
                fileName = path.basename(filePathWithoutMetadataExt, path.extname(filePathWithoutMetadataExt));
            }
            return `${parentName}.${fileName}`;
        }
        if (typeDef.metadataName === metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
            const bundleName = path.basename(path.dirname(filePathWithoutMetadataExt));
            const fileName = path.basename(filePathWithoutMetadataExt);
            return path.join(bundleName, fileName);
        }
        if (typeDef.metadataName === metadataRegistry.typeDefs.StaticResource.metadataName) {
            return TypeDefUtil.getAggregateFullNameForFilePath(metadataRegistry, typeDef, filePath);
        }
        if (typeDef.metadataName === metadataRegistry.typeDefs.Territory2 ||
            typeDef.metadataName === metadataRegistry.typeDefs.Territory2Rule) {
            return TypeDefUtil.getAggregateFullNameForFilePath(metadataRegistry, typeDef, filePath);
        }
        if (typeDef.inFolder) {
            return TypeDefUtil.getAggregateFullNameForFilePath(metadataRegistry, typeDef, filePath);
        }
        //default
        return path.basename(filePathWithoutMetadataExt, path.extname(filePathWithoutMetadataExt));
    }
    /**
     * Gets the fullName for the aggregateSourceElement related to the given filePath
     * For a path to a decomposed type such as Custom Field, this method would return the fullName of its
     * parent object: 'CustomObjectName__c'
     * @param metadataRegistry
     * @param typeDef
     * @param filePath
     * @returns {string}
     */
    static getAggregateFullNameForFilePath(metadataRegistry, typeDef, filePath) {
        const filePathWithoutMetadataExt = filePath.replace(MetadataRegistry.getMetadataFileExt(), '');
        // For decomposed CustomObject and CustomObjectTranslation subtypes
        if (!_.isNil(typeDef.parent)) {
            // Subtype of CustomObjectTranslation
            if (typeDef.metadataName === metadataRegistry.typeDefs.CustomFieldTranslation.metadataName) {
                return path.basename(path.dirname(filePath));
            }
            // Subtype of CustomObject
            return path.basename(path.dirname(path.dirname(filePath)));
        }
        if (typeDef.metadataName === metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
            return path.basename(path.dirname(filePath));
        }
        if (typeDef.metadataName === metadataRegistry.typeDefs.StaticResource.metadataName) {
            return staticResource_1.StaticResource.getFullName(filePath, typeDef);
        }
        if (typeDef.metadataName === metadataRegistry.typeDefs.Territory2.metadataName ||
            typeDef.metadataName === metadataRegistry.typeDefs.Territory2Rule.metadataName) {
            const modelName = path.basename(path.dirname(path.dirname(filePath)));
            const fileName = path.basename(filePathWithoutMetadataExt, path.extname(filePathWithoutMetadataExt));
            return `${modelName}.${fileName}`;
        }
        if (typeDef.inFolder) {
            const folderName = path.basename(path.dirname(filePath));
            const fileName = path.basename(filePathWithoutMetadataExt, path.extname(filePathWithoutMetadataExt));
            return path.join(folderName, fileName);
        }
        return path.basename(filePathWithoutMetadataExt, path.extname(filePathWithoutMetadataExt));
    }
    /**
     * Gets the nondecomposed metadata file path for the aggregate entity
     * For example, given a filePath to a decomposed CustomField workspace file, this method would return
     * the nondecomposed filePath to its parent CustomObject entity
     * @param metadataRegistry
     * @param aggregateTypeDef
     * @param filePath
     * @returns {any}
     */
    static getAggregateMetadataFilePathFromWorkspacePath(metadataRegistry, aggregateTypeDef, filePath) {
        if (aggregateTypeDef.metadataName === metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
            if (filePath.endsWith(MetadataRegistry.getMetadataFileExt())) {
                return filePath;
            }
            else {
                // Each Aura bundle has a definition file that has one of the suffixes: .app, .cmp, .design, .evt, etc.
                // Each bundle has one metadata file path that ends with its definition suffix + '-meta.xml'
                // This scans the bundle directory to find the existing aggregate metadata file path
                const bundlePath = path.dirname(filePath);
                const matchingFilePaths = glob.sync(path.join(bundlePath, `*${MetadataRegistry.getMetadataFileExt()}`));
                if (matchingFilePaths.length > 0) {
                    return matchingFilePaths[0];
                }
                // In the case that an Aura bundle has been deleted from the workspace, a search for its definition file
                // will produce no results. In this case, return the filePath being processed.
                return filePath;
            }
        }
        else if (aggregateTypeDef.metadataName === metadataRegistry.typeDefs.StaticResource.metadataName) {
            return staticResource_1.StaticResource.getMetadataFilePathFor(filePath, aggregateTypeDef);
        }
        else {
            // decompositionWorkspaceStrategies should only be used within AggregateSourceElement and exclusively
            // to determine the workspace location of metadata files, but until typeDefs
            // are first class objects, I am using it here to minimize code duplication
            const workspaceStrategy = decompositionStrategyFactory_1.DecompositionStrategyFactory.newDecompositionWorkspaceStrategy(aggregateTypeDef.decompositionConfig);
            return workspaceStrategy.getNondecomposedFilePath(filePath, aggregateTypeDef);
        }
    }
    /**
     * Returns the default aggregate (non-decomposed) metadata path for the given entity type and fullName
     * @param devName
     * @param typeDef
     * @param defaultSrcDir
     * @param metadataRegistry
     * @param auraBundleFileProperties
     * @returns {any}
     */
    static getDefaultAggregateMetadataPath(devName, typeDef, defaultSrcDir, metadataRegistry, auraBundleFileProperties) {
        let metadataPath;
        const defaultTypeDir = !util.isNullOrUndefined(typeDef.defaultDirectory) ?
            path.join(defaultSrcDir, typeDef.defaultDirectory) : defaultSrcDir;
        if (typeDef.metadataName === metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
            const bundleName = devName.split(path.sep)[0];
            const parentBundle = auraBundleFileProperties.find(fileProperty => fileProperty.fullName.split(path.sep)[0] === bundleName);
            const fileName = `${path.basename(parentBundle.fileName)}${metadataRegistry.metadataFileExt}`;
            metadataPath = path.join(defaultTypeDir, bundleName, fileName);
        }
        else if (typeDef.metadataName === metadataRegistry.typeDefs.CustomObject.metadataName) {
            const filename = `${devName}.${typeDef.ext}${metadataRegistry.metadataFileExt}`;
            metadataPath = path.join(defaultTypeDir, filename);
        }
        else if (typeDef.metadataName === metadataRegistry.typeDefs.QuickAction.metadataName) {
            const fileName = `${devName}.quickAction${metadataRegistry.metadataFileExt}`;
            metadataPath = path.join(defaultTypeDir, fileName);
        }
        else if (typeDef.metadataName === metadataRegistry.typeDefs.ApprovalProcess.metadataName) {
            const fileName = `${devName}.approvalProcess${metadataRegistry.metadataFileExt}`;
            metadataPath = path.join(defaultTypeDir, fileName);
        }
        else if (typeDef.metadataName === metadataRegistry.typeDefs.Territory2Model.metadataName) {
            const filename = `${devName}.${typeDef.ext}${metadataRegistry.metadataFileExt}`;
            metadataPath = path.join(defaultTypeDir, devName, filename);
        }
        else if (typeDef.metadataName === metadataRegistry.typeDefs.Territory2.metadataName ||
            typeDef.metadataName === metadataRegistry.typeDefs.Territory2Rule.metadataName) {
            const nameParts = devName.split('.');
            const fileName = `${nameParts[1]}.${typeDef.ext}${metadataRegistry.metadataFileExt}`;
            metadataPath = path.join(defaultSrcDir, metadataRegistry.typeDefs.Territory2Model.defaultDirectory, nameParts[0], typeDef.defaultDirectory, fileName);
        }
        else if (devName.includes('.') && typeDef.metadataName !== metadataRegistry.typeDefs.Document.metadataName && typeDef.metadataName !== metadataRegistry.typeDefs.QuickAction.metadataName
            && typeDef.metadataName !== metadataRegistry.typeDefs.CustomMetadata.metadataName && typeDef.metadataName !== metadataRegistry.typeDefs.DuplicateRule.metadataName) {
            // This is a child of a compound type (like custom field or weblink), use the parent name as a directory
            const nameParts = devName.split('.');
            const fileName = `${nameParts[1]}.${typeDef.ext}${metadataRegistry.metadataFileExt}`;
            metadataPath = path.join(defaultTypeDir, nameParts[0], fileName);
        }
        else if (devName.includes(path.sep)) {
            // This is a document in a folder
            const nameParts = devName.split(path.sep);
            const fileName = `${nameParts[1]}.${typeDef.ext}${metadataRegistry.metadataFileExt}`;
            metadataPath = path.join(defaultTypeDir, nameParts[0], fileName);
        }
        else {
            // This is a normal type
            const filename = `${devName}.${typeDef.ext}${metadataRegistry.metadataFileExt}`;
            metadataPath = path.join(defaultTypeDir, filename);
        }
        return metadataPath;
    }
    /**
     * Some source members on the server map to decomposed types in the workspace
     * This method gets the fullName for the aggregate element associated with the sourceMember name
     * @param metadataRegistry
     * @param sourceMemberTypeDef
     * @param sourceMemberName
     * @returns {any}
     */
    static getAggregateFullNameFromSourceMemberName(metadataRegistry, sourceMemberTypeDef, sourceMemberName) {
        sourceMemberName = sourceMemberName.replace(/\//g, path.sep);
        if (!_.isNil(sourceMemberTypeDef.parent)) {
            return sourceMemberName.split('.')[0];
        }
        else {
            if (sourceMemberTypeDef.metadataName === metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
                return sourceMemberName.split(path.sep)[0];
            }
            return sourceMemberName;
        }
    }
    /**
     * Get the aggregate fullName from the workspace fullName
     * (The logic is the same as in getAggregateFullNameFromSourceMemberName() but this is just a coincidence)
     * @param metadataRegistry
     * @param workspaceTypeDef
     * @param workspaceFullName
     * @returns {any}
     */
    static getAggregateFullNameFromWorkspaceFullName(metadataRegistry, workspaceTypeDef, workspaceFullName) {
        if (!_.isNil(workspaceTypeDef.parent)) {
            return workspaceFullName.split('.')[0];
        }
        else {
            if (workspaceTypeDef.metadataName === metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
                return workspaceFullName.split(path.sep)[0];
            }
            return workspaceFullName;
        }
    }
    /**
     * Gets the path to the directory in the metadata API deploy package that will contain the source of the given typeDef and fullName
     * @param metadataRegistry
     * @param typeDef
     * @param fullName
     * @param mdDir - path to the metadata API formatted directory
     */
    static getPathToMdapiSourceDir(metadataRegistry, typeDef, fullName, mdDir) {
        const defaultMdapiEntityDir = path.join(mdDir, typeDef.defaultDirectory);
        if (typeDef.metadataName === metadataRegistry.typeDefs.Territory2.metadataName ||
            typeDef.metadataName === metadataRegistry.typeDefs.Territory2Rule.metadataName) {
            const modelName = fullName.split('.')[0];
            return path.join(mdDir, metadataRegistry.typeDefs.Territory2Model.defaultDirectory, modelName, typeDef.defaultDirectory);
        }
        if (typeDef.metadataName === metadataRegistry.typeDefs.Territory2Model.metadataName) {
            return path.join(defaultMdapiEntityDir, fullName);
        }
        if (typeDef.metadataName === metadataRegistry.typeDefs.Document.metadataName ||
            typeDef.metadataName === metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName ||
            typeDef.metadataName === metadataRegistry.typeDefs.EmailTemplate.metadataName ||
            typeDef.metadataName === metadataRegistry.typeDefs.Report.metadataName ||
            typeDef.metadataName === metadataRegistry.typeDefs.Dashboard.metadataName) {
            const parentName = fullName.split(path.sep)[0];
            return path.join(defaultMdapiEntityDir, parentName);
        }
        return defaultMdapiEntityDir;
    }
    /**
     * Gets the fileName expected by the metadata API for the given metadata file path
     * @param metadataRegistry
     * @param typeDef
     * @param metadataFilePath
     * @returns {string}
     */
    static getMdapiFormattedMetadataFileName(metadataRegistry, typeDef, metadataFilePath) {
        const mdapiFormatMetadataFileName = path.basename(metadataFilePath);
        if (typeDef.metadataName === metadataRegistry.typeDefs.Document.metadataName) {
            // For documents append the -meta.xml file extension to the content filename
            const workspaceContentFilePath = TypeDefUtil.getContentPathWithNonStdExtFromMetadataPath(metadataRegistry, typeDef, metadataFilePath);
            const workspaceContentFileName = path.basename(workspaceContentFilePath);
            return `${workspaceContentFileName}${metadataRegistry.metadataFileExt}`;
        }
        if (typeDef.metadataName === metadataRegistry.typeDefs.DashboardFolder.metadataName ||
            typeDef.metadataName === metadataRegistry.typeDefs.DocumentFolder.metadataName ||
            typeDef.metadataName === metadataRegistry.typeDefs.EmailFolder.metadataName ||
            typeDef.metadataName === metadataRegistry.typeDefs.ReportFolder.metadataName) {
            return mdapiFormatMetadataFileName.replace(`.${typeDef.ext}`, '');
        }
        if (typeDef.metadataName === metadataRegistry.typeDefs.CustomPageWebLink.metadataName) {
            // For custom page weblinks change back to .weblink
            return mdapiFormatMetadataFileName.replace(`.${typeDef.ext}${metadataRegistry.metadataFileExt}`, '.weblink');
        }
        if (!typeDef.hasContent) {
            return mdapiFormatMetadataFileName.replace(metadataRegistry.metadataFileExt, '');
        }
        return mdapiFormatMetadataFileName;
    }
    static getContentPathWithNonStdExtFromMetadataPath(metadataRegistry, typeDef, metadataFilePath) {
        if (typeDef.metadataName === metadataRegistry.typeDefs.Document.metadataName || typeDef.metadataName === metadataRegistry.typeDefs.StaticResource.metadataName) {
            let pathWithoutMetaExtension = metadataFilePath.replace(MetadataRegistry.getMetadataFileExt(), '');
            const documentFileName = path.basename(pathWithoutMetaExtension, path.extname(pathWithoutMetaExtension));
            let matchingWorkspaceDocumentFiles = glob.sync(path.join(path.dirname(pathWithoutMetaExtension), `${documentFileName}*`));
            matchingWorkspaceDocumentFiles = matchingWorkspaceDocumentFiles.map(filePath => path.resolve(filePath)); // glob returns paths using the forward slash only, which breaks tests in Windows
            return matchingWorkspaceDocumentFiles.find(docFile => srcDevUtil.fileNamesWithoutExtensionsMatch(path.basename(docFile), documentFileName) && !docFile.endsWith(MetadataRegistry.getMetadataFileExt()));
        }
        return null;
    }
    /**
     * Returns true if the aggregate type has children types that are mdapi addressable
     * @param metadataRegistry
     * @param typeDef
     * @returns {boolean}
     */
    static hasIndividuallyAddressableChildWorkspaceElements(metadataRegistry, aggregateTypeDef) {
        return aggregateTypeDef.metadataName === metadataRegistry.typeDefs.CustomObject.metadataName;
    }
    /**
     * Returns true if the type has child types that are not already decomposed
     * @param typeDef
     * @returns {boolean}
     */
    static requiresIndividuallyAddressableMembersInPackage(typeDef) {
        return typeDef.childXmlNames && typeDef.childXmlNames.length > 0 && typeDef.metadataName !== 'CustomObject' && typeDef.metadataName !== 'CustomObjectTranslation';
    }
}
exports.TypeDefUtil = TypeDefUtil;

//# sourceMappingURL=typeDefUtil.js.map
