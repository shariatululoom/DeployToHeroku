/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// Node
const path = require('path');
const moment = require('moment');
const _ = require('lodash');
const util = require('util');
// Local
const messages = require(path.join(__dirname, '..', 'messages'))();
const logger = require(path.join(__dirname, '..', 'logApi'));
const pkg2Utils = require(path.join(__dirname, 'package2Utils'));
const DEFAULT_SELECT = 'SELECT Id, Package2Id, SubscriberPackageVersionId, Name, Package2.Name, Package2.NamespacePrefix, ' +
    'Description, Tag, Branch, MajorVersion, MinorVersion, PatchVersion, BuildNumber, IsBeta, ' +
    'CreatedDate, LastModifiedDate ' +
    'FROM Package2Version';
const DEFAULT_ORDER_BY_FIELDS = 'Package2Id, Branch, MajorVersion, MinorVersion, PatchVersion, BuildNumber';
class Package2VersionListCommand {
    constructor() {
        this.logger = logger.child('package2:version:list');
        this.results = [];
        this.verbose = false;
        this.concise = false;
    }
    execute(context) {
        return this._execute(context)
            .catch((err) => {
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw pkg2Utils.applyErrorAction(err);
        });
    }
    _execute(context) {
        this.org = context.org;
        this.force = context.org.force;
        this.verbose = context.flags.verbose;
        this.concise = context.flags.concise;
        return this.force.toolingQuery(this.org, this._constructQuery(context.flags))
            .then((queryResult) => {
            const records = queryResult.records;
            if (records && records.length > 0) {
                records.forEach((record) => {
                    const released = !record.IsBeta || false;
                    this.results.push({
                        Package2Id: record.Package2Id,
                        Branch: record.Branch,
                        Tag: record.Tag,
                        MajorVersion: record.MajorVersion,
                        MinorVersion: record.MinorVersion,
                        PatchVersion: record.PatchVersion,
                        BuildNumber: record.BuildNumber,
                        Id: record.Id,
                        SubscriberPackageVersionId: record.SubscriberPackageVersionId,
                        Name: record.Name,
                        NamespacePrefix: record.Package2.NamespacePrefix,
                        Package2Name: record.Package2.Name,
                        Description: record.Description,
                        Version: [record.MajorVersion, record.MinorVersion, record.PatchVersion, record.BuildNumber].join('.'),
                        // table output needs string false to display 'false'
                        IsBeta: (context.flags.json ? record.IsBeta : record.IsBeta.toString()),
                        // table output needs string false to display 'false'
                        Released: (context.flags.json ? released : released.toString()),
                        CreatedDate: moment(record.CreatedDate).format('YYYY-MM-DD HH:mm'),
                        LastModifiedDate: moment(record.LastModifiedDate).format('YYYY-MM-DD HH:mm')
                    });
                });
            }
            return this.results;
        });
    }
    _getLastDays(paramName, lastDays) {
        if (isNaN(lastDays)) {
            throw new Error(messages.getMessage('invalidDaysNumber', paramName, 'package2'));
        }
        if (parseInt(lastDays, 10) < 0) {
            throw new Error(messages.getMessage('invalidDaysNumber', paramName, 'package2'));
        }
        return lastDays;
    }
    // construct custom WHERE clause parts
    _constructWhere(package2Ids, createdLastDays, lastModLastDays) {
        const where = [];
        // filter on given package2 ids
        if (package2Ids) {
            // split and remove dups
            if (util.isString(package2Ids)) {
                package2Ids = package2Ids.split(',');
            }
            package2Ids = _.uniq(package2Ids);
            // validate ids
            package2Ids.forEach((package2Id) => {
                pkg2Utils.validateId(pkg2Utils.BY_LABEL.PACKAGE2_ID, package2Id);
            });
            // stash where part
            if (package2Ids.length > 1) {
                where.push(`Package2Id IN ('${package2Ids.join('\',\'')}')`);
            }
            else {
                where.push(`Package2Id = '${package2Ids[0]}'`);
            }
        }
        // filter on created date, days ago: 0 for today, etc
        if (!util.isNullOrUndefined(createdLastDays)) {
            createdLastDays = this._getLastDays('createdlastdays', createdLastDays);
            where.push(`CreatedDate = LAST_N_DAYS:${createdLastDays}`);
        }
        // filter on last mod date, days ago: 0 for today, etc
        if (!util.isNullOrUndefined(lastModLastDays)) {
            lastModLastDays = this._getLastDays('modifiedlastdays', lastModLastDays);
            where.push(`LastModifiedDate = LAST_N_DAYS:${lastModLastDays}`);
        }
        return where;
    }
    // assemble query
    _assembleQueryParts(select, where = [], orderBy = '') {
        let wherePart = '';
        if (where.length > 0) {
            wherePart = ` WHERE ${where.join(' AND ')}`;
        }
        const query = `${select}${wherePart}${orderBy}`;
        logger.debug(query);
        return query;
    }
    // construct query based on given params
    _constructQuery(flags = {}) {
        // construct custom WHERE clause, if applicable
        const where = this._constructWhere(flags.package2ids, flags.createdlastdays, flags.modifiedlastdays);
        if (flags.released) {
            where.push('IsBeta = false');
        }
        // construct ORDER BY clause
        // TODO: validate given fields
        const orderBy = ` ORDER BY ${flags.orderby ? flags.orderby : DEFAULT_ORDER_BY_FIELDS}`;
        return this._assembleQueryParts(DEFAULT_SELECT, where, orderBy);
    }
    /**
     * indicates that the human readable message should be tabular
     * @returns {[{}...]}
     */
    getColumnData() {
        this.logger.styledHeader(this.logger.color.blue(`Package2 Versions [${this.results.length}]`));
        if (this.concise) {
            return [
                { key: 'Package2Id', label: messages.getMessage('package2Id', [], 'package2_version_list') },
                { key: 'Version', label: messages.getMessage('version', [], 'package2_version_list') },
                { key: 'Id', label: messages.getMessage('id', [], 'package2_version_list') },
                { key: 'SubscriberPackageVersionId', label: messages.getMessage('subscriberPackageVersionId', [], 'package2_version_list') },
                { key: 'Released', label: 'Released' }
            ];
        }
        const columns = [
            { key: 'Package2Name', label: 'Package2 Name' },
            { key: 'NamespacePrefix', label: 'Namespace' },
            { key: 'Package2Id', label: messages.getMessage('package2Id', [], 'package2_version_list') },
            { key: 'Name', label: 'Version Name' },
            { key: 'Version', label: messages.getMessage('version', [], 'package2_version_list') },
            { key: 'Id', label: messages.getMessage('id', [], 'package2_version_list') },
            { key: 'SubscriberPackageVersionId', label: messages.getMessage('subscriberPackageVersionId', [], 'package2_version_list') },
            { key: 'Released', label: 'Released' }
        ];
        if (this.verbose) {
            columns.push({ key: 'CreatedDate', label: 'Created Date' });
            columns.push({ key: 'LastModifiedDate', label: 'Last Modified Date' });
            columns.push({ key: 'Branch', label: messages.getMessage('package2Branch', [], 'package2_version_list') });
            columns.push({ key: 'Tag', label: messages.getMessage('package2Tag', [], 'package2_version_list') });
            columns.push({ key: 'Description', label: messages.getMessage('description', [], 'package2_version_list') });
        }
        return columns;
    }
}
Package2VersionListCommand.DEFAULT_SELECT = DEFAULT_SELECT;
Package2VersionListCommand.DEFAULT_ORDER_BY_FIELDS = DEFAULT_ORDER_BY_FIELDS;
module.exports = Package2VersionListCommand;

//# sourceMappingURL=package2VersionListCommand.js.map
