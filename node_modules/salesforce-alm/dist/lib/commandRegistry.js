/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
const fs = require('fs');
const path = require('path');
const _ = require('lodash');
const spawn = require('child_process').spawnSync;
const util = require('util');
const Config = require(path.join(__dirname, 'configApi')).Config;
const config = new Config();
const messages = require(path.join(__dirname, 'messages'))();
const logger = require(path.join(__dirname, 'logApi'));
const COMMANDS_DIR = path.join(__dirname, '..', 'commands');
const VersionCommand = require(path.join(__dirname, 'versionCommand'));
// Post break-up toolbelt, figure out a way to dynamically
// pull in SFDX commands from submodules.
const SFDX_SISTER_PLUGINS = ['force-language-services', 'salesforce-lightning-cli'];
// global parameters
const GLOBAL_PARAMETERS = _.sortBy([
    // supported by SOME commands
    // to include in --help, register flag in command's definition, eg { name: 'verbose', hidden: false }; include
    // description and longDescription to override default descriptions
    {
        name: 'verbose',
        description: 'emit additional command output to stdout',
        longDescription: 'Emit additional command output to stdout.',
        hasValue: false,
        hidden: true,
        required: false,
        type: 'flag'
    }, {
        name: 'concise',
        description: 'emit brief command output to stdout',
        longDescription: 'Emit brief command output to stdout.',
        hasValue: false,
        hidden: true,
        required: false,
        type: 'flag'
    }, {
        name: 'quiet',
        description: 'nothing emitted stdout',
        longDescription: 'Command does not output to stdout.',
        hasValue: false,
        hidden: true,
        required: false,
        type: 'flag'
    },
    // supported by ALL commands
    {
        name: 'json',
        description: messages.getMessage('jsonOutputOption'),
        longDescription: messages.getMessage('jsonOutputOptionLong'),
        hasValue: false,
        hidden: false,
        required: false,
        type: 'flag'
    }, {
        name: 'loglevel',
        description: messages.getMessage('loglevelOption'),
        longDescription: messages.getMessage('loglevelOptionLong'),
        hasValue: true,
        hidden: false,
        required: false,
        values: Object.keys(logger.levels),
        default: 'error',
        type: 'string'
    }
], (global) => global.name);
// optional supported parameters
const TARGET_USERNAME_PARAMETER = {
    name: messages.targetusername,
    char: 'u',
    description: messages.getMessage('targetUsernameOption'),
    longDescription: messages.getMessage('targetUsernameOptionLong'),
    hasValue: true,
    required: false,
    type: 'string'
};
const TARGET_DEV_HUB_USERNAME_PARAMETER = {
    name: 'targetdevhubusername',
    char: 'v',
    description: messages.getMessage('createOrgTargetDevhubUsername'),
    longDescription: messages.getMessage('createOrgTargetDevhubUsernameLong'),
    required: false,
    hasValue: true,
    type: 'string'
};
const SCHEMA_PARAMETER = {
    name: 'confighelp',
    longDescription: messages.getMessage('schemaInfoOptionLong'),
    hasValue: false,
    required: false,
    type: 'flag'
};
/**
 * Generates commands from command definitions applying
 * global and supported flags and common execution handling.
 */
class CommandDecorator {
    constructor(namespace, commandPreFilter, execCommand) {
        this.namespace = namespace;
        this.commandPreFilter = commandPreFilter;
        this.execCommand = execCommand;
        this.logger = logger.child('cmdDecorator');
        this.topics = {};
    }
    /**
     * Generate commands from command definition files decorating with common flags and
     * execution handling.
     *
     * @param cmdsDir  Directory of command definitions organized by main topic
     *                     dirs containing a main topic def file and command
     *                     definition files.
     * @param cmdDefs  Array of command definitions.
     * @param applyCommandPreFilter  Boolean, true to wrap execution (default true)
     * @returns {array}
     */
    decorate(cmdsDir, cmdDefs = [], applyCommandPreFilter = true) {
        const decoratedCmdDefs = [];
        // Read all the commands sync for when the toolbelt loads
        fs.readdirSync(cmdsDir).forEach((fileOrDir) => {
            const cmdDefPath = path.join(cmdsDir, fileOrDir);
            // if directory, directory name is main topic and directory should
            // contain same-named main topic definition file.
            if (fs.statSync(cmdDefPath).isDirectory()) {
                const tmpFileOrDir = fileOrDir; // for scope access in cmdDef iteration
                const tmpCmdDefPath = cmdDefPath; // for scope access in cmdDef iteration
                // store main topic def to generate help of all child commands
                let mainTopicCmdDef;
                const childCmdDefs = [];
                // to determine spacing in-between command name and description: '<child command>[SPACING]# <description>'
                let longestCmdName = 0;
                // process each command definition in main topic dir
                fs.readdirSync(tmpCmdDefPath).forEach((cmdDef) => {
                    const topicCmdDefPath = path.join(tmpCmdDefPath, cmdDef);
                    if (path.extname(topicCmdDefPath) === '.js') {
                        // if file is same name as main topic dir, store for later processing
                        if (cmdDef.substring(0, cmdDef.indexOf('.')) === tmpFileOrDir) {
                            mainTopicCmdDef = require(topicCmdDefPath)(); // eslint-disable-line global-require
                            mainTopicCmdDef.command = tmpFileOrDir;
                        }
                        else {
                            // process child command def file
                            const childCmd = this._processCommandDefinitionFromFile(topicCmdDefPath);
                            this._registerCommand(decoratedCmdDefs, childCmd, applyCommandPreFilter);
                            // store for main topic command listing generation
                            childCmdDefs.push(childCmd);
                            // adjust command name / description spacing, if needed
                            if (childCmd.command.length > longestCmdName) {
                                longestCmdName = childCmd.command.length;
                            }
                        }
                    }
                });
                // process main topic def, if found (error if not)
                if (mainTopicCmdDef) {
                    // compose main topic command invoked via 'force:<main-topic>' or 'force:<main-topic> --help'
                    const mainTopicCmd = this._generateMainTopicCommand(mainTopicCmdDef);
                    this._registerCommand(decoratedCmdDefs, mainTopicCmd, applyCommandPreFilter);
                    // reset
                    mainTopicCmdDef = undefined;
                }
                else {
                    throw new Error(`Main topic definition not found for '${cmdDefPath}'`);
                }
            }
            else {
                const cmd = this._processCommandDefinitionFromFile(cmdDefPath);
                this._registerCommand(decoratedCmdDefs, cmd, applyCommandPreFilter);
            }
        });
        // process command definition objects
        cmdDefs.forEach((cmdDef) => {
            const cmd = this.processCommandDefinition(cmdDef);
            this._registerCommand(decoratedCmdDefs, cmd, applyCommandPreFilter);
        });
        return decoratedCmdDefs;
    }
    /**
     * Decorates commands with global and supported parameters.  Applies standard
     * flags and behavior to main topic definitions.
     *
     * Excludes execution handling.
     *
     * @param cmdDefs  Array of undecorated command definitions.
     * @param applyCommandPreFilter  Boolean, true to wrap execution (default true)
     * @returns {array} Array of decorated command definitions.
     */
    decorateCmdDefs(cmdDefs = [], applyCommandPreFilter = true) {
        const decoratedCmdDefs = [];
        const mainTopicCmdDefs = cmdDefs.filter((cmdDef) => cmdDef.mainTopic);
        if (mainTopicCmdDefs.length === 0) {
            throw new Error('Main topic command definitions not found');
        }
        // loop thru main topics decorating each child command and
        // generating main topic command listings
        mainTopicCmdDefs.forEach((mainTopicCmdDef) => {
            // find main topic's child commands
            const childCmdDefs = cmdDefs.filter((cmdDef) => cmdDef.command && cmdDef.command.startsWith(`${mainTopicCmdDef.command}:`));
            if (childCmdDefs.length === 0) {
                throw new Error(`No commands found for main topic '${mainTopicCmdDef.command}'`);
            }
            // decorate child commands and determine spacing in-between
            // command name and description: '<child command>[SPACING]# <description>'
            let longestCmdName = 0;
            childCmdDefs.forEach((childCmdDef) => {
                // process child command def file
                const childCmd = this.processCommandDefinition(childCmdDef);
                this._registerCommand(decoratedCmdDefs, childCmd, applyCommandPreFilter);
                // adjust command name / description spacing, if needed
                if (childCmd.command.length > longestCmdName) {
                    longestCmdName = childCmd.command.length;
                }
            });
            // compose main topic command invoked via 'force:<main-topic>' or 'force:<main-topic> --help'
            const mainTopicCmd = this._generateMainTopicCommand(mainTopicCmdDef);
            this._registerCommand(decoratedCmdDefs, mainTopicCmd, applyCommandPreFilter);
        });
        // double-check that inbound and outbound command definition counts are equal
        if (cmdDefs.length !== decoratedCmdDefs.length) {
            throw new Error(`Found decorated command definition count imbalance: ${cmdDefs.length}/${decoratedCmdDefs.length}`);
        }
        return decoratedCmdDefs;
    }
    /**
     * DocOpts generator.  See http://docopt.org/.
     *
     * flag.xor:   groups elements when one of the mutually exclusive cases is required: (--apple | --orange)
     * flag.or:    groups elements when none of the mutually exclusive cases is required: [--apple | --orange]
     * flag.and:   specifies that if one element is present, then another one is required: (--apple --orange)
     * flag.array: designates that argument to the left could be repeated one or more times
     * cmd.variableArgs: produces 'name=value'
     *
     * @example
     *  {
     *      name: 'classnames',
     *      ...
     *      xor: ['suitenames']
     *  },{
     *      name: 'suitenames',
     *      type: 'string',
     *      array: true
     *      ...
     *  }
     *
     *  Results in:
     *      Usage: heroku force:apex:test:run (-n <string> | -s <string>...)
     *
     * @example
     *  {
     *      name: 'classnames',
     *      ...
     *      or: ['suitenames']
     *  },{
     *      name: 'suitenames',
     *      ...
     *  }
     *
     *  Results in:
     *      Usage: heroku force:apex:test:run [-n <string> | -s <string>]
     *
     * @example
     *  {
     *      name: 'classnames',
     *      ...
     *      and: ['suitenames']
     *  },{
     *      name: 'suitenames',
     *      type: 'flag'
     *      ...
     *  }
     *
     *  Results in:
     *      Usage: heroku force:apex:test:run (-n <string> -s )
     *
     * TODO:
     *  - Support nesting, eg:
     *      Usage: my_program (--either-this <and-that> | <or-this>)
     *      Usage: my_program [(<one-argument> <another-argument>)]
     *
     * @param cmdDef
     */
    applyUsagePattern(cmdDef) {
        if (util.isFunction(cmdDef.usage)) {
            cmdDef.usage = cmdDef.usage(cmdDef);
        }
        if (cmdDef.usage) {
            return;
        }
        let flags = cmdDef.flags;
        const paramDisplayName = 'char';
        const requiredStrs = [];
        const optionalStrs = [];
        flags = this._generateUsageElementGrouping(flags, 'xor', paramDisplayName, '(', ')', true, requiredStrs);
        flags = this._generateUsageElementGrouping(flags, 'and', paramDisplayName, '(', ')', false, requiredStrs);
        flags = this._generateUsageElementGrouping(flags, 'or', paramDisplayName, '[', ']', true, optionalStrs);
        const requiredFlags = flags.filter((flag) => flag.required);
        this._generateUsageElement(requiredStrs, requiredFlags, paramDisplayName);
        const optionalFlags = flags.filter((flag) => !flag.required);
        this._generateUsageElement(optionalStrs, optionalFlags, paramDisplayName, '[', ']');
        // Assume the topic already starts with the namespace.
        let namespacePart = '';
        // Check if the namespace already exists in the topic.
        if (this.namespace && !cmdDef.topic.startsWith(this.namespace)) {
            namespacePart = `${this.namespace}:`;
        }
        const cmd = `${namespacePart}${cmdDef.topic}${(cmdDef.command ? `:${cmdDef.command}` : '')}`;
        // TODO: heroku topic --help should NOT emit usage strings for commands
        const requiredStr = requiredStrs.length > 0 ? ` ${requiredStrs.join(' ')}` : '';
        const optionalStr = optionalStrs.length > 0 ? ` ${optionalStrs.join(' ')}` : '';
        cmdDef.usage = `${cmd}${(cmdDef.variableArgs ? ' name=value...' : '')}${requiredStr}${optionalStr}`;
    }
    /**
     * Generate and apply values option, eg (red*, blue, green), to end of
     * description attribute.  Asterisk denotes default, if applicable.
     *
     * @param cmdDef
     */
    applyFlagValueOptions(cmdDef) {
        cmdDef.flags.forEach((flag) => {
            const descriptionTrailers = [];
            if (flag.values) {
                if (util.isFunction(cmdDef.usage)) {
                    flag.values = flag.values();
                }
                if (!util.isArray(flag.values)) {
                    throw new Error(`Expected an array for ${flag.name}.values`);
                }
                // place default as first listed
                const values = [];
                if (flag.default) {
                    values.push(`${flag.default}*`);
                }
                flag.values.forEach((value) => {
                    if (value !== flag.default) {
                        values.push(value);
                    }
                });
                if (values.length > 0) {
                    flag.description = `${flag.description} (${values.join(',')})`;
                }
            }
            else if (flag.default) {
                descriptionTrailers.push({ key: 'default', value: flag.default });
            }
            if (flag.min) {
                descriptionTrailers.push({ key: 'min', value: flag.min });
            }
            if (descriptionTrailers.length > 0) {
                const trailerString = descriptionTrailers.reduce((accumulator, val, index) => {
                    if (index === 0) {
                        return `${val.key}:${val.value}`;
                    }
                    else {
                        return `${accumulator}, ${val.key}:${val.value}`;
                    }
                }, '');
                flag.description = `${flag.description} (${trailerString})`;
            }
        });
    }
    massageTopicAndCommand(cmdDef) {
        if (cmdDef.topic) {
            return cmdDef;
        }
        if (_.isString(cmdDef.command)) {
            const matcher = cmdDef.command.match(/(^[a-z0-9]+)(:?)/);
            cmdDef.topic = matcher[1];
            cmdDef.command = cmdDef.command.replace(`${matcher[1]}${matcher[2]}`, '') || undefined;
            this.logger.trace(`${cmdDef.topic}${cmdDef.mainTopic ? ' (main topic)' : `:${cmdDef.command}`}`);
        }
        if (cmdDef.mainTopic) {
            this.topics[cmdDef.topic] = cmdDef.description;
            if (cmdDef.hideTopicFromTopicList) {
                this.topics[cmdDef.topic] = false;
            }
        }
        return cmdDef;
    }
    applyDeprecationWarnings(cmdDef) {
        if (cmdDef.deprecated) {
            cmdDef.description = `WARNING: ${logger.formatDeprecationWarning(cmdDef.command, cmdDef.deprecated, 'command')}\n\n${cmdDef.description}`;
        }
        cmdDef.flags.forEach(flag => {
            if (flag.deprecated) {
                flag.description = `WARNING: ${logger.formatDeprecationWarning(flag.name, flag.deprecated, 'flag')}`;
            }
        });
    }
    /**
     * Process command definition by:
     *   - set requiresProject and requiresUsername
     *   - applying global flags
     *   - applying supporting flags
     *   - generating docopts and applying to usage attribute
     *   - generating values str and applying to end of description attribute
     *
     * @param cmdDef
     * @returns {*}
     */
    processCommandDefinition(cmdDef) {
        this.massageTopicAndCommand(cmdDef);
        if (!cmdDef.flags) {
            cmdDef.flags = [];
        }
        // we assume by default all commands require a project workspace. Specifying requiresProject=false in the command
        // JSON will allow a command to execute outside of a project workspace.
        if (util.isUndefined(cmdDef.requiresProject)) {
            cmdDef.requiresProject = true;
        }
        // apply commonly supported flags, eg 'username' via 'requiresUsername:true'
        this._applySupportedFlags(cmdDef);
        // apply globally supported flags
        this._applyGlobalFlags(cmdDef);
        // generate and apply "Usage: <cmd> <required and optional flags>";
        // calling this after _applyGlobalFlags will include global flags, if supported
        this.applyUsagePattern(cmdDef);
        // generate and apply value options for each flag, where applicable.  Eg '<description> (green*, blue, red)'
        this.applyFlagValueOptions(cmdDef);
        this.applyDeprecationWarnings(cmdDef);
        return cmdDef;
    }
    //   P R I V A T E   M E T H O D S
    _generateUsageElementGrouping(flags, conditionalAttrName, paramDisplayName, beforeChar, afterChar, mutualExclusive, strs) {
        const groupFlags = flags.filter((flag) => flag[conditionalAttrName]);
        groupFlags.forEach((conditionalFlag) => {
            const conditionalStrs = [];
            this._generateUsageElement(conditionalStrs, [conditionalFlag], paramDisplayName);
            const optionFlags = [];
            conditionalFlag[conditionalAttrName].forEach((optionFlagName) => {
                const optionFlag = flags.find((flag) => flag.name === optionFlagName);
                optionFlags.push(optionFlag);
            });
            optionFlags.forEach((optionFlag) => {
                if (optionFlag.xor || optionFlag.or || optionFlag.and) {
                    throw new Error(`Nested flag grouping not supported for ${conditionalAttrName}`);
                }
                this._generateUsageElement(conditionalStrs, [optionFlag], paramDisplayName);
                // remove flag from
                flags = flags.filter((flag) => flag.name !== optionFlag.name);
            });
            const separator = mutualExclusive ? ' | ' : ' ';
            strs.push(`${beforeChar}${conditionalStrs.join(separator)}${afterChar}`);
            // remove 'or flags', handled here
            flags = flags.filter((flag) => flag.name !== conditionalFlag.name);
        });
        return flags;
    }
    _generateUsageElement(elementStrs = [], flags, paramDisplayName = 'char', beforeChar = '', afterChar = '') {
        const paramDash = paramDisplayName === 'char' ? '-' : '--';
        flags.forEach((flag) => {
            // don't show usage for hidden flags
            if (!flag.hidden) {
                // not all flags have short names
                const flagName = flag[paramDisplayName] ?
                    `${paramDash}${flag[paramDisplayName]}` : `--${flag.name}`;
                const type = flag.hasValue ? ` <${flag.type || 'string'}>${flag.array ? '...' : ''}` : '';
                elementStrs.push(`${beforeChar}${flagName}${type}${afterChar}`);
            }
        });
    }
    _applyCommandPreFilter(cmdDef) {
        const commandRunWrapper = cmdDef.run;
        cmdDef.run = this.commandPreFilter.bind({
            command: commandRunWrapper,
            commandContext: cmdDef
        });
        return cmdDef;
    }
    // compose main topic command invoked via 'force:<main-topic>' or 'force:<main-topic> --help'
    _generateMainTopicCommand(mainTopicCmdDef) {
        mainTopicCmdDef.requiresProject = false;
        mainTopicCmdDef.supportsTargetUsername = false;
        mainTopicCmdDef.hidden = true;
        mainTopicCmdDef.mainTopic = true;
        this.massageTopicAndCommand(mainTopicCmdDef);
        const fullCommand = `${this.namespace}:${mainTopicCmdDef.topic}`;
        mainTopicCmdDef.usage = `${fullCommand}:COMMAND [command-specific-options]`;
        const executableName = process.env.HEROKU_EXECUTABLE_NAME || 'sfdx';
        // generate run command to invoke 'sfdx <main topic> --help'
        if (!mainTopicCmdDef.run) {
            mainTopicCmdDef.run = (context) => this.execCommand({
                execute: () => {
                    // spawn to generate --help consistently across
                    // force:<main-topic>' and 'force:<main-topic> --help' invocations
                    const helpStr = spawn(executableName, [fullCommand, '--help']);
                    logger.logRaw(helpStr.stdout.toString());
                    return Promise.resolve('');
                },
                getHumanErrorMessage: () => 'MainTopicHelpCommand',
                getHumanSuccessMessage: () => undefined
            }, context);
        }
        return mainTopicCmdDef;
    }
    // apply globally supported flags
    _applyGlobalFlags(cmdDef) {
        GLOBAL_PARAMETERS.forEach((globalFlag) => {
            // commands are allowed to override global's descriptions
            const hasGlobalFlag = cmdDef.flags.find((existingFlag) => existingFlag.name === globalFlag.name);
            if (hasGlobalFlag) {
                if (hasGlobalFlag.char) {
                    throw new Error(`DEV ERR: Global shortnames not permitted: command '${cmdDef.command}', shortname '${hasGlobalFlag.char}'`);
                }
                if (hasGlobalFlag.required) {
                    throw new Error(`DEV ERR: Global parameters are not required: command '${cmdDef.command}', param '${hasGlobalFlag.name}'`);
                }
                if (hasGlobalFlag.hasValue && !globalFlag.hasValue) {
                    throw new Error(`DEV ERR: Global parameters do not take a value (hasValue): command '${cmdDef.command}', param '${hasGlobalFlag.name}'`);
                }
                // remove existing flag then re-add w/ merged flag def where command overrides global flag def
                cmdDef.flags = cmdDef.flags.filter((existingFlag) => existingFlag.name !== globalFlag.name);
                cmdDef.flags.push(Object.assign({}, globalFlag, hasGlobalFlag));
            }
            else if (!globalFlag.hidden) {
                cmdDef.flags.push(Object.assign({}, globalFlag));
            }
        });
    }
    _applyFlag(cmdDef, flag) {
        const dupFlag = cmdDef.flags.find((existingFlag) => existingFlag.name === flag.name || (existingFlag.char && existingFlag.char === flag.char));
        if (dupFlag) {
            throw new Error(`DEV ERR: Found duplicate name or shortname for command '${cmdDef.command}' and flag '${flag.name}'`);
        }
        cmdDef.flags.push(flag);
    }
    // apply cross-command flags, if supported
    _applySupportedFlags(cmdDef) {
        if (cmdDef.schema) {
            const description = messages.getMessage('schemaInfoOption', cmdDef.schema.flag);
            this._applyFlag(cmdDef, Object.assign({ description }, SCHEMA_PARAMETER));
        }
        // allow commands to override different properties on the targetusername flag ('cept for name and char), eg org:delete.
        // must commands will support, so undefined === does NOT support
        this._applyTargetUsernameSupport(cmdDef, 'supportsTargetUsername', TARGET_USERNAME_PARAMETER, false);
        // allow commands to override different properties on the targetusername flag ('cept for name and char)
        // must commands will NOT support, so undefined === does NOT support
        this._applyTargetUsernameSupport(cmdDef, 'supportsTargetDevHubUsername', TARGET_DEV_HUB_USERNAME_PARAMETER, false);
    }
    _applyTargetUsernameSupport(cmdDef, supportsAttributeName, supportedFlag, valueIfUndefined) {
        const supportFlag = cmdDef.flags.find(flag => flag.name === supportedFlag.name);
        if (supportFlag) {
            // having
            if (supportFlag.char && supportFlag.char !== supportedFlag.char) {
                throw new Error(`DEV ERR: Invalid command definition: Command ${cmdDef.command}'s flag '${supportFlag.name}' must assign '${supportedFlag.char}' shorthand for --${supportedFlag.name}.`);
            }
            // set attrs for clarity & consistency
            cmdDef[supportsAttributeName] = true;
            // merge enables overriding descriptions and required:true
            cmdDef.flags = cmdDef.flags.filter((existingFlag) => existingFlag.name !== supportedFlag.name);
            this._applyFlag(cmdDef, Object.assign({}, supportedFlag, supportFlag));
        }
        else {
            // if undefined, set attr to boolean value for clarity & consistency
            cmdDef[supportsAttributeName] = _.isBoolean(cmdDef[supportsAttributeName])
                ? cmdDef[supportsAttributeName]
                : valueIfUndefined;
            if (cmdDef[supportsAttributeName]) {
                // non-existence of supports attribute may default to either supports or does not support
                const uFlag = cmdDef.flags.find(flag => flag.char === supportedFlag.char);
                if (uFlag) {
                    throw new Error(`DEV ERR: Invalid command definition: Command ${cmdDef.command}'s flag '${uFlag.name}' uses the ${supportedFlag.char}' shorthand which is required for --${supportedFlag.name}.  Either change the shorthand or set ${supportsAttributeName} false`);
                }
                // apply to command
                this._applyFlag(cmdDef, Object.assign({}, supportedFlag));
            }
        }
    }
    _registerCommand(cmdDefs, cmdDef, applyCmdPreFilter) {
        cmdDefs.push(applyCmdPreFilter ? this._applyCommandPreFilter(cmdDef) : cmdDef);
    }
    // generate command object from command definition file
    _processCommandDefinitionFromFile(cmdDefPath) {
        const cmdDef = require(cmdDefPath)(this.execCommand); // eslint-disable-line global-require
        const cmdFileName = cmdDefPath.substring(cmdDefPath.lastIndexOf(path.sep));
        cmdDef.command = cmdFileName.match(/([a-zA-Z0-9_]+)/)[1].replace(/_/g, ':');
        return this.processCommandDefinition(cmdDef);
    }
}
/**
 * Registers commands from command definitions applying
 * global and supported flags and common execution handling.
 */
class CommandRegistry {
    constructor(namespace, commandPreFilter, execCommand) {
        this.namespace = namespace;
        this.commandPreFilter = commandPreFilter;
        this.execCommand = execCommand;
        this.logger = logger.child('cmdRegistry');
        this._decorator = new CommandDecorator(namespace, commandPreFilter, execCommand);
        this._commands = [];
        this._register();
    }
    /**
     * @returns {array} decorated commands ready for service
     */
    get commands() {
        return this._commands;
    }
    /**
     * @returns {array} decorated commands ready for service
     */
    get topics() {
        return _.reduce((this._decorator && this._decorator.topics) || {}, (arr, description, name) => {
            arr.push({
                name,
                description: description || '',
                hidden: !description
            });
            return arr;
        }, []);
    }
    /**
     * @returns {CommandDecorator} decorator instance
     */
    get decorator() {
        return this._decorator;
    }
    //   P R I V A T E   M E T H O D S
    _register() {
        this._commands = this._decorator.decorate(COMMANDS_DIR, this._specialCommandDefs());
    }
    _specialCommandDefs() {
        // force --version
        const forceCmd = {
            namespace: this.namespace,
            hidden: true,
            topic: '',
            requiresProject: false,
            flags: [{
                    name: 'version',
                    char: 'v',
                    description: messages.getMessage('versionDescription', null, 'versionCommand')
                }],
            run: (context) => this.execCommand(new VersionCommand(config), context)
        };
        return [forceCmd];
    }
}
// Static properties for use by command wrappers.  I.e., src/commands/**/*
CommandRegistry.SFDX_SUB_MODULES = SFDX_SISTER_PLUGINS;
CommandRegistry.COMMANDS_DIR = COMMANDS_DIR;
CommandRegistry.TARGET_USERNAME_PARAMETER = TARGET_USERNAME_PARAMETER;
CommandRegistry.TARGET_DEV_HUB_USERNAME_PARAMETER = TARGET_DEV_HUB_USERNAME_PARAMETER;
CommandRegistry.SCHEMA_PARAMETER = SCHEMA_PARAMETER;
CommandRegistry.GLOBAL_PARAMETERS = GLOBAL_PARAMETERS;
module.exports = CommandRegistry;

//# sourceMappingURL=commandRegistry.js.map
