"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright, 1999-2016, salesforce.com
 * All Rights Reserved
 * Company Confidential
 */
const _ = require("lodash");
const almError = require("../almError");
const Alias = require("../alias");
const command_1 = require("../command");
const user_1 = require("./user");
const permissionSetAssignment_1 = require("./permissionSetAssignment");
/**
 * Assign a named Permission Set to a list of users, a specific user, or the default user.
 */
class UserPermsetAssignCommand extends command_1.default {
    constructor() {
        super('user:permset:assign');
        this.successes = [];
        this.failures = [];
    }
    validate(context) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            // verify we have an org.  can't do anything without an org
            if (!context.org) {
                throw almError({ keyName: 'noOrgProvided', bundle: 'generatePassword' });
            }
            this.org = context.org;
            return _super("validate").call(this, context);
        });
    }
    /**
     * executes the assign command
     * @param context - the cli context
     * @returns {Promise}
     */
    execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
            this.usernames = _.map((_.get(context, 'flags.onbehalfof') || this.org.getName()).split(','), _.trim);
            // Convert any aliases to usernames
            const aliases = yield Alias.list();
            this.usernames = this.usernames.map(username => aliases[username] || username);
            let users = yield user_1.default.fetchUsers(this.org, this.usernames);
            return Promise.all(users.map(user => new permissionSetAssignment_1.default(this.org).create(user, context.flags.permsetname)
                .then((psa) => {
                this.successes.push({ name: user.getField('username'), value: context.flags.permsetname });
                return psa;
            })
                .catch(err => {
                this.failures.push({ name: user.getField('username'), message: err.message });
            }))).then(() => {
                return { successes: this.successes, failures: this.failures };
            });
        });
    }
    getHumanSuccessMessage() {
        if (this.successes.length > 0) {
            this.logger.styledHeader(this.logger.color.blue('Permsets Assigned'));
            this.logger.table(this.successes, { columns: [
                    { key: 'name', label: 'Username' },
                    { key: 'value', label: 'Permission Set Assignment' }
                ] });
        }
        if (this.failures.length > 0) {
            if (this.successes.length > 0) {
                this.logger.log('');
            }
            this.logger.styledHeader(this.logger.color.red('Failures'));
            this.logger.table(this.failures, { columns: [
                    { key: 'name', label: 'Username' },
                    { key: 'message', label: 'Error Message' }
                ] });
        }
    }
}
exports.UserPermsetAssignCommand = UserPermsetAssignCommand;
exports.default = UserPermsetAssignCommand;

//# sourceMappingURL=userPermsetAssignCommand.js.map
