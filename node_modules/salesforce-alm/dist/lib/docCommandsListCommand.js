/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
const path = require('path');
// Thirdparty
const Promise = require('bluebird');
const _ = require('lodash');
// Local
const Config = require(path.join(__dirname, 'configApi')).Config;
const messages = require(path.join(__dirname, 'messages'));
const logger = require(path.join('..', 'lib', 'logApi'));
const main = require(path.join('..', 'index'));
// Post break-up toolbelt, figure out a way to dynamically
// pull in SFDX commands from submodules.
const SFDX_SUB_MODULES = require(path.join('..', 'lib', 'commandRegistry')).SFDX_SUB_MODULES;
/**
 * Command lists each SFDX command.  JSON output
 * aggregates all commands into single JSON string.
 */
class DocCommandsListCommand {
    constructor(requireFn = require) {
        this.messages = messages(new Config().getLocale());
        this.logger = logger.child('docCommandsListCommand');
        this.cmds = [];
        main.commands.forEach((cmd) => {
            if (!cmd.command) {
                return;
            }
            this.cmds.push({
                name: `${cmd.topic}:${cmd.command}`,
                description: cmd.description,
                usage: cmd.usage
            });
        });
        SFDX_SUB_MODULES.forEach((module) => {
            try {
                // pull module from cli node_modules;
                // try-catch 'cause module may not exist.
                const moduleCmds = requireFn(module).commands; // eslint-disable-line global-require
                if (moduleCmds) {
                    moduleCmds.forEach((moduleCmd) => {
                        if (!moduleCmd.command) {
                            return;
                        }
                        if (!moduleCmd.usage) {
                            main.commandDecorator.applyUsagePattern(moduleCmd);
                        }
                        this.cmds.push({
                            name: `${moduleCmd.topic}:${moduleCmd.command}`,
                            description: moduleCmd.description,
                            usage: moduleCmd.usage
                        });
                    });
                }
                else {
                    this.logger.warn(`No commands found in module ${module}`);
                }
            }
            catch (err) {
                this.logger.warn(err.message);
            }
        });
        this.cmds = _.chain(this.cmds)
            .sortBy([function (o) { return o.name ? o.name.toUpperCase() : o.name; }])
            .value();
    }
    validate() {
        return Promise.resolve(null);
    }
    execute(context) {
        this.usage = context.flags.usage;
        this.cmds = this.cmds.map(cmd => {
            if (this.usage) {
                return cmd.usage;
            }
            else {
                return { name: cmd.name, description: cmd.description };
            }
        });
        return Promise.resolve(this.cmds);
    }
    getHumanSuccessMessage() {
        let cmdList = [];
        if (this.usage) {
            cmdList = this.cmds.map(cmd => `  ${cmd}`);
        }
        else {
            const longestCmdName = this.cmds.reduce((acc, curr) => Math.max(acc, curr.name.length), 0);
            this.cmds.forEach((cmd) => {
                const buffer = new Array((longestCmdName - cmd.name.length) + 2).join(' ');
                cmdList.push(`  ${cmd.name}${buffer}# ${cmd.description}`);
            });
        }
        this.logger.styledHeader(this.logger.color.blue('Commands'));
        this.logger.log(cmdList.join('\n'));
        return '';
    }
}
module.exports = DocCommandsListCommand;

//# sourceMappingURL=docCommandsListCommand.js.map
