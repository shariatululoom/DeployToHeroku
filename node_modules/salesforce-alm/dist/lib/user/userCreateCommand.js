"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
const _ = require("lodash");
const fs = require("fs");
const messages = require("../messages");
const almError = require("../almError");
const srcDevUtil = require("../srcDevUtil");
const Org = require("../scratchOrgApi");
const Alias = require("../alias");
const varargsCommand_1 = require("../varargsCommand");
const user_1 = require("./user");
class UserCreateCommand extends varargsCommand_1.default {
    constructor() {
        super('user:create');
        this.successes = [];
        this.failures = [];
    }
    validate(context) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            // verify we have an org.  can't do anything without an org
            if (!context.org) {
                throw almError({ keyName: 'noOrgProvided', bundle: 'user_create' });
            }
            // verify that the org is a scratch org
            return context.org.checkScratchOrg(context.flags.defaultdevhubusername)
                .then(() => { this.org = context.org; })
                .then(() => _super("validate").call(this, context));
        });
    }
    execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
            this.user = new user_1.default(context.org);
            // Build the user config
            const { fields, generatepassword, permsets = [] } = yield this._buildUserConfig(context);
            // Create the user
            yield this.user.create(fields);
            this.successes.push({ name: 'User Creation', value: this.user.id });
            // Assign permission sets to the created user
            if (permsets.length) {
                try {
                    yield this.user.assignPermissionSets(permsets);
                    this.successes.push({ name: 'Permission Set Assignment', value: permsets.join() });
                }
                catch (err) {
                    this.failures.push({ name: 'Permission Set Assignment', message: err.message });
                }
            }
            // Create the initial auth info
            const authInfo = this._buildAuthInfo(context.flags);
            // Create a new scratch org config for this user
            const newUserOrg = new Org(this.org.force);
            newUserOrg.setName(authInfo.username);
            // Write the auth file for this user
            try {
                yield this.org.force.authorizeAndSave(authInfo, newUserOrg);
                this.logger.info(`Authenticated new user: ${this.user.getField('username')} for org ${this.org.authConfig.orgId}`);
            }
            catch (err) {
                // If we can't auth as this user then save a user auth config without an access token (so user:display works) and continue
                this.logger.debug(`Could not authenticate with user: ${this.user.getField('username')} and profile: ${this.user.getField('profileid')} due to error: ${err.message}`);
                delete authInfo.refreshToken;
                yield newUserOrg.saveConfig(Object.assign(authInfo, { accessToken: '<NO API ACCESS>' }), undefined);
            }
            // Generate and set a password if specified
            if (generatepassword) {
                try {
                    yield this.user.assignPassword();
                    this.successes.push({ name: 'Password Assignment', value: this.user.password });
                }
                catch (err) {
                    this.failures.push({ name: 'Password Assignment', message: err.message });
                }
            }
            // Write/update the <orgId>.json file to keep track of users in the org for later cleanup
            yield this._updateOrgFile(authInfo.scratchAdminUsername);
            // Set the alias if specified
            if (context.flags.setalias) {
                yield Alias.set(context.flags.setalias, this.user.getField('username'));
            }
            return Promise.resolve(Object.assign({ orgId: this.org.authConfig.orgId }, this.user.toJSON()));
        });
    }
    // Builds a user config that merges properties from a definition file with any
    // key/value pairs specified on the command line.  Command line props override
    // those from the definition file.  Any missing required fields are generated
    // based on the specified or default username.
    _buildUserConfig(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const userDefFile = context.flags.definitionfile;
            let userConfig = {};
            const config = {};
            // Get config defined in the user definition file
            if (userDefFile) {
                userConfig = yield srcDevUtil.readJSON(userDefFile);
            }
            // Command line props override config file props
            userConfig = Object.assign(srcDevUtil.toLowerCaseKeys(userConfig), srcDevUtil.toLowerCaseKeys(this.keyValuePairs));
            userConfig = yield this._addDefaultProps(userConfig);
            //
            // Build a new config object that's easier to consume for execute()
            //
            const { permsets, generatepassword } = userConfig;
            if (permsets) {
                config.permsets = _.isString(permsets) ? permsets.split(',') : permsets;
                delete userConfig.permsets;
            }
            if (generatepassword) {
                config.generatepassword = generatepassword === true || generatepassword === 'true';
                delete userConfig.generatepassword;
            }
            delete userConfig.profilename;
            config.fields = userConfig;
            this.logger.debug('Creating user with config:', config);
            return config;
        });
    }
    // Builds an auth object for this user to authenticate and save in a file in the global hidden directory.
    _buildAuthInfo({ setalias }) {
        const { orgId, instanceUrl, devHubUsername, loginUrl, clientId, clientSecret, privateKey } = this.org.authConfig;
        const authInfo = {
            orgId,
            instanceUrl,
            devHubUsername,
            loginUrl,
            createdOrgInstance: 'utf8',
            username: this.user.getField('username'),
            userId: this.user.id,
            userProfileName: this.profileName,
            created: this.user.getField('createddate'),
            refreshToken: this.user.refreshToken,
            scratchAdminUsername: this.org.getName()
        };
        // Set the clientId, clientSecret, and privateKey of the admin user if they exist
        if (clientId)
            authInfo.clientId = clientId;
        if (clientSecret)
            authInfo.clientSecret = clientSecret;
        if (privateKey)
            authInfo.privateKeyFile = privateKey;
        return authInfo;
    }
    // Add any properties that are required by the User API and not specified by the CLI user.
    _addDefaultProps(userConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const missingRequiredFields = _.difference(user_1.default.REQUIRED_FIELDS, Object.keys(userConfig));
            // Assign a profile ID
            if (missingRequiredFields.includes('profileid')) {
                this.profileName = userConfig.profilename || 'Standard User';
                this.logger.debug(`Querying org for profile name [${this.profileName}]`);
                const profileQuery = `SELECT id FROM profile WHERE name='${this.profileName}'`;
                const response = yield this.org.force.query(this.org, profileQuery);
                userConfig.profileid = _.get(response, 'records[0].Id');
                if (!userConfig.profileid) {
                    throw almError({ keyName: 'profileNameNotFound', bundle: 'user_create' }, this.profileName);
                }
                _.pull(missingRequiredFields, 'profileid');
            }
            else {
                // A profileID was provided so query for the profile name from the ID
                const profileQR = yield this.org.force.query(this.org, `SELECT name FROM profile WHERE id='${userConfig.profileid}'`);
                this.profileName = _.get(profileQR, 'records[0].Name');
            }
            // Generate a unique username based on the specified or default scratch org admin's username
            if (missingRequiredFields.includes('username')) {
                const username = this.org.getName();
                this.logger.debug(`Setting default username based on username [${username}]`);
                userConfig.username = `${Date.now()}_${username}`;
                _.pull(missingRequiredFields, 'username');
            }
            // Fetch the user details for the specified or default username
            // to default any other required fields
            if (missingRequiredFields.length) {
                const missingFields = missingRequiredFields.join();
                const username = this.org.getName();
                this.logger.debug(`Querying org for username [${username}] to default missing required fields [${missingFields}]'`);
                const userQuery = `SELECT ${missingFields} FROM user WHERE username='${username}'`;
                const response = yield this.org.force.query(this.org, userQuery);
                const userInfo = _.get(response, 'records[0]');
                delete userInfo.attributes;
                Object.assign(userConfig, srcDevUtil.toLowerCaseKeys(userInfo));
            }
            return userConfig;
        });
    }
    // Creates or updates the org file in $HOME/.sfdx (<orgId>.json) with the newly created username and the
    // scratch org admin username to simplify org cleanup.
    _updateOrgFile(scratchAdminUsername) {
        return __awaiter(this, void 0, void 0, function* () {
            const orgId = this.org.authConfig.orgId;
            const username = this.user.getField('username');
            const orgFileName = `${orgId}.json`;
            const orgFilePath = srcDevUtil.getGlobalFilePath(orgFileName);
            try {
                const orgFileExists = fs.existsSync(orgFilePath);
                const orgFileData = orgFileExists ? yield srcDevUtil.readJSON(orgFilePath) : { usernames: [scratchAdminUsername] };
                orgFileData.usernames.push(username);
                yield srcDevUtil.saveGlobalConfig(orgFileName, orgFileData);
                this.logger.info(`Updated org file: ${orgFileName} with new user: ${username}`);
            }
            catch (err) {
                this.logger.info(`Could not write new user data to org file: ${orgFileName} \n Error Message: ${err.message}`);
            }
            return Promise.resolve();
        });
    }
    getHumanSuccessMessage() {
        const username = this.user.getField('username');
        const userId = this.user.id;
        const orgId = this.org.authConfig.orgId;
        const userCreatedSuccessMsg = messages().getMessage('success', [username, userId, orgId, username], 'user_create');
        if (this.failures.length) {
            this.logger.styledHeader(this.logger.color.yellow('Partial Success'));
            this.logger.log(userCreatedSuccessMsg);
            this.logger.log('');
            this.logger.styledHeader(this.logger.color.red('Failures'));
            this.logger.table(this.failures, { columns: [
                    { key: 'name', label: 'Action' },
                    { key: 'message', label: 'Error Message' }
                ] });
        }
        else {
            return userCreatedSuccessMsg;
        }
    }
}
exports.UserCreateCommand = UserCreateCommand;
exports.default = UserCreateCommand;

//# sourceMappingURL=userCreateCommand.js.map
