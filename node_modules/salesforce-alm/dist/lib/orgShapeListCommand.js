"use strict";
const path = require('path');
const _ = require('lodash');
const Promise = require('bluebird');
const Org = require(path.join(__dirname, 'scratchOrgApi'));
const messages = require(path.join(__dirname, 'messages'))();
const logger = require(path.join(__dirname, 'logApi'));
const OrgDecorator = require(path.join(__dirname, 'orgHighlighter'));
const ShapeRepApi = require(path.join(__dirname, 'shapeRepApi'));
const EMPTY_STRING = '';
/**
 * Command impl for force:org:shape:list
 */
class OrgShapeListCommand {
    constructor() {
        this.logger = logger.child('OrgShapeListCommand');
        this.orgDecorator = new OrgDecorator(this.logger);
    }
    execute() {
        const sortAndDecorateFunc = (val) => {
            const sortVal = val.username;
            this.orgDecorator.decorateStatus(val);
            return [val.alias, sortVal];
        };
        return Org.readAllUserFilenames()
            .then(fileNames => Org.readLocallyValidatedMetaConfigsGroupedByOrgType(fileNames, 3, null))
            .then((metaConfigs) => {
            const reachableOrgs = [];
            metaConfigs.nonScratchOrgs.forEach((orgMeta) => {
                this.logger.info(`Checking org: ${orgMeta.username} with status: ${orgMeta.connectedStatus}`);
                if (orgMeta.connectedStatus && orgMeta.connectedStatus === 'Connected') {
                    reachableOrgs.push(orgMeta);
                }
            });
            return reachableOrgs;
        })
            .then((reachableOrgs) => {
            const shapes = [];
            const allOrgs = Promise.map(reachableOrgs, (orgMeta) => {
                // need an Org to make sobject query
                this.logger.info(`Query org: ${orgMeta.username} for shapes`);
                const shapeOrg = Org.create(orgMeta.username);
                return shapeOrg.then((org) => org.getConfig().then(() => {
                    // query all shape representations for an org
                    const shapeApi = new ShapeRepApi(null, org);
                    const query = shapeApi.findShapesOrNull();
                    return query.then((queryResult) => {
                        if (!_.isNil(queryResult)) {
                            return { shapeMeta: orgMeta, result: queryResult };
                        }
                        return null;
                    });
                }));
            }, { concurrency: 1 })
                .catch((err) => {
                this.logger.error(false, 'Error finding org shapes', err);
                throw err;
            })
                .then((results) => {
                results.forEach((r) => {
                    if (!_.isNil(r)) {
                        // process all ShapeRepresentation records for this org
                        _.forEach(r.result.records, (shape) => {
                            const meta = r.shapeMeta;
                            const orgShape = {
                                orgId: meta.orgId,
                                username: meta.username,
                                alias: meta.alias,
                                shapeId: shape.Id,
                                status: shape.Status,
                                createdBy: shape.CreatedBy.Username,
                                createdDate: shape.CreatedDate
                            };
                            shapes.push(orgShape);
                        });
                    }
                });
            });
            // resolve shape orgs to find all shape representations
            return Promise.join(allOrgs, () => shapes);
        })
            .then((shapes) => {
            this.logger.styledHeader(this.logger.color.blue('Org Shapes'));
            return shapes;
        })
            .then((shapes) => ({ orgShapes: _.sortBy(shapes, sortAndDecorateFunc) }));
    }
    validate(context) {
        return Promise.resolve(context.flags);
    }
    getHumanErrorMessage() {
        return EMPTY_STRING;
    }
    getHumanSuccessMessage() {
        return EMPTY_STRING;
    }
    getEmptyResultMessage(key) {
        if (key === 'orgShapes') {
            return messages.getMessage('noOrgShapes', null, 'org_shape_list');
        }
        return null;
    }
    getColumnData() {
        // default columns for the shape list
        const orgShapeColumns = [
            { key: 'defaultMarker', label: '' },
            { key: 'alias', label: 'ALIAS' },
            { key: 'username', label: 'USERNAME' },
            { key: 'orgId', label: 'ORG ID' },
            { key: 'status', label: 'SHAPE STATUS' },
            { key: 'createdBy', label: 'CREATED BY' },
            { key: 'createdDate', label: 'CREATED DATE' }
        ];
        return {
            orgShapes: orgShapeColumns
        };
    }
}
module.exports = OrgShapeListCommand;

//# sourceMappingURL=orgShapeListCommand.js.map
