/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// Node
const path = require('path');
const url = require('url');
const _ = require('lodash');
// Thirdparty
const Promise = require('bluebird');
const fs = Promise.promisifyAll(require('fs'));
// Local
const ConfigApi = require(path.join(__dirname, 'configApi')).Config;
const Org = require(path.join(__dirname, 'scratchOrgApi'));
const Alias = require(path.join(__dirname, 'alias'));
const messages = require(path.join(__dirname, 'messages'));
const almError = require(path.join(__dirname, 'almError'));
const openBrowser = require(path.join(__dirname, 'openBrowser'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const consts = require(path.join(__dirname, 'constants'));
const SfdxConfigAggregator = require(path.join(__dirname, 'config', 'SfdxConfigAggregator'));
const defaultConnectedAppInfo = require(path.join(__dirname, 'defaultConnectedApp'));
const urls = require(path.join(__dirname, 'urls'));
const getType = context => {
    let type;
    if (context.setdefaultusername) {
        type = Org.Defaults.USERNAME;
    }
    else if (context.setdefaultdevhubusername) {
        type = Org.Defaults.DEVHUB;
    }
    return type;
};
/**
 * stdin handler called when the client secret is obtained from the user.
 * @param force  - the force api.
 * @param clientSecret - the Oauth client secret.
 * @param context - the cli context.
 */
const doAuth = function (force, clientSecret, context, orgApi, loginUrl) {
    const oauthConfig = {
        clientId: context.clientid,
        clientSecret,
        redirectUri: force.getConfig().getOauthCallbackUrl(),
        loginUrl
    };
    const authUrl = force.getAuthorizationUrl(oauthConfig);
    const server = require(path.join(__dirname, 'process')); // eslint-disable-line global-require
    // This call starts up a web server that handles Oauth redirect requests
    return server.startOauth(orgApi, oauthConfig, 
    /**
     * callback that checks the orgs state parameter. used to prevent request forgery.
     * @param requestState - state id generated in force.js
     * @returns {boolean} - true if the id in the state matches what the server sent back.
     */
    (requestState) => {
        const query = url.parse(authUrl, true).query;
        return !_.isNil(requestState) && requestState === query.state;
    }, getType(context))
        .then(({ oauthResponse }) => {
        // We want to open the browser after we start the outh server incase
        // there is a problem starting the oauth server.
        openBrowser.open(authUrl);
        // Then we want to wait for the auth response once the browser is opened
        return oauthResponse.then(() => orgApi.getConfig());
    });
};
const AUTH_URL_REGEXP = /^force:\/\/(?:([^:]*):([^:]*):)?([^@]*)@([\w@:/\-.]*)$/;
const _doSfdxUrlAuth = function (force, context, orgApi) {
    const type = getType(context);
    const file = context.sfdxurlfile;
    return srcDevUtil.readJSON(file)
        .catch(() => fs.readFileAsync(file, 'utf8').then(sfdxAuthUrl => ({ sfdxAuthUrl })))
        .then(({ sfdxAuthUrl }) => {
        const matcher = _.isString(sfdxAuthUrl) && sfdxAuthUrl.trim().match(AUTH_URL_REGEXP);
        if (!matcher) {
            throw almError({ keyName: 'InvalidSfdxAuthUrl', bundle: 'auth_sfdxurl' }, [consts.AUTH_URL_FORMAT1, consts.AUTH_URL_FORMAT2]);
        }
        // We have 4 possible vars specified in the format. clientId, clientSecret, refreshToken, instanceUrl
        const NUM_VARS = 4;
        const variables = [];
        let matcherIndex = matcher.length - 1;
        let variableIndex = NUM_VARS - 1;
        // Start from the back of the matcher, and move backwards since some variables are optional
        while (variableIndex >= 0) {
            if (matcherIndex > 0) {
                variables.push(matcher[matcherIndex]);
            }
            else {
                variables.push(undefined);
            }
            variableIndex--;
            matcherIndex--;
        }
        const [tmpInstanceUrl, refreshToken, clientSecret, clientId] = variables;
        // ensure url has https (add-on may or may not supply it)
        const instanceUrl = !tmpInstanceUrl.startsWith('http') ? `https://${tmpInstanceUrl}` : tmpInstanceUrl;
        return force.authorizeAndSave({
            instanceUrl,
            loginUrl: instanceUrl,
            refreshToken,
            clientSecret,
            clientId
        }, orgApi, !!type);
    });
};
const _doJwtAuth = function (force, context, orgApi, loginUrl) {
    const type = getType(context);
    const oauthConfig = {
        clientId: context.clientid,
        loginUrl,
        username: context.username,
        privateKeyFile: context.jwtkeyfile
    };
    return force.authorizeAndSave(oauthConfig, orgApi, !!type);
};
/**
 * module interface for the authorization command
 * @param force - reference to the force implementation
 * @constructor
 */
class AuthCommand {
    constructor(force) {
        const Force = require(path.join(__dirname, 'force')); // eslint-disable-line global-require
        this.force = _.isNil(force) ? new Force(new ConfigApi()) : force;
        this.force.generateCodeChallenge();
        this.messages = messages(this.force.config.getLocale());
    }
    validate(context) {
        const username = context.flags.username;
        const file = context.flags.jwtkeyfile;
        if ((!_.isNil(username) && _.isNil(file)) ||
            (_.isNil(username) && !_.isNil(file))) {
            const jwtError = new Error(this.messages.getMessage('authorizeCommandMissingJwtOption'));
            jwtError.name = 'AuthorizeCommandMissingJwtOption';
            return Promise.reject(jwtError);
        }
        if ((_.isNil(context.flags.clientid) && !_.isNil(username) && !_.isNil(file))) {
            const missingClientIdError = new Error(this.messages.getMessage('authorizeCommandMissingClientId'));
            missingClientIdError.name = 'AuthorizeCommandMissingClientId';
            return Promise.reject(missingClientIdError);
        }
        return Promise.resolve(srcDevUtil.fixCliContext(context));
    }
    /**
     * main processing for the command. other commands should implement a similar prototype
     * @param context - the cli context (flags)
     * @param stdinValues - map of stdin values
     * @returns {Promise.<Error>}
     */
    execute(context, stdinValues) {
        this.isJwt = !_.isNil(context.jwtkeyfile);
        this.isSfdxUrl = !_.isNil(context.sfdxurlfile);
        const org = new Org(this.force, getType(context));
        org.alias = context.setalias;
        let promise;
        if (context.instanceurl) {
            // Always use the command line instance first;
            promise = Promise.resolve(context.instanceurl);
        }
        else {
            // Check the env var before local config
            const aggregator = new SfdxConfigAggregator();
            promise = aggregator.initialize().then(() => {
                const instance = aggregator.getInfo('instanceUrl');
                if (instance.isEnvVar()) {
                    return instance.val;
                }
                else {
                    return this.force.config.getAppConfigIfInWorkspace().sfdcLoginUrl ||
                        instance.val ||
                        urls.production;
                }
            });
        }
        if (this.isSfdxUrl) {
            promise = promise.then(() => _doSfdxUrlAuth(this.force, context, org));
        }
        else if (this.isJwt) {
            promise = promise.then(loginUrl => _doJwtAuth(this.force, context, org, loginUrl));
        }
        else {
            let clientSecret;
            // use default global connected app
            if (_.isNil(context.clientid)) {
                context.clientid = defaultConnectedAppInfo.clientId;
                clientSecret = defaultConnectedAppInfo.clientSecret;
            }
            else {
                clientSecret = _.isNil(stdinValues) ? null : stdinValues.get('secret');
            }
            const secretTrimmed = clientSecret === null ? null : clientSecret.trim();
            if (secretTrimmed !== null && secretTrimmed.length > 0) {
                promise = promise.then(loginUrl => doAuth(this.force, secretTrimmed, context, org, loginUrl)
                    .catch((err) => {
                    if (err.name === 'invalid_client') {
                        throw almError('invalid_client');
                    }
                    throw err;
                }));
            }
            else {
                return Promise.reject(almError('ClientSecretRequired'));
            }
        }
        if (context.setalias) {
            promise = promise.then(res => Alias.set(context.setalias, res.username).then(() => res));
        }
        return promise;
    }
    /**
     * returns a human readable message for a cli output
     * @param org - the data representing the authorized org
     * @returns {string}
     */
    getHumanSuccessMessage(org) {
        let successMsg = this.messages.getMessage('authorizeCommandSuccess', [org.username, org.orgId]);
        if (!this.isJwt && !this.isSfdxUrl) {
            successMsg += `\n${this.messages.getMessage('authorizeCommandCloseBrowser')}`;
        }
        return successMsg;
    }
}
module.exports = AuthCommand;

//# sourceMappingURL=authCommand.js.map
