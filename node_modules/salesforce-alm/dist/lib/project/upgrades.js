/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require('path');
const fs = require('fs');
const _ = require('lodash');
const Bluebird = require('bluebird');
Bluebird.promisifyAll(fs);
const messages = require(path.join('..', 'messages'))();
const error = require(path.join('..', 'almError'));
const utils = require(path.join('..', 'srcDevUtil'));
const consts = require(path.join('..', 'constants'));
const logger = require(path.join('..', 'logApi'));
const projectDirUtil = require(path.join('..', 'projectDir'));
// List all project update actions but not sure how to do dynamic imports with typescript
// since it needs the static checker. If this list grows to long, future us can worry about it.
//
// IMPORTANT NOTE: Order matters here. When adding a new project upgrade script, make sure you
// put it at the END of the array. 
const heads_down_project_1 = require("./upgrades/heads-down-project");
const org_def_conversion_1 = require("./upgrades/org-def-conversion");
const remove_use_decomposition_1 = require("./upgrades/remove-use-decomposition");
const actionsFns = [
    heads_down_project_1.default,
    org_def_conversion_1.default,
    remove_use_decomposition_1.default
];
/**
 * Special update action that fixes the break in what a "project" is. i.e. sfdx-workspace.json -> sfdx-project.json.
 * @param prompt
 */
function upgradeAndGetProjectPath(prompt) {
    return __awaiter(this, void 0, void 0, function* () {
        let projectPath;
        try {
            projectPath = projectDirUtil.getPath();
        }
        catch (err) {
            if (err.name === 'InvalidProjectWorkspace' && err.oldAndBustedPath) {
                const answer = (yield prompt(messages.getMessage('prompt_renameProjectFile', [`${err.oldAndBustedPath}/${consts.OLD_WORKSPACE_CONFIG_FILENAME}`, consts.WORKSPACE_CONFIG_FILENAME], 'projectUpgrade'))).toLowerCase();
                if (answer === 'yes' || answer === 'y') {
                    const oldFile = path.join(err.oldAndBustedPath, consts.OLD_WORKSPACE_CONFIG_FILENAME);
                    const newFile = path.join(err.oldAndBustedPath, consts.WORKSPACE_CONFIG_FILENAME);
                    return fs.renameAsync(oldFile, newFile).then(() => err.oldAndBustedPath);
                }
                else {
                    return Promise.resolve(null);
                }
            }
            return Promise.resolve(null);
        }
        return Promise.resolve(projectPath);
    });
}
const UPGRADE_STATE_FILE = 'upgrade-state.txt';
function readCurrentUpgradeVersion(projectPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const upgradeStateFile = path.join(projectPath, utils.getWorkspaceStateFolderName(), UPGRADE_STATE_FILE);
        return fs.readFileAsync(upgradeStateFile, 'utf8').then(data => parseInt(data)).catch(() => 0);
    });
}
function saveCurrentUpgradeVersion(projectPath, upgradeNumber) {
    return __awaiter(this, void 0, void 0, function* () {
        const upgradeStateFile = path.join(projectPath, utils.getWorkspaceStateFolderName(), UPGRADE_STATE_FILE);
        return fs.writeFileAsync(upgradeStateFile, upgradeNumber).catch(() => { });
    });
}
/**
 * Preform the upgrade using all upgrade actions that haven't been applied that need to be.
 * @param prompt
 */
function upgrades(prompt, force = false) {
    return __awaiter(this, void 0, void 0, function* () {
        let projectPath = yield upgradeAndGetProjectPath(prompt);
        if (_.isNil(projectPath)) {
            throw error({
                keyName: 'error_validProject',
                bundle: 'projectUpgrade'
            });
        }
        let upgradeNumber = 0;
        if (!force) {
            upgradeNumber = yield readCurrentUpgradeVersion(projectPath);
        }
        let actions = [];
        for (let actionFn; upgradeNumber < actionsFns.length; upgradeNumber++) {
            actionFn = actionsFns[upgradeNumber];
            actions.push(yield actionFn(projectPath, prompt));
        }
        actions = _.compact(actions);
        if (actions.length > 0) {
            logger.log();
            let answer = (yield prompt(messages.getMessage('prompt_queuedActions', [actions.length], 'projectUpgrade'))).toLowerCase();
            if (answer === 'list') {
                logger.log(_.map(actions, action => `\t - ${action.description}`).join('\n'));
                logger.log();
                answer = (yield prompt(messages.getMessage('prompt_continue', [], 'projectUpgrade'))).toLowerCase();
            }
            if (answer === 'yes' || answer === 'y') {
                for (let action of actions) {
                    const result = yield action.act(projectPath);
                    if (!_.isNil(result)) {
                        throw error('error_upgradeFailed', [result]);
                    }
                }
            }
            else {
                logger.log(messages.getMessage('skipping', [actions.length], 'projectUpgrade'));
                return Promise.resolve({});
            }
        }
        else {
            logger.log();
            logger.log(messages.getMessage('uptodate', [], 'projectUpgrade'));
        }
        return saveCurrentUpgradeVersion(projectPath, upgradeNumber)
            .then(() => {
            logger.log('\nProject successfully upgraded.\n');
        })
            .then(() => ({ actions: _.map(actions, 'description') }));
    });
}
exports.default = upgrades;
module.exports = upgrades;

//# sourceMappingURL=upgrades.js.map
