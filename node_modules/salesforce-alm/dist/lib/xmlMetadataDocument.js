/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require('path');
const util = require('util');
const DOMParser = require('xmldom').DOMParser;
const XMLSerializer = require('xmldom').XMLSerializer;
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
/**
 * Class used to hold an XML metadata document.
 * This uses a unitary XML representation and DOM content.
 */
class XmlMetadataDocument {
    constructor(metadataName) {
        if (!util.isNullOrUndefined(metadataName)) {
            this.setRepresentation(this.getOuterXml(metadataName));
        }
    }
    getRepresentation() {
        const pretty = true;
        return XmlMetadataDocument.serializeData(this.data, pretty);
    }
    getUnmodifiedRepresentation() {
        const pretty = false;
        return XmlMetadataDocument.serializeData(this.data, pretty);
    }
    setRepresentation(representation) {
        this.data = XmlMetadataDocument.parseRepresentation(representation);
    }
    getAnnotation() {
        return this.annotation;
    }
    setAnnotation(annotation) {
        this.annotation = annotation;
    }
    isEquivalent(doc) {
        return this.getRepresentation() === doc.getRepresentation();
    }
    isEquivalentTo(representation) {
        const rhs = new XmlMetadataDocument();
        rhs.setRepresentation(representation);
        return this.isEquivalent(rhs);
        ;
    }
    static getWhitespace(indent) {
        const tabSpaces = '    ';
        let whitespace = '\n';
        for (let i = 0; i < indent; ++i) {
            whitespace = whitespace + tabSpaces;
        }
        return whitespace;
    }
    static isEmptyElement(node) {
        return node.childNodes.length === 0;
    }
    static isSimpleElement(node) {
        const nodeTypeText = 3;
        const nodeTypeComment = 8;
        return node.childNodes.length === 1 && (node.firstChild.nodeType === nodeTypeText || node.firstChild.nodeType === nodeTypeComment);
    }
    static insertAfter(node, refNode) {
        if (refNode.nextSibling !== null) {
            refNode.parentNode.insertBefore(node, refNode.nextSibling);
        }
        else {
            refNode.parentNode.appendChild(node);
        }
    }
    static addWhitespaceNodes(document, node, indent) {
        if (node !== null) {
            const nodeTypeElement = 1;
            if (node.nodeType === nodeTypeElement) {
                if (!XmlMetadataDocument.isEmptyElement(node) && !XmlMetadataDocument.isSimpleElement(node)) {
                    node.insertBefore(document.createTextNode(XmlMetadataDocument.getWhitespace(indent + 1)), node.firstChild);
                }
                XmlMetadataDocument.insertAfter(document.createTextNode(XmlMetadataDocument.getWhitespace(node.nextSibling !== null ? indent : indent - 1)), node);
            }
            let child = node.firstChild;
            while (child !== null) {
                XmlMetadataDocument.addWhitespaceNodes(document, child, indent + 1);
                child = child.nextSibling;
            }
        }
    }
    static addWhitespace(document) {
        document.insertBefore(document.createTextNode(XmlMetadataDocument.getWhitespace(0)), document.documentElement);
        XmlMetadataDocument.addWhitespaceNodes(document, document.documentElement, 0);
    }
    static beautifyDocument(document) {
        srcDevUtil.stripWhitespace(document);
        XmlMetadataDocument.addWhitespace(document);
    }
    static serializeData(document, pretty) {
        if (pretty) {
            XmlMetadataDocument.beautifyDocument(document);
        }
        return new XMLSerializer().serializeToString(document);
    }
    static parseRepresentation(xml) {
        return new DOMParser().parseFromString(xml);
    }
    getOuterXml(metadataName) {
        const requiresExpicitXsiNsDeclaration = ['Report'];
        const xmlDecl = '<?xml version="1.0" encoding="UTF-8"?>';
        const xmlns = 'xmlns="http://soap.sforce.com/2006/04/metadata"';
        const xmlnsXsi = 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"';
        const rootElement = requiresExpicitXsiNsDeclaration.includes(metadataName) ? `<${metadataName} ${xmlns} ${xmlnsXsi} />` : `<${metadataName} ${xmlns}/>`;
        return `${xmlDecl}${rootElement}`;
    }
}
exports.XmlMetadataDocument = XmlMetadataDocument;

//# sourceMappingURL=xmlMetadataDocument.js.map
