/*
 * Copyright, 1999-2016, salesforce.com
 * All Rights Reserved
 * Company Confidential
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const path = require("path");
const almError = require("./almError");
const defaultConnectedApp = require(path.join(__dirname, 'defaultConnectedApp'));
const messages = require(path.join(__dirname, 'messages'))();
const BUNDLE_NAME = 'IndexErrorProcessor';
/**
 * Simple enum so the error processors can returns something that indicates the check
 * completed and no problems were found.
 */
var CheckStatus;
(function (CheckStatus) {
    CheckStatus[CheckStatus["OK"] = 0] = "OK";
})(CheckStatus = exports.CheckStatus || (exports.CheckStatus = {}));
/**
 * Returns an array of processors used to determine if an error can be further refined. Instead of
 * adding more error handing logic to index.js add it here, as it's much easier to unit test.
 * @param appConfig - the sfdx configuration
 * @param context - the cli context
 * @param err - a potentially course grained error thrown by the cli.
 */
function getProcessors(appConfig, context, err) {
    return [
        checkVersionMisMatchAsync(context, err),
        checkServer500(err),
        checkOauthAnd404(appConfig, context, err)
    ];
}
exports.getProcessors = getProcessors;
/**
 * Check is there is an invalid grant with oauth or a 404 response from the server.
 * @param appConfig - sfdx configuration
 * @param context - cli context
 * @param err - an error from the cli
 */
function checkOauthAnd404(appConfig, context, err) {
    if (context && err && (err.name === 'invalid_grant' || err.name === 'ERROR_HTTP_404')) {
        const notFoundMessage = messages.getMessage('notSpecified');
        let authConfig = {};
        if (context.org) {
            authConfig = context.org.authConfig;
        }
        else {
            lodash_1._.set(authConfig, 'username', context.flags.username);
            lodash_1._.set(authConfig, 'clientId', context.flags.clientid);
            lodash_1._.set(authConfig, 'privateKey', context.flags.jwtkeyfile);
            if (appConfig) {
                lodash_1._.set(authConfig, 'loginUrl', appConfig.sfdcLoginUrl);
            }
        }
        throw almError('oauthInvalidGrant', [
            // We know the 404 and invalid grant error always contain a name and message. 
            // The 404 error message is an html error page response.
            err.name.includes('404') ? err.name : `${err.name} - ${err.message}`,
            lodash_1._.isNil(authConfig.username) ? notFoundMessage : authConfig.username,
            lodash_1._.isNil(authConfig.clientId) || authConfig.clientId ===
                defaultConnectedApp.clientId ? notFoundMessage : authConfig.clientId,
            lodash_1._.isNil(authConfig.loginUrl) ? notFoundMessage : authConfig.loginUrl,
            lodash_1._.isNil(authConfig.privateKey) ? notFoundMessage : authConfig.privateKey
        ], 'oauthInvalidGrantAction');
    }
    return CheckStatus.OK;
}
exports.checkOauthAnd404 = checkOauthAnd404;
/**
 * Check that the servers api version is <= to the local config apiVersion.
 * @param context - the cli context that contains an org
 * @param _err  - an error thrown by the cli
 */
function checkVersionMisMatchAsync(context, _err) {
    return __awaiter(this, void 0, void 0, function* () {
        if (_err && _err.name === 'NOT_FOUND') {
            if (context && context.org) {
                const maxApiVersionForOrg = yield context.org.retrieveMaxApiVersion();
                const configVersion = context.org.force.config.getApiVersion();
                if (lodash_1._.toNumber(configVersion) > lodash_1._.toNumber(maxApiVersionForOrg.version)) {
                    throw almError({ bundle: BUNDLE_NAME, keyName: 'apiMisMatch' }, [configVersion, maxApiVersionForOrg.version], { keyName: 'apiMisMatchAction', bundle: BUNDLE_NAME });
                }
            }
        }
        return CheckStatus.OK;
    });
}
exports.checkVersionMisMatchAsync = checkVersionMisMatchAsync;
/**
 * Check to see if the throw error is a server 500. THis error is critical. If a database is being update in production
 * This error is throw after a rest style connection. It's imperative that customer's get a link to http://trust.salesforce.com
 * @param _err - an error to process thrown by the cli.
 */
function checkServer500(_err) {
    if (_err && _err.name === 'ERROR_HTTP_500' && lodash_1._.isEmpty(lodash_1._.trim(_err.message))) {
        throw almError({ bundle: BUNDLE_NAME, keyName: 'server500' }, null, { bundle: BUNDLE_NAME, keyName: 'server500Action' });
    }
    return CheckStatus.OK;
}
exports.checkServer500 = checkServer500;

//# sourceMappingURL=indexErrorProcessor.js.map
