/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require('path');
const fs = require('fs');
const _ = require('lodash');
const Bluebird = require('bluebird');
Bluebird.promisifyAll(fs);
const projectDirUtil = require(path.join('..', '..', 'projectDir'));
const utils = require(path.join('..', '..', 'srcDevUtil'));
const consts = require(path.join('..', '..', 'constants'));
const messages = require(path.join('..', '..', 'messages'))();
const UpgradeAction_1 = require("./UpgradeAction");
const heads_down_project_1 = require("./heads-down-project");
const heads_down_project_2 = require("./heads-down-project");
const DEFAULT = path.join('config', '*def.json');
function default_1(projectDir, prompt) {
    return __awaiter(this, void 0, void 0, function* () {
        let answer = yield prompt(messages.getMessage('prompt_orgDefPattern', [DEFAULT], 'projectUpgrade'));
        if (answer === 'SKIP') {
            // No action
            return Promise.resolve(null);
        }
        if (answer === 'D' || answer === 'DEFAULT') {
            answer = DEFAULT;
        }
        answer = answer.replace(/[.?+^$[\]\\(){}|-]/g, "\\$&");
        answer = answer.replace('*', '.*');
        const fileRegex = new RegExp(`${answer}$`);
        // Find file names that match the regex
        const matchedFiles = [];
        utils.actOn(projectDir, (file) => {
            if (file.match(fileRegex)) {
                matchedFiles.push(file);
            }
        });
        // Check matched files for heads up
        const files = [];
        for (let matchedFile of matchedFiles) {
            // Don't store this so we don't put a bunch of files in memory. The write is going to happen at a later time.
            const contents = yield fs.readFileAsync(matchedFile, 'utf8');
            // Check headsUp, company, country, and orgPreference format.
            const needsAction = contents.match(heads_down_project_1.HEADS_UP) ||
                contents.match(/"[cC]ompany"\s*:/) ||
                contents.match(/"[eE]mail"\s*:/) ||
                contents.match(/"[oO]rgPreferences"\s*:\s*\{\s*"(?!(enabled|disabled))/) ||
                contents.match(/"[lL]astName"\s*:/);
            if (needsAction) {
                files.push(matchedFile);
            }
        }
        if (files.length > 0) {
            return Promise.resolve(new UpgradeAction_1.default(messages.getMessage('action_orgDefConversion', [files.length], 'projectUpgrade'), () => __awaiter(this, void 0, void 0, function* () {
                // Not doing this in parrellel right now, but we could
                for (let file of files) {
                    let json = yield utils.readJSON(file);
                    // Org preferences need to stay in upper, so  move to array form first
                    const orgPreferences = json.orgPreferences || json.OrgPreferences;
                    if (_.isPlainObject(orgPreferences) && !orgPreferences.enabled && !orgPreferences.disabled) {
                        const enabled = _.map(orgPreferences, (enabled, prefName) => !!enabled ? prefName : null).filter(_.isString);
                        const disabled = _.map(orgPreferences, (enabled, prefName) => !enabled ? prefName : null).filter(_.isString);
                        delete json.OrgPreferences;
                        json.orgPreferences = { enabled, disabled };
                    }
                    const contents = JSON.stringify(json).replace(heads_down_project_1.HEADS_UP, heads_down_project_2.REPLACE_FN);
                    json = yield utils.parseJSON(contents, file);
                    if (json.company) {
                        json.orgName = json.company;
                        delete json.company;
                    }
                    if (json.email) {
                        json.adminEmail = json.email;
                        delete json.email;
                    }
                    if (json.lastName) {
                        delete json.lastName;
                    }
                    yield fs.writeFileAsync(file, JSON.stringify(json, null, 2));
                }
                return Promise.resolve(null);
            })));
        }
        return Promise.resolve(null);
    });
}
exports.default = default_1;
;

//# sourceMappingURL=org-def-conversion.js.map
