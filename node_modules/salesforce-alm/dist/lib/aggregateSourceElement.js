/*
 * Copyright (c) 2017, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const folderPerSubtypeWorkspaceDecomposition_1 = require("./folderPerSubtypeWorkspaceDecomposition");
const fs = require('fs-extra');
const path = require('path');
const _ = require('lodash');
const srcDevUtil = require('./srcDevUtil');
const sourceState = require('./sourceState');
const messages = require(path.join(__dirname, 'messages'))();
const MetadataRegistry = require("./metadataRegistry");
const decompositionStrategyFactory_1 = require("./decompositionStrategyFactory");
const workspaceElement_1 = require("./workspaceElement");
const typeDefUtil_1 = require("./typeDefUtil");
const staticResource_1 = require("./staticResource");
/**
 * Class used to manage top-level metadata
 * Examples of top-level metadata types include: ApexClass, CustomObject, StaticResource, etc.
 *
 * For compound metadata requiring de/recomposition, this facade is the point of entry for
 * decomposition/re-composition from other code. No client code should reference any other
 * internal implementation classes. If this class proves inadequate for future needs then it should
 * be extended and the internal implementation classes modified to support the new requirements.
 *
 * This class is agnostic wrt how the decomposition of the source metadata file is
 * performed, including the nature of the aggregated and decomposed files,  and also
 * how the decomposed files are represented in the workspace. These decisions are
 * delegated to the strategies configured in the metadata registry for the type.
 */
class AggregateSourceElement {
    /**
     * @param aggregateTypeDef - this is the type def for the top-level parent metadata - e.g. ApexClass, CustomObject, etc.
     * @param metadataRegistry
     */
    constructor(aggregateTypeDef, aggregateFullName, aggregateMetadataFilePath, metadataRegistry) {
        /**
         *
         * @param sourcePath Source workspace filepath
         * @param mdapiPath Temporary mdapiDir filepath
         * @returns {{sourcePath: *, mdapiPath: *}}
         * @private
         */
        this.createTranslation = function (sourcePath, mdapiPath) {
            return { sourcePath, mdapiPath };
        };
        this.workspaceVersion = null; // fill this in when the workspace version is known
        this.metadataRegistry = metadataRegistry; // my hope is to be able to get rid of this when typeDefs become first class
        this.typeDef = aggregateTypeDef;
        this.aggregateFullName = aggregateFullName;
        this.metadataFilePath = aggregateMetadataFilePath;
        this.decompStrategy = decompositionStrategyFactory_1.DecompositionStrategyFactory.newDecompositionStrategy(this.typeDef.decompositionConfig);
        this.workspaceStrategy = decompositionStrategyFactory_1.DecompositionStrategyFactory.newDecompositionWorkspaceStrategy(this.typeDef.decompositionConfig);
        this.commitStrategy = decompositionStrategyFactory_1.DecompositionStrategyFactory.newDecompositionCommitStrategy(this.typeDef.decompositionConfig);
        this.contentStrategy = decompositionStrategyFactory_1.DecompositionStrategyFactory.newContentStrategy(this.typeDef, this.metadataRegistry, this.workspaceVersion);
        this.workspaceElements = [];
        this.pendingDeletedWorkspaceElements = [];
        this.deleted = null;
        this.renamed = false;
    }
    static getKeyFromMetadataNameAndFullName(aggregateMetadataName, aggregateFullName) {
        return `${aggregateMetadataName}__${aggregateFullName}`;
    }
    getKey() {
        return AggregateSourceElement.getKeyFromMetadataNameAndFullName(this.typeDef.metadataName, this.getAggregateFullName());
    }
    /**
     * Gets the metadata workspace path that would be in use if this type were not transformed.
     * The locations of associated decomposed/non-decomposed content and metadata  files can be inferred from this name.
     * @returns {string}
     */
    getMetadataFilePath() {
        return this.metadataFilePath;
    }
    getAggregateFullName() {
        return this.aggregateFullName;
    }
    /**
     * Returns all paths to workspace source files matching the given metadata type and fullName
     * @param typeDefForPath
     * @param fullNameForPath
     * @returns {string[]}
     */
    getWorkspacePathsForTypeAndFullName(typeDefForPath, fullNameForPath) {
        // get content file paths
        const allContentPaths = this.getContentPaths(this.getMetadataFilePath());
        const contentPathsForFullName = allContentPaths.filter(contentPath => {
            const fullName = typeDefUtil_1.TypeDefUtil.getFullNameForFilePath(this.metadataRegistry, typeDefForPath, contentPath);
            return fullName === fullNameForPath;
        });
        // get metadata file paths
        const allDecomposedPaths = this.getMetadataPaths(this.getMetadataFilePath());
        const metadataPathsForFullName = allDecomposedPaths.filter(decomposedPath => {
            const decomposedTypeDef = this.metadataRegistry.getTypeDefinitionByFileName(decomposedPath, true);
            if (decomposedTypeDef.metadataName === typeDefForPath.metadataName) {
                const decomposedFullName = typeDefUtil_1.TypeDefUtil.getFullNameForFilePath(this.metadataRegistry, decomposedTypeDef, decomposedPath);
                return fullNameForPath === decomposedFullName;
            }
            return false;
        });
        return contentPathsForFullName.concat(metadataPathsForFullName);
    }
    addWorkspaceElement(workspaceElement) {
        this.workspaceElements.push(workspaceElement);
    }
    /**
     * Returns the collection of workspace elements associated with this aggregate source element
     * @returns {WorkspaceElement[]}
     */
    getWorkspaceElements() {
        return this.workspaceElements;
    }
    /**
     * Adds the given workspace element to a collection to be processed during commit
     * @param deletedWorkspaceElement
     */
    addPendingDeletedWorkspaceElement(deletedWorkspaceElement) {
        this.pendingDeletedWorkspaceElements.push(deletedWorkspaceElement);
    }
    /**
     * Returns the collection of deleted workspace elements associated with this aggregate source element
     * @returns {WorkspaceElement[]}
     */
    getPendingDeletedWorkspaceElements() {
        return this.pendingDeletedWorkspaceElements;
    }
    isDeleted() {
        if (!_.isNil(this.deleted)) {
            return this.deleted;
        }
        else {
            return this.isAggregateSourceElementDeleted();
        }
    }
    isRenamed() {
        return this.renamed;
    }
    /**
     * If the workspace is in an inconsistent state, where a metadata file was deleted but not the content files,
     * or the aura bundle metadata file was deleted but not the whole bundle, then throw an error
     * @param workspaceElement
     */
    validateIfDeletedWorkspaceElement(workspaceElement) {
        if (workspaceElement.getState() === sourceState.DELETED) {
            const contentPaths = this.typeDef.hasContent ? this.getContentPaths(this.getMetadataFilePath()) : [];
            // If the metadata file was deleted and not the content file, throw an error
            // Or if the container path for the fine-grained item was deleted but other decomposed items exist, throw an error
            if (workspaceElement.getSourcePath() === this.getContainerPath()) {
                const allDecomposedPaths = this.getMetadataPaths(this.getMetadataFilePath());
                if (this.typeDef.hasContent && contentPaths.length !== 0 || (allDecomposedPaths.length !== 0)) {
                    const err = new Error();
                    err.message = messages.getMessage('MissingMetadataFile', workspaceElement.getSourcePath());
                    err.name = 'Missing Metadata File';
                    throw err;
                }
            }
            // For Aura Bundles, if we are deleting the metadata file, but there are still other aura definitions present, we should throw an error
            if (this.typeDef.metadataName == this.metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
                const auraTypeDef = this.metadataRegistry.getLightningDefByFileName(workspaceElement.getSourcePath());
                if (auraTypeDef && auraTypeDef.hasMetadata) {
                    const otherAuraFilesExist = !_.isNil(contentPaths.find(contentPath => !contentPath.endsWith(auraTypeDef.fileSuffix)));
                    if (otherAuraFilesExist) {
                        const err = new Error();
                        err.message = messages.getMessage('MissingContentFile', workspaceElement.getSourcePath());
                        err.name = 'Missing Content File';
                        throw err;
                    }
                }
            }
        }
    }
    getContainerPath() {
        return this.workspaceStrategy.getContainerPath(this.getMetadataFilePath(), this.typeDef.ext);
    }
    isAggregateSourceElementDeleted() {
        let isDeleted = false;
        this.getWorkspaceElements().forEach(workspaceElement => {
            this.validateIfDeletedWorkspaceElement(workspaceElement);
            if (workspaceElement.getState() === sourceState.DELETED) {
                if (workspaceElement.getSourcePath() === this.getContainerPath()) {
                    isDeleted = true;
                }
                if (this.typeDef.hasContent) {
                    // For metadata that has content files and we are deleting the content file, but the metadata file was not deleted yet,
                    // this was likely intentional, so delete that file as well
                    if (workspaceElement.getSourcePath().endsWith(this.typeDef.ext)) {
                        if (srcDevUtil.pathExistsSync(this.getMetadataFilePath())) {
                            this.markForDelete();
                        }
                    }
                    // For files that don't end in a known metadata path name (such as documents and static resource files), and this is not a rename,
                    // then also delete the metadata files
                    if (!workspaceElement.getSourcePath().endsWith(MetadataRegistry.getMetadataFileExt())) {
                        if (this.typeDef.metadataName === this.metadataRegistry.typeDefs.Document.metadataName || this.typeDef.metadataName === this.metadataRegistry.typeDefs.StaticResource.metadataName) {
                            const resourceContentFilePath = typeDefUtil_1.TypeDefUtil.getContentPathWithNonStdExtFromMetadataPath(this.metadataRegistry, this.typeDef, this.getMetadataFilePath());
                            if (resourceContentFilePath) {
                                this.renamed = true;
                            }
                            else {
                                if (srcDevUtil.pathExistsSync(this.getMetadataFilePath())) {
                                    this.markForDelete();
                                }
                            }
                        }
                    }
                }
            }
        });
        return isDeleted;
    }
    /**
     * Flags this aggregate source element as deleted and marks all of its associated workspace elements as deleted
     */
    markForDelete() {
        this.deleted = true;
        const metadataPathsToDelete = this.getMetadataPaths(this.getMetadataFilePath());
        const contentPathsToDelete = this.getContentPaths(this.getMetadataFilePath());
        const allPaths = metadataPathsToDelete.concat(contentPathsToDelete);
        allPaths.forEach(deletedPath => {
            const pathTypeDef = this.metadataRegistry.getTypeDefinitionByFileName(deletedPath, true);
            const fullNameForPath = typeDefUtil_1.TypeDefUtil.getFullNameForFilePath(this.metadataRegistry, pathTypeDef, deletedPath);
            const deletedWorkspaceElement = new workspaceElement_1.WorkspaceElement(pathTypeDef, fullNameForPath, deletedPath, sourceState.DELETED, false);
            this.addPendingDeletedWorkspaceElement(deletedWorkspaceElement);
        });
    }
    /**
     * Gets the list of existing decomposed and non-decomposed metadata files for the given source metadata entity.
     *
     * @param metadataFilePath the workspace path that would be in use if this type were not transformed.
     * The locations of the actual decomposed files can be inferred from this name. This is a proxy for all
     * of decomposed files.
     * @returns {string[]} the list of existing decomposed files for the given source metadata entity
     */
    getMetadataPaths(metadataFilePath) {
        const paths = [];
        const containerPath = this.workspaceStrategy.getContainerPath(metadataFilePath, this.typeDef.ext);
        if (!_.isNil(containerPath) && srcDevUtil.pathExistsSync(containerPath)) {
            paths.push(containerPath);
        }
        const decompositionPaths = this.workspaceStrategy.findDecomposedPaths(metadataFilePath, this.typeDef.ext);
        for (const decomposedSubtypeConfig of decompositionPaths.keys()) {
            for (const decompositionPath of decompositionPaths.get(decomposedSubtypeConfig)) {
                paths.push(decompositionPath);
            }
        }
        return paths;
    }
    /**
     * Gets all of the workspace paths to composed and nondecomposed content files associated with this aggregateSourceElement
     * @param metadataFilePath
     * @returns {any}
     */
    getContentPaths(metadataFilePath) {
        if (this.typeDef.hasContent) {
            return this.contentStrategy.getContentPaths(metadataFilePath);
        }
        return [];
    }
    /**
     * Commits changes to the workspace
     * @param manifest
     * @param unsupportedMimeTypes - the list of non-whitelisted static resource mime types
     * @returns {Array[]}
     */
    commit(manifest, unsupportedMimeTypes) {
        let newPaths = [];
        let updatedPaths = [];
        let deletedPaths = [];
        let dupPaths = [];
        // commit deleted source to workspace
        this.pendingDeletedWorkspaceElements.forEach(deletedWorkspaceElement => {
            srcDevUtil.deleteIfExistsSync(deletedWorkspaceElement.getSourcePath());
            deletedPaths.push(deletedWorkspaceElement.getSourcePath());
        });
        // commit metadata to the workspace
        if (!_.isNil(this.retrievedMetadataPath)) {
            const [newMetaPaths, updatedMetaPaths, deletedMetaPaths, dupMetaPaths] = this.decomposeMetadata(this.retrievedMetadataPath, this.getMetadataFilePath(), manifest);
            newPaths = newPaths.concat(newMetaPaths);
            updatedPaths = updatedPaths.concat(updatedMetaPaths);
            deletedPaths = deletedPaths.concat(deletedMetaPaths);
            dupPaths = dupPaths.concat(dupMetaPaths);
        }
        // commit content to the workspace
        if (this.typeDef.hasContent && !_.isNil(this.retrievedContentPaths)) {
            const [newContentPaths, updatedContentPaths, deletedContentPaths, dupContentPaths] = this.contentStrategy.saveContent(this.getMetadataFilePath(), this.retrievedContentPaths, this.retrievedMetadataPath, this.isDuplicate, unsupportedMimeTypes);
            newPaths = newPaths.concat(newContentPaths);
            updatedPaths = updatedPaths.concat(updatedContentPaths);
            deletedPaths = deletedPaths.concat(deletedContentPaths);
            dupPaths = dupPaths.concat(dupContentPaths);
        }
        // if we are processing a folder type and the folder does not exist, create it in the workspace
        if (this.typeDef.metadataName.endsWith('Folder')) {
            const folderExtensionIndex = this.getMetadataFilePath().indexOf(`.${this.typeDef.ext}${MetadataRegistry.getMetadataFileExt()}`);
            const folderPath = this.getMetadataFilePath().substring(0, folderExtensionIndex);
            if (!srcDevUtil.pathExistsSync(folderPath)) {
                srcDevUtil.ensureDirectoryExistsSync(folderPath);
                this.addWorkspaceElement(new workspaceElement_1.WorkspaceElement(this.typeDef, this.aggregateFullName, folderPath, sourceState.NEW, false));
            }
        }
        // associate commited source to sourceElement
        this.addCorrespondingWorkspaceElements(newPaths, sourceState.NEW);
        this.addCorrespondingWorkspaceElements(updatedPaths, sourceState.CHANGED);
        this.addCorrespondingWorkspaceElements(deletedPaths, sourceState.DELETED);
        this.addCorrespondingWorkspaceElements(dupPaths, sourceState.DUP);
        return [newPaths, updatedPaths, deletedPaths];
    }
    addCorrespondingWorkspaceElements(filePaths, state) {
        filePaths.forEach((filePath) => {
            let tempFilePath = filePath;
            if (tempFilePath.endsWith('.dup')) {
                // if we are dealing with a duplicate file do all the calculations as if it wasn't a dup
                tempFilePath = tempFilePath.substring(0, tempFilePath.length - 4);
            }
            const workspaceElementTypeDef = this.metadataRegistry.getTypeDefinitionByFileName(tempFilePath, true);
            let workspaceElementFullName = typeDefUtil_1.TypeDefUtil.getFullNameForFilePath(this.metadataRegistry, workspaceElementTypeDef, tempFilePath);
            const isStandardMember = workspaceElementTypeDef.hasStandardMembers && !workspaceElementFullName.includes('__');
            const workspaceElement = new workspaceElement_1.WorkspaceElement(workspaceElementTypeDef, workspaceElementFullName, filePath, state, isStandardMember);
            this.addWorkspaceElement(workspaceElement);
        });
    }
    checkForDuplicates() {
        let decomposedFolder;
        // temporary fix to address W-4374943. Refactor in version 42 will remove the need for checking workspaceStrategy this way
        if (this.typeDef.decompositionConfig.workspaceStrategy === 'folderPerSubtype') {
            const folderPerSubtypeWorkspaceDecomposition = new folderPerSubtypeWorkspaceDecomposition_1.FolderPerSubtypeWorkspaceDecomposition(this.typeDef.decompositionConfig);
            decomposedFolder = folderPerSubtypeWorkspaceDecomposition.getDecomposedSourceDirFromMetadataFile(this.metadataFilePath, this.typeDef.ext);
        }
        if (fs.existsSync(this.metadataFilePath) || fs.existsSync(decomposedFolder)) {
            this.isDuplicate = true;
        }
    }
    /**
     * Gets the translation objects for copying source from the workspace to the metadata API formatted directory
     * @param mdDir
     * @param tmpDir
     * @param unsupportedMimeTypes - the list of non-whitelisted static resource mime types
     * @returns {Array}
     */
    getFilePathTranslations(mdDir, tmpDir, unsupportedMimeTypes) {
        const filePathTranslations = [];
        const workspacePathToSourceDir = path.dirname(this.getMetadataFilePath());
        const mdapiSourceDir = typeDefUtil_1.TypeDefUtil.getPathToMdapiSourceDir(this.metadataRegistry, this.typeDef, this.getAggregateFullName(), mdDir);
        // For Aura components, map the parent directory of the source element
        if (this.typeDef.metadataName === this.metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
            const srcDirToMdapiDir = this.createTranslation(workspacePathToSourceDir, mdapiSourceDir);
            filePathTranslations.push(srcDirToMdapiDir);
            return filePathTranslations;
        }
        // get the file path translation for content files
        if (this.typeDef.hasContent) {
            let workspaceContentFilePath = this.getMetadataFilePath().replace(MetadataRegistry.getMetadataFileExt(), '');
            if (this.typeDef.metadataName === this.metadataRegistry.typeDefs.Document.metadataName) {
                workspaceContentFilePath = typeDefUtil_1.TypeDefUtil.getContentPathWithNonStdExtFromMetadataPath(this.metadataRegistry, this.typeDef, this.getMetadataFilePath());
            }
            const workspaceContentFileName = path.basename(workspaceContentFilePath);
            let contentFilePathTranslation;
            if (this.typeDef.metadataName === this.metadataRegistry.typeDefs.StaticResource.metadataName) {
                const sr = new staticResource_1.StaticResource(this.getMetadataFilePath(), this.metadataRegistry.typeDefs.StaticResource, this.workspaceVersion, undefined, unsupportedMimeTypes);
                contentFilePathTranslation = this.createTranslation(sr.getResource(this.metadataRegistry), path.join(mdapiSourceDir, `${path.basename(workspaceContentFileName, path.extname(workspaceContentFileName))}.${this.metadataRegistry.typeDefs.StaticResource.ext}`));
            }
            else {
                contentFilePathTranslation = this.createTranslation(workspaceContentFilePath, path.join(mdapiSourceDir, workspaceContentFileName));
            }
            filePathTranslations.push(contentFilePathTranslation);
        }
        // get the file path translation for metadata files
        const composedPath = this.composeMetadata(this.getMetadataFilePath(), tmpDir);
        const workspacePathToMetadata = !_.isNil(composedPath) ? composedPath : this.getMetadataFilePath();
        const mdapiFormattedMetadataFileName = typeDefUtil_1.TypeDefUtil.getMdapiFormattedMetadataFileName(this.metadataRegistry, this.typeDef, this.getMetadataFilePath());
        const metadataFilePathTranslation = this.createTranslation(workspacePathToMetadata, path.join(mdapiSourceDir, mdapiFormattedMetadataFileName));
        filePathTranslations.push(metadataFilePathTranslation);
        return filePathTranslations;
    }
    /**
     * Composes a single metadata file from one or more files each representing a part of the whole.
     * It is important to understand that this does <b>not</b> have to be an mdapi xml file, even though
     * it usually will be. That determination will be driven by a type-specific configuration.
     *
     * @param metadataFilePath the workspace path that would be in use if this type were not transformed.
     * The locations of the actual decomposed files can be inferred from this name. This is a proxy for all
     * of decomposed files.
     * @param tmpDir temporary directory to hold the composed metadata file outside of the workspace.
     * @returns {string} the path of composed metadata file.
     */
    composeMetadata(metadataFilePath, tmpDir) {
        let container;
        const containerPath = this.workspaceStrategy.getContainerPath(metadataFilePath, this.typeDef.ext);
        if (!_.isNil(containerPath) && this.includeDecomposition(containerPath)) {
            if (!srcDevUtil.pathExistsSync(containerPath)) {
                const err = new Error();
                const metaExtIndex = containerPath.indexOf(MetadataRegistry.getMetadataFileExt());
                const pathWithoutMetaExt = containerPath.substring(0, metaExtIndex);
                if (srcDevUtil.pathExistsSync(pathWithoutMetaExt) && !this.typeDef.hasContent) {
                    err.message = messages.getMessage('MissingMetadataExtension', [pathWithoutMetaExt, containerPath]);
                    err.name = 'Expected Metadata Extension';
                }
                else {
                    err.message = messages.getMessage('MissingMetadataFileWithMetaExt', containerPath);
                    err.name = 'Missing Metadata File';
                }
                throw err;
            }
            else {
                container = this.decompStrategy.newContainerDocument(this.typeDef.metadataName);
                container.setRepresentation(fs.readFileSync(containerPath, 'utf8'));
            }
        }
        const decompositions = new Map();
        const decompositionPaths = this.workspaceStrategy.findDecomposedPaths(metadataFilePath, this.typeDef.ext);
        for (const decomposedSubtypeConfig of decompositionPaths.keys()) {
            for (const decompositionPath of decompositionPaths.get(decomposedSubtypeConfig)) {
                if (this.includeDecomposition(decompositionPath)) {
                    const decomposition = this.decompStrategy.newDecompositionDocument(decomposedSubtypeConfig.metadataName);
                    decomposition.setRepresentation(fs.readFileSync(decompositionPath, 'utf8'));
                    if (_.isNil(decompositions.get(decomposedSubtypeConfig))) {
                        decompositions.set(decomposedSubtypeConfig, []);
                    }
                    decompositions.get(decomposedSubtypeConfig).push(decomposition);
                }
            }
        }
        const composed = this.decompStrategy.compose(container, decompositions);
        const composedPath = this.getComposedFilePath(tmpDir);
        srcDevUtil.ensureDirectoryExistsSync(path.dirname(composedPath));
        fs.writeFileSync(composedPath, composed.getRepresentation());
        return composedPath;
    }
    includeDecomposition(decompositionFilePath) {
        if (this.typeDef.decompositionConfig.useSparseComposition) {
            const candidateElement = this.workspaceElements.find((workspaceElement) => workspaceElement.getSourcePath() === decompositionFilePath &&
                (workspaceElement.getState() == sourceState.NEW || workspaceElement.getState() == sourceState.CHANGED));
            return !_.isNil(candidateElement);
        }
        else {
            return true;
        }
    }
    /**
     *
     * @param sourceFilePath an aggregated file, typically an mdapi xml file
     * @param metadataFilePath the workspace path that would be in use if this type were not transformed.
     * The locations of the actual decomposed files can be inferred from this name. This is a proxy for all
     * of decomposed files.
     * @returns {[string[], string[], string[]]} a triplet containing a list of new, updated, and deleted workspace paths for the decomposed files.
     */
    decomposeMetadata(sourceFilePath, metadataFilePath, manifest) {
        const composed = this.decompStrategy.newComposedDocument(this.typeDef.decompositionConfig.metadataName);
        composed.setRepresentation(fs.readFileSync(sourceFilePath, 'utf8'));
        let container;
        let decompositions;
        [container, decompositions] = this.decompStrategy.decompose(composed, typeDefUtil_1.TypeDefUtil.getAggregateFullNameForFilePath(this.metadataRegistry, this.typeDef, this.getMetadataFilePath()), manifest);
        const documents = this.getPaths(metadataFilePath, container, decompositions);
        const existingPaths = this.getMetadataPaths(metadataFilePath);
        return this.commitStrategy.commit(documents, existingPaths, this.isDuplicate);
    }
    getComposedFilePath(tmpDir) {
        return typeDefUtil_1.TypeDefUtil.getDefaultAggregateMetadataPath(this.getAggregateFullName(), this.typeDef, tmpDir, this.metadataRegistry, []);
    }
    getPaths(metadataFilePath, container, decompositions) {
        const paths = new Map();
        const containerPath = this.workspaceStrategy.getContainerPath(metadataFilePath, this.typeDef.ext);
        if (!_.isNil(containerPath)) {
            if (!_.isNil(container)) {
                paths.set(containerPath, container);
            }
        }
        for (const decomposedSubtypeConfig of decompositions.keys()) {
            for (const decomposition of decompositions.get(decomposedSubtypeConfig)) {
                const sourceDir = this.workspaceStrategy.getDecomposedSubtypeDirFromMetadataFile(metadataFilePath, this.typeDef.ext, decomposedSubtypeConfig);
                const annotation = decomposition.getAnnotation();
                const fileName = this.workspaceStrategy.getDecomposedFileName(annotation, decomposedSubtypeConfig);
                const decomposedPath = path.join(sourceDir, fileName);
                paths.set(decomposedPath, decomposition);
            }
        }
        return paths;
    }
}
exports.AggregateSourceElement = AggregateSourceElement;

//# sourceMappingURL=aggregateSourceElement.js.map
