/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
// Node
const path = require('path');
const Promise = require('bluebird');
const util = require('util');
// Local
const MdapiPushApi = require(path.join(__dirname, 'mdapiPushApi'));
const almError = require(path.join(__dirname, 'almError'));
const messages = require(path.join(__dirname, 'messages'))();
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil.js'));
const syncCommandHelper = require(path.join(__dirname, 'syncCommandHelper'));
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const consts = require(path.join(__dirname, 'constants'));
const logger = require(path.join(__dirname, 'logApi'));
class MdapiPushCommand {
    constructor() {
        this.logger = logger.child('source:push');
    }
    getPreExecuteMessage({ orgId, username }) {
        return messages.getMessage('pushCommandCliPreExecute', [orgId, username]);
    }
    execute(context) {
        const rows = [];
        const projectPath = this.orgApi.config.getProjectPath();
        return MetadataRegistry.initializeMetadataTypeInfos(this.orgApi)
            .then(() => {
            const mdapiPush = new MdapiPushApi(this.orgApi);
            context.unsupportedMimeTypes = []; // for logging unsupported static resource mime types
            return mdapiPush.doPush(context);
        })
            .catch(e => {
            if (e.name === 'SourceConflict') {
                const error = almError('sourceConflictDetected');
                e.sourceConflictElements.forEach(sourceElement => syncCommandHelper.createConflictRows(rows, sourceElement, projectPath));
                error.columns = syncCommandHelper.getColumnMetaInfo(messages);
                error.result = rows;
                this.logger.error(messages.getMessage('pushCommandConflictMsg'));
                throw error;
            }
            else if (e.name === 'DeployFailed') {
                e.failures.forEach((failure) => syncCommandHelper.createDeployFailureRow(rows, failure, projectPath));
                const error = almError('sourcePushFailed');
                error.columns = this._getErrorColumnData();
                error.result = rows;
                throw error;
            }
            else if (e.name === 'PollingTimeout') {
                throw almError('sourcePushTimeout', context.wait);
            }
            else {
                throw e;
            }
        })
            .then(result => result.outboundFiles.forEach((sourceElement) => syncCommandHelper.createDisplayRows(rows, sourceElement, projectPath)))
            .then(() => this.logger.styledHeader(this.logger.color.blue(messages.getMessage('pushCommandHumanSuccess'))))
            .then(() => {
            srcDevUtil.logUnsupportedMimeTypeError(context.unsupportedMimeTypes, this.logger, this.orgApi.force);
        })
            .then(() => (context.json ? { pushedSource: rows } : rows));
    }
    validate(context) {
        this.orgApi = context.org;
        this.verbose = context.flags.verbose;
        this.json = context.flags.json;
        const fixedContext = srcDevUtil.fixCliContext(context);
        if (!util.isNullOrUndefined(fixedContext.wait)) {
            if (srcDevUtil.isInt(fixedContext.wait)) {
                fixedContext.wait = parseInt(fixedContext.wait);
                if (fixedContext.wait < consts.MIN_SRC_WAIT_MINUTES) {
                    return Promise.reject(almError('mdapiCliInvalidNumericParam', 'wait'));
                }
            }
            else {
                return Promise.reject(almError('mdapiCliInvalidNumericParam', 'wait'));
            }
        }
        return Promise.resolve(fixedContext);
    }
    /**
     * this indicated to index.js this command should produce tabular output.
     * @returns {*[]}
     */
    getColumnData() {
        return syncCommandHelper.getColumnMetaInfo(messages);
    }
    _getErrorColumnData() {
        if (this.verbose || this.json) {
            return [
                { key: 'fullName', label: messages.getMessage('fullNameTableColumn') },
                { key: 'type', label: messages.getMessage('typeTableColumn') },
                { key: 'filePath', label: messages.getMessage('workspacePathTableColumn') },
                { key: 'error', label: messages.getMessage('errorColumn', null, 'source_push') },
                { key: 'lineNumber', label: messages.getMessage('lineNumberColumn', null, 'source_push') },
                { key: 'columnNumber', label: messages.getMessage('columnNumberColumn', null, 'source_push') }
            ];
        }
        else {
            return [
                { key: 'filePath', label: messages.getMessage('workspacePathTableColumn') },
                { key: 'error', label: messages.getMessage('errorColumn', null, 'source_push') }
            ];
        }
    }
}
module.exports = MdapiPushCommand;

//# sourceMappingURL=mdapiPushCommand.js.map
