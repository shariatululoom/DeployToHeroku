/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
const path = require('path');
const Promise = require('bluebird');
const util = require('util');
const _ = require('lodash');
// Local
const logApi = require(path.join(__dirname, '..', 'logApi'));
let logger;
const messages = require(path.join(__dirname, '..', 'messages'))();
const package2Utils = require(path.join(__dirname, '..', 'package2', 'package2Utils'));
const DEFAULT_POLL_INTERVAL_IN_MILLISECONDS = 5000;
const DEFAULT_MAX_RETRIES = 0;
const RETRY_MINUTES_IN_MILLIS = 60000;
const ERROR_QUERY = 'SELECT Message FROM PackageVersionUninstallRequestError WHERE ParentRequest.Id = \'%s\' ORDER BY Message';
/**
 * This uninstalls a package in to a target org.
 * @param context: heroku context
 * @returns {*|promise}
 */
class PackageUninstallCommand {
    constructor(pollIntervalInMillis) {
        this.pollIntervalInMillis = _.isNil(pollIntervalInMillis) ? DEFAULT_POLL_INTERVAL_IN_MILLISECONDS : pollIntervalInMillis;
        this.maxRetries = DEFAULT_MAX_RETRIES;
        this.id = null;
        logger = logApi.child('force:package:uninstall');
    }
    poll(context, id, retries) {
        this.org = context.org;
        this.force = this.org.force;
        const username = context.flags.targetusername;
        const orgApi = context.org;
        if (username) {
            orgApi.setName(username);
        }
        return orgApi.force.toolingRetrieve(orgApi, 'SubscriberPackageVersionUninstallRequest', id)
            .then((request) => {
            switch (request.Status) {
                case 'Success': {
                    return request;
                }
                case 'Error': {
                    const err = messages.getMessage('defaultErrorMessage', [this.id, request.Id], 'package_uninstall');
                    return this.force.toolingQuery(this.org, util.format(ERROR_QUERY, id))
                        .then((queryResult) => {
                        const errors = [];
                        if (queryResult.records && queryResult.records.length > 0) {
                            queryResult.records.forEach((record) => {
                                errors.push(`(${errors.length + 1}) ${record.Message}`);
                            });
                        }
                        const error = new Error(`${err}${errors.length > 0 ? `\n=== Errors\n${errors.join('\n')}` : ''}`);
                        error.name = 'UNINSTALL_ERROR';
                        error.action = messages.getMessage('action', [], 'package_uninstall');
                        throw error;
                    });
                }
                default: {
                    if (retries > 0) {
                        // Request still in progress.  Just print a console message and move on. Server will be polled again.
                        if (this.status !== request.Status) {
                            this.status = request.Status;
                            logger.log(`Waiting for the package uninstall request to get processed. Status = ${request.Status}`);
                        }
                        return Promise.delay(this.pollIntervalInMillis).then(this.poll.bind(this, context, id, retries - 1));
                    }
                    return request;
                }
            }
        });
    }
    execute(context) {
        return this._execute(context)
            .catch((err) => {
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw package2Utils.applyErrorAction(err);
        });
    }
    _execute(context) {
        this.org = context.org;
        this.force = context.org.force;
        this.id = context.flags.id;
        const username = context.flags.targetusername;
        this.maxRetries = _.isNil(context.flags.wait) ? this.maxRetries : ((RETRY_MINUTES_IN_MILLIS / this.pollIntervalInMillis) * context.flags.wait);
        const apiVersion = this.force.config.getAppConfig().apiVersion;
        if (apiVersion < 36) {
            throw new Error('This command is supported only on API versions 36.0 and higher');
        }
        package2Utils.validateId(package2Utils.BY_LABEL.SUBSCRIBER_PACKAGE2_VERSION_ID, context.flags.id);
        // Construct SubscriberPackageVersionUnininstallRequest sobject used to trigger package uninstall.
        const package2UninstallRequest = {
            SubscriberPackageVersionId: this.id
        };
        // TODO: should be able to remove org.setName since framework handles org setup via cmdDef.supportsTargetUsername (true or undefined)
        if (username) {
            this.org.setName(username);
        }
        return this.force.toolingCreate(this.org, 'SubscriberPackageVersionUninstallRequest', package2UninstallRequest)
            .then((result) => {
            if (result.success) {
                return this.poll.bind(this)(context, result.id, this.maxRetries);
            }
            else {
                throw new Error(result.errors);
            }
        });
    }
    /**
     * returns a human readable message for a cli output
     * @returns {string}
     */
    getHumanSuccessMessage(result) {
        const arg = result.Status === 'Success' ?
            [result.SubscriberPackageVersionId] : [result.Id, this.org.name];
        return messages.getMessage(result.Status, arg, 'package_uninstall_get');
    }
}
module.exports = PackageUninstallCommand;

//# sourceMappingURL=packageUninstallCommand.js.map
