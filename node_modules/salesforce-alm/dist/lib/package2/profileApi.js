/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
// Node
const path = require('path');
const fs = require('fs');
const glob = require('glob');
// Thirdparty
const DOMParser = require('xmldom').DOMParser;
const XMLSerializer = require('xmldom').XMLSerializer;
// Local
const logApi = require(path.join(__dirname, '..', 'logApi'));
class ProfileApi {
    constructor(org) {
        this.org = org;
        this.config = this.org.config;
        this.apiVersion = this.config.getApiVersion();
        this.logger = logApi.child('profile');
        this.nodeEntities = {
            name: ['CustomObject', 'CustomField', 'Layout', 'CustomTab'],
            parentName: ['objectPermissions', 'fieldPermissions', 'layoutAssignments', 'tabVisibilities'],
            childName: ['object', 'field', 'layout', 'tab']
        };
    }
    _copyNodes(originalDom, parentName, childName, members, appendToNode) {
        let nodesAdded = false;
        const nodes = originalDom.getElementsByTagName(parentName);
        if (!nodes) {
            return nodesAdded;
        }
        for (let i = 0; i < nodes.length; i++) {
            const name = nodes[i].getElementsByTagName(childName)[0].childNodes[0].nodeValue;
            if (members.indexOf(name) >= 0) {
                appendToNode.appendChild(nodes[i]);
                nodesAdded = true;
            }
        }
        return nodesAdded;
    }
    _findAllProfiles() {
        return glob.sync(path.join(this.config.getProjectPath(), '**', '*.profile-meta.xml'));
    }
    /**
     * For any profile present in the workspace, this function generates a subset of data that only contains references
     * to items in the manifest.
     *
     * @param destPath location of new profiles
     * @param package manifest json object
     */
    generateProfiles(destPath, manifest) {
        const excludedProfiles = [];
        const profilePaths = this._findAllProfiles();
        if (!profilePaths) {
            return excludedProfiles;
        }
        profilePaths.forEach((profilePath) => {
            const profileDom = new DOMParser().parseFromString(fs.readFileSync(profilePath, 'utf-8'));
            const newDom = new DOMParser().parseFromString('<?xml version="1.0" encoding="UTF-8"?><Profile xmlns="http://soap.sforce.com/2006/04/metadata"></Profile>');
            const profileNode = newDom.getElementsByTagName('Profile')[0];
            let hasNodes = false;
            manifest.Package.types.forEach((element) => {
                const name = element['name'];
                const members = element['members'];
                const idx = this.nodeEntities.name.indexOf(name);
                if (idx > -1) {
                    hasNodes = this._copyNodes(profileDom, this.nodeEntities.parentName[idx], this.nodeEntities.childName[idx], members, profileNode);
                }
            });
            const xmlFile = path.basename(profilePath);
            const destFilePath = path.join(destPath, xmlFile);
            if (hasNodes) {
                const serializer = new XMLSerializer();
                fs.writeFileSync(destFilePath, serializer.serializeToString(newDom), 'utf-8');
            }
            else {
                // remove from manifest
                excludedProfiles.push(xmlFile.replace(/(.*)(\.profile)/, '$1'));
                try {
                    fs.unlinkSync(destFilePath);
                }
                catch (err) {
                    // It is normal for the file to not exist if the profile is in the worskpace but not in the directory being packaged.
                    if (err.code !== 'ENOENT') {
                        throw err;
                    }
                }
            }
        });
        return excludedProfiles;
    }
    /**
     * Filter out all profiles in the manifest and if any profiles exists in the workspace, add them to the manifest.
     *
     * @param resultAsKeyValuePairs key value pairs of manifest values
     */
    beforeManifestGenerationHook(resultAsKeyValuePairs) {
        const profilePaths = this._findAllProfiles();
        // Filter all profiles
        resultAsKeyValuePairs = resultAsKeyValuePairs.filter((kvp) => kvp.type !== 'Profile');
        if (profilePaths) {
            profilePaths.forEach((profilePath) => {
                const profileName = profilePath.replace(/(.*profiles.)(.*)(\.profile-meta.xml)/, '$2');
                resultAsKeyValuePairs.push({ type: 'Profile', name: profileName });
            });
        }
        return resultAsKeyValuePairs;
    }
    /**
     * Filter out all profile metadata from the metadata directory
     *
     * @param sourceElementsForMdDir all source elements used to populate the metadata directory.
     */
    beforePopulateMdDirHook(sourceElementsForMdDir) {
        // Filter out All Profiles. These are processed and added separately
        return sourceElementsForMdDir.filter((element) => element.typeDef.metadataName !== 'Profile');
    }
}
module.exports = ProfileApi;

//# sourceMappingURL=profileApi.js.map
