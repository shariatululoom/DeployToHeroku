/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require('fs');
const archiver = require('archiver');
const os = require('os');
// 3pp
const BBPromise = require('bluebird');
// Local
const logger = require(path.join('..', 'lib', 'logApi'));
const almError = require(path.join(__dirname, 'almError'));
const DeployReport = require(path.join(__dirname, 'mdapiDeployReportApi'));
const constants = require(path.join(__dirname, 'constants'));
const StashApi = require(path.join(__dirname, 'stash'));
const DEPLOY_ERROR_EXIT_CODE = 1;
// convert params (lowercase) to expected deploy options (camelcase)
const convertParamsToDeployOptions = function ({ rollbackonerror, testlevel, runtests, autoUpdatePackage, checkonly, ignorewarnings }) {
    const deployOptions = {};
    deployOptions.rollbackOnError = rollbackonerror;
    if (testlevel) {
        deployOptions.testLevel = testlevel;
    }
    if (runtests) {
        // FIXME: mdapi still only running first test
        deployOptions.runTests = runtests.includes(',') ? runtests.split(',') : runtests;
    }
    if (autoUpdatePackage) {
        deployOptions.autoUpdatePackage = autoUpdatePackage;
    }
    if (ignorewarnings) {
        deployOptions.ignoreWarnings = ignorewarnings;
    }
    if (checkonly) {
        deployOptions.checkOnly = checkonly;
    }
    return deployOptions;
};
/**
 * API that wraps Metadata API to deploy source - directory or zip - to given org.
 *
 * @param force
 * @constructor
 */
class MdDeployApi {
    constructor(org, pollIntervalStrategy) {
        this.scratchOrg = org;
        this.force = org.force;
        this.logger = logger.child('md-deploy');
        this.timer = process.hrtime();
        this._fsStatAsync = BBPromise.promisify(fs.stat);
        this._reporter = new DeployReport(org, pollIntervalStrategy);
        this.pollIntervalStrategy = pollIntervalStrategy;
    }
    _getElapsedTime() {
        const elapsed = process.hrtime(this.timer);
        this.timer = process.hrtime();
        return ((elapsed[0] * 1000) + (elapsed[1] / 1000000)).toFixed(3);
    }
    _zip(dir, zipfile) {
        const file = path.parse(dir);
        const outFile = zipfile || path.join((os.tmpdir() || '.'), `${file.base}.zip`);
        const output = fs.createWriteStream(outFile);
        return new BBPromise((resolve, reject) => {
            const archive = archiver('zip', { zlib: { level: 9 } });
            archive.on('finish', () => {
                this._log(`${archive.pointer()} bytes written to ${outFile} using ${this._getElapsedTime()}ms`);
                resolve(outFile);
            });
            archive.on('error', (err) => {
                this._logError(err);
                reject(err);
            });
            archive.pipe(output);
            archive.directory(dir, file.base);
            archive.finalize();
        });
    }
    _log(message) {
        if (this.loggingEnabled) {
            this.logger.log(message);
        }
    }
    _logError(message) {
        if (this.loggingEnabled) {
            this.logger.error(message);
        }
    }
    _getMetadata({ deploydir, zipfile }) {
        // either zip root dir or pass given zip filepath
        return deploydir ? this._zip(deploydir, zipfile) : zipfile;
    }
    _sendMetadata(zipPath, options) {
        zipPath = path.resolve(zipPath);
        this._log(`Deploying ${zipPath}...`);
        const zipStream = this._createReadStream(zipPath);
        return this.force.mdapiDeploy(this.scratchOrg, zipStream, convertParamsToDeployOptions(options));
    }
    _createReadStream(zipPath) {
        return fs.createReadStream(zipPath);
    }
    deploy(options) {
        // Logging is enabled if the output is not json and logging is not disabled
        this.loggingEnabled = options.verbose || (!options.json && !options.disableLogging);
        options.wait = +(options.wait || constants.DEFAULT_MDAPI_WAIT_MINUTES);
        if (options.rollbackonerror === undefined && options.ignoreerrors === undefined) {
            options.rollbackonerror = true;
        }
        else {
            options.rollbackonerror = false;
        }
        return this._doDeploy(options);
    }
    validate(context) {
        const options = context.flags;
        const deploydir = options.deploydir;
        const zipfile = options.zipfile;
        const jobid = options.jobid;
        const validationPromises = [];
        // Wait must be a number that is greater than zero or equal to -1.
        const validWaitValue = !isNaN(+options.wait) && (+options.wait === -1 || +options.wait >= 0);
        if (options.wait && !validWaitValue) {
            return BBPromise.reject(almError('mdapiCliInvalidWaitError'));
        }
        if (options.rollbackonerror) {
            if (options.rollbackonerror.toLowerCase() === 'true') {
                options.rollbackonerror = true;
            }
            else if (options.rollbackonerror.toLowerCase() === 'false') {
                options.rollbackonerror = false;
            }
            else {
                return BBPromise.reject(almError('mdDeployCommandCliInvalidRollbackError', options.rollbackonerror));
            }
        }
        if (!(deploydir || zipfile || jobid)) {
            return BBPromise.reject(almError('MissingRequiredParameter', 'deploydir|zipfile|jobid'));
        }
        try {
            this._validateExclusiveFlag(options, 'deploydir', 'jobid');
            this._validateExclusiveFlag(options, 'zipfile', 'jobid');
            this._validateExclusiveFlag(options, 'checkonly', 'jobid');
            this._validateExclusiveFlag(options, 'rollbackonerror', 'ignoreerrors');
        }
        catch (e) {
            return BBPromise.reject(e);
        }
        // Validate required options
        if (deploydir) {
            // Validate that the deploy root is a directory.
            validationPromises.push(this._validateFileStat(deploydir, fileData => fileData.isDirectory(), BBPromise.resolve, almError('InvalidArgumentDirectoryPath', ['deploydir', deploydir])));
        }
        else if (zipfile) {
            // Validate that the zipfile is a file.
            validationPromises.push(this._validateFileStat(zipfile, fileData => fileData.isFile(), BBPromise.resolve, almError('InvalidArgumentFilePath', ['zipfile', zipfile])));
        }
        return BBPromise.all(validationPromises).then(() => BBPromise.resolve(options));
    }
    // Accepts:
    //     pathToValidate: a file path to validate
    //     validationFunc: function that is called with the result of a fs.stat(), should return true or false
    //     successFunc:    function that returns a promise.
    //     error:          an Error object that will be thrown if the validationFunc returns false.
    // Returns:
    //     Successfull Validation: The result of a call to successFunc.
    //     Failed Validation:      A rejected promise with the specified error, or a PathDoesNotExist
    //                             error if the file read fails.
    _validateFileStat(pathToValidate, validationFunc, successFunc, error) {
        return this._fsStatAsync(pathToValidate).then((data) => {
            if (validationFunc(data)) {
                return successFunc();
            }
            else {
                return Promise.reject(error);
            }
        }).catch((err) => {
            err = (err.code === 'ENOENT') ? almError('PathDoesNotExist', pathToValidate) : err;
            return BBPromise.reject(err);
        });
    }
    _validateExclusiveFlag(options, param1, param2) {
        if (options[param1] !== undefined && options[param2] !== undefined) {
            throw almError('mdapiCliExclusiveFlagError', [param1, param2]);
        }
    }
    _doDeployStatus(result, options) {
        options.deprecatedStatusRequest = (options.jobid) ? true : false;
        options.jobid = options.jobid || result.id;
        options.result = result;
        options.result.status = options.result.state;
        return this._reporter.report(options);
    }
    _setStashVars(result, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield StashApi.setValues({
                jobid: result.id,
                targetusername: options.targetusername
            }, StashApi.Commands.MDAPI_DEPLOY);
            return result;
        });
    }
    _doDeploy(options) {
        return BBPromise.resolve()
            .then(() => this._getMetadata(options))
            .then(zipPath => {
            let promise = BBPromise.resolve();
            if (!options.jobid) {
                promise = this._sendMetadata(zipPath, options);
            }
            return promise;
        })
            .then(result => this._setStashVars(result, options))
            .then(result => this._doDeployStatus(result, options))
            .then(result => this._throwErrorIfDeployFailed(result))
            .catch((err) => {
            if (err.name === 'sf:MALFORMED_ID') {
                throw almError('mdDeployCommandCliInvalidJobIdError', options.jobid);
            }
            else {
                throw err;
            }
        });
    }
    _throwErrorIfDeployFailed(result) {
        if (result.status === 'Failed') {
            const err = almError('mdapiDeployFailed');
            this._setExitCode(DEPLOY_ERROR_EXIT_CODE);
            err.result = result;
            return BBPromise.reject(err);
        }
        return BBPromise.resolve(result);
    }
    _setExitCode(code) {
        process.exitCode = code;
    }
    _minToMs(min) {
        return min * 60000;
    }
}
module.exports = MdDeployApi;

//# sourceMappingURL=mdapiDeployApi.js.map
