/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// Node
const util = require('util');
const path = require('path');
// Thirdparty
const _ = require('lodash');
const Promise = require('bluebird');
const optional = require('optional-js');
// Local
const almError = require(path.join(__dirname, 'almError'));
const Force = require(path.join(__dirname, 'force'));
const OrgPrefRegistry = require(path.join(__dirname, 'orgPrefRegistry'));
const messages = require(path.join(__dirname, 'messages'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const logger = require(path.join(__dirname, 'logApi'));
/**
 * Returns the url to be used to authorize into the new scratch org
 * @param scratchOrgInfoComplete
 * @param force
 * @param useLoginUrl
 * @returns {*}
 * @private
 */
const _getOrgInstanceAuthority = function (scratchOrgInfoComplete, appConfig, useLoginUrl, masterOrgLoginUrl) {
    const createdOrgInstance = scratchOrgInfoComplete.SignupInstance;
    let signupTargetLoginUrl;
    if (createdOrgInstance === 'utf8') {
        signupTargetLoginUrl = masterOrgLoginUrl;
    }
    else {
        const signupTargetLoginUrlConfig = appConfig.signupTargetLoginUrl;
        signupTargetLoginUrl = optional.ofNullable(signupTargetLoginUrlConfig)
            .orElse(`https://${createdOrgInstance}.salesforce.com`);
    }
    return signupTargetLoginUrl;
};
/**
 * after we successfully signup an org we need to trade the auth token for access and refresh token.
 * @param scratchOrgInfoComplete - The completed ScratchOrgInfo which should contain an access token.
 * @param force - the force api
 * @param hubOrg - the environment hub org
 * @param scratchOrg - the scratch org to save to disk
 * @param clientSecret - The OAuth client secret. May be null for JWT OAuth flow.
 * @param saveAsDefault {boolean} - whether to save this org as the default for this workspace.
 * @returns {*}
 * @private
 */
const _authorize = function (scratchOrgInfoComplete, force, hubOrg, scratchOrg, clientSecret, saveAsDefault) {
    const appConfig = force.config.getAppConfigIfInWorkspace();
    const oauthConfig = {
        clientId: scratchOrgInfoComplete.ConnectedAppConsumerKey,
        createdOrgInstance: scratchOrgInfoComplete.SignupInstance
    };
    const isJwtFlow = util.isNullOrUndefined(clientSecret);
    return hubOrg.getConfig()
        .then((configData) => {
        configData.isDevHub = true;
        return hubOrg.saveConfig(configData);
    })
        .then((config) => {
        oauthConfig.loginUrl = _getOrgInstanceAuthority(scratchOrgInfoComplete, appConfig, true, config.loginUrl);
        if (isJwtFlow) {
            // JWT OAuth flow
            oauthConfig.username = scratchOrgInfoComplete.SignupUsername;
            oauthConfig.privateKeyFile = config.privateKey;
        }
        else {
            // Web Server OAuth "auth code exchange" flow
            oauthConfig.clientSecret = clientSecret;
            oauthConfig.redirectUri = scratchOrg.config.getOauthCallbackUrl();
            oauthConfig.authCode = scratchOrgInfoComplete.AuthCode;
        }
        oauthConfig.devHubUsername = config.username;
        oauthConfig.created = Date.now();
        return force.authorizeAndSave(oauthConfig, scratchOrg, saveAsDefault)
            .catch((err) => {
            // If the custom domain url is not yet available,
            // the authorization above will fail. If this is the source of the error,
            // then retry the authorization using the instance url
            if (err.code === 'ENOTFOUND') {
                oauthConfig.loginUrl = _getOrgInstanceAuthority(scratchOrgInfoComplete, appConfig, false, config.loginUrl);
                return force.authorizeAndSave(oauthConfig, scratchOrg, saveAsDefault);
            }
            else {
                return Promise.reject(err);
            }
        });
    });
};
/**
 * Copy the orgPreferences out of the definition, if they exist. Note that the scratchDef map is
 * being modified to remove the orgPreferences object, if it exists.
 *
 * @param scratchDef The JSON representation of the scratch org definition file.
 * @returns {*} The Object representing the orgPreferences, or undefined if none were specified.
 */
const _extractPrefs = function (scratchDef) {
    const orgPrefs = {};
    function reducePrefs(prefNames, prefVal) {
        if (prefNames) {
            prefNames.reduce((acc, val) => {
                acc[val] = prefVal;
                return acc;
            }, orgPrefs);
        }
    }
    reducePrefs(_.get(scratchDef, 'orgPreferences.enabled'), true);
    reducePrefs(_.get(scratchDef, 'orgPreferences.disabled'), false);
    delete scratchDef.orgPreferences;
    return orgPrefs;
};
/**
 * Builds a Map of org preference API type to an array of the org preferences (and values) to be set via that API.
 * @param prefs - The Object representing the OrgPreferences.
 * @returns {*} The Map of API type to org preferences and values. May be empty.
 * @private
 */
const _buildOrgPrefsToApiMap = function (prefs) {
    const orgPrefApiMap = new Map();
    Object.keys(prefs).forEach((pref) => {
        const orgPrefApi = OrgPrefRegistry.whichApi(pref);
        if (util.isNullOrUndefined(orgPrefApi)) {
            const err = new Error(`Unsupported org preference: ${pref}`);
            err.name = 'UnsupportedOrgPreference';
            throw err;
        }
        const orgPref = {};
        orgPref[pref] = prefs[pref];
        if (!orgPrefApiMap.has(orgPrefApi)) {
            orgPrefApiMap.set(orgPrefApi, [orgPref]);
        }
        else {
            const apiOrgPrefs = orgPrefApiMap.get(orgPrefApi);
            apiOrgPrefs.push(orgPref);
            orgPrefApiMap.set(orgPrefApi, apiOrgPrefs);
        }
    });
    return orgPrefApiMap;
};
/**
 * Signup API object.
 * @constructor
 * @param configApi The app configuration
 * @param forceApi The force api
 * the scratchOrgInfo status is active.
 */
const signup = function (forceApi, hubOrg) {
    this.force = optional.ofNullable(forceApi).orElse(new Force());
    this.hubOrg = hubOrg;
    this.logger = logger.child('scratchOrgInfoApi');
    this.orgPrefApiMap = null;
};
/**
 * This extracts orgPrefs from the user input and performs a basic scratchOrgInfo request.
 * @param scratchOrgInfo - An object containing the fields of the ScratchOrgInfo.
 * @returns {*|promise}
 */
signup.prototype.request = function (scratchOrgInfo) {
    const prefs = _extractPrefs(scratchOrgInfo);
    if (!_.isEmpty(prefs)) {
        try {
            this.orgPrefApiMap = _buildOrgPrefsToApiMap(prefs);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    const _scratchOrgInfo = srcDevUtil.mapKeys(scratchOrgInfo, _.upperFirst, true);
    return this.force.create(this.hubOrg, 'ScratchOrgInfo', _scratchOrgInfo)
        .catch((err) => {
        if (err.errorCode === 'REQUIRED_FIELD_MISSING') {
            err.message = messages(this.force.config.getLocale()).getMessage('signupFieldsMissing', err.fields.toString());
        }
        return Promise.reject(err);
    });
};
/**
 * salesforce only allows soql queries that are 10K or less characters long. We want to isolate ScratchOrgInfo queries to locally
 * authenticated orgs. To do that we need to make sure jsforce doesn't submit a query that exceeds this limit. Which is
 * what could happen by calling retrieveScratchOrgInfosWhereInOrgIds with a criteria object such as
 * {ScratchOrg: {$in: [...]}}
 * @param {object} devHub - The devHub used to query ScratchOrgInfo objects.
 * @param {array} scratchOrgIds - List of org ids that will be chunked.
 * @param {number} chunkSize - The maximum number of ScratchOrgsIds to submit in one query.
 * @returns {Promise.<Map>} - See retrieveScratchOrgInfos
 */
signup.prototype.retrieveScratchOrgInfosWhereInOrgIds = function (devHub, scratchOrgIds, chunkSize = 100) {
    const maxChunkSize = _.isInteger(chunkSize) && chunkSize > 0 ? chunkSize : 100;
    const maxNumberOfIds = 2000;
    if (scratchOrgIds) {
        if (scratchOrgIds.length > maxNumberOfIds) {
            return Promise.reject(almError('MaxOrgIds', [maxNumberOfIds], 'MaxOrgIdsAction'));
        }
        if (scratchOrgIds.length > maxChunkSize) {
            const chunks = _.chunk(scratchOrgIds, maxChunkSize);
            // Id list is chunked to ensure jsforce doesn't specify a query greater than 10K characters. And we won't submit more
            // than 1 request at a time.
            return Promise.map(chunks, (chunk) => this.retrieveScratchOrgInfos(devHub, { ScratchOrg: { $in: chunk } }), { concurrency: 1 })
                .then((arrayOfMaps) => _.reduce(arrayOfMaps, (accum, value) => new Map([...accum, ...value]), new Map()));
        }
        else {
            return this.retrieveScratchOrgInfos(devHub, { ScratchOrg: { $in: scratchOrgIds } });
        }
    }
    return Promise.resolve(new Map());
};
/**
 * retrieves a list of scratchOrgInfo's associated with a devHub
 * @param devHub - the dev hub associated with the infos.
 * @param {object} criteria - the query criteria. ex {Id: '1234233214'}
 * @param {array} fields - the fields expected for the return
 * @returns {Promise.<Map>} keys = SignupUsername, values = org data
 */
signup.prototype.retrieveScratchOrgInfos = function (devHub, criteria, fields) {
    // By default we will find all
    let _criteria = {};
    // make sure devHub is defined
    if (!_.isNil(devHub)) {
        // if criteria is specified
        if (!_.isNil(criteria)) {
            // And it's and object
            if (_.isObject(criteria) && !_.isEmpty(criteria)) {
                _criteria = criteria;
            }
            else {
                const error = new Error(`criteria must be an object: ${criteria}`);
                error.name = 'InvalidCriteria';
                return Promise.reject(error);
            }
        }
        // default criteria
        let _fields = ['OrgName', 'Status', 'CreatedBy.Username', 'CreatedDate', 'ExpirationDate', 'Edition'];
        // if fields are specified
        if (!_.isNil(fields)) {
            // And it's an array of non-empty strings
            if (_.isArray(fields) && fields.length > 0 &&
                fields.every((elem) => _.isString(elem) && elem.length > 0)) {
                _fields = fields;
            }
            else {
                const error = new Error(`fields must be an array: ${criteria}`);
                error.name = 'InvalidFields';
                return Promise.reject(error);
            }
        }
        const returnKey = 'SignupUsername';
        // Ensure the fields includes the ScratchOrgId
        if (!_fields.includes(returnKey)) {
            _fields.push(returnKey);
        }
        // Go to the server and get all the scratch orgs for the specified dev hub.
        // Return a map keyed by SignupUsername
        return devHub.getConfig().then((orgConfig) => this.force.find(devHub, 'ScratchOrgInfo', _criteria, _fields).then((data) => {
            // convert head up camel case to head down camel case
            const info = data.map((element) => {
                const orgElement = _.mapKeys(element, (val, key) => _.camelCase(key));
                orgElement.devHubOrgId = orgConfig.orgId;
                // Store the dev hub reference since we have it and it's potentially expensive to get.
                orgElement.devHubUsername = orgConfig.username;
                if (_.isPlainObject(orgElement.createdBy)) {
                    orgElement.createdBy = orgElement.createdBy.Username;
                }
                return orgElement;
            });
            // index the scratch org infos by signupUsername
            return new Map(info.map((element) => [element[_.camelCase(returnKey)], element]));
        }));
    }
    else {
        const error = new Error('provide a devHub when finding scratchOrgInfo objects');
        error.name = 'NoDevHub';
        return Promise.reject(error);
    }
};
/**
 * This retrieves the ScratchOrgInfo
 * @param scratchOrgInfoId - the id of the scratchOrgInfo that we are retrieving
 * @returns {Promise}
 */
signup.prototype.retrieveScratchOrgInfo = function (scratchOrgInfoId) {
    return this.force.retrieve(this.hubOrg, 'ScratchOrgInfo', scratchOrgInfoId)
        .then((request) => {
        let message;
        let error;
        switch (request.Status) {
            case 'Active':
                return request;
            case 'Error':
                message = messages(this.force.config.getLocale()).getMessage('signupFailed', request.ErrorCode);
                error = new Error(message);
                error.name = 'RemoteOrgSignupFailed';
                return Promise.reject(error);
            default:
                message = messages(this.force.config.getLocale()).getMessage('signupUnexpected');
                error = new Error(message);
                error.name = 'UnexpectedSignupStatus';
                return Promise.reject(error);
        }
    });
};
/**
 * This authenticates into the newly created org and sets org preferences
 * @param scratchOrgInfoResult - an object containing the fields of the ScratchOrgInfo
 * @param clientSecret - the OAuth client secret. May be null for JWT OAuth flow
 * @param scratchOrg - The ScratchOrg configuration
 * @param saveAsDefault - Save the org as the default for commands to run against
 * @returns {*}
 */
signup.prototype.processScratchOrgInfoResult = function (scratchOrgInfoResult, clientSecret, scratchOrg, setAsDefault) {
    scratchOrg.setName(scratchOrgInfoResult.SignupUsername);
    return _authorize(scratchOrgInfoResult, this.force, this.hubOrg, scratchOrg, clientSecret, setAsDefault).then((orgData) => {
        const resultingOrgData = orgData;
        const setPreferences = () => {
            if (!util.isNullOrUndefined(this.orgPrefApiMap) && this.orgPrefApiMap.size > 0) {
                return scratchOrg.setPreferences(this.orgPrefApiMap);
            }
            return Promise.resolve(null);
        };
        // perform remote operations in parallel
        return Promise.all([
            // set desired prefs on org
            setPreferences(),
            // send creds for apphub access
            scratchOrg.getAppHub().then((appHubApi) => appHubApi.postScratchOrgCreate(scratchOrgInfoResult, scratchOrg))
        ])
            .then(() => resultingOrgData)
            .catch((err) => Promise.reject(err));
    });
};
module.exports = signup;

//# sourceMappingURL=scratchOrgInfoApi.js.map
