/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// Node
const path = require('path');
const _ = require('lodash');
// Local
const ConfigFile = require(path.join(__dirname, 'ConfigFile'));
const almError = require(path.join(__dirname, '..', 'almError'));
const consts = require(path.join(__dirname, '..', 'constants'));
const messages = require(path.join(__dirname, '..', 'messages'))();
const srcDevUtil = require(path.join(__dirname, '..', 'srcDevUtil'));
const SFDX_CONFIG_FILE_NAME = 'sfdx-config.json';
const OrgDefaults = {
    DEVHUB: consts.DEFAULT_DEV_HUB_USERNAME,
    USERNAME: consts.DEFAULT_USERNAME,
    list() {
        return [OrgDefaults.DEVHUB, OrgDefaults.USERNAME, OrgDefaults.APIVERSION];
    }
};
// In the future consider keying input validation off of command type validation.
const ALLOWED_PROPERTIES = [
    {
        key: 'instanceUrl',
        input: {
            // If a value is provided validate it otherwise no value is unset.
            validator: value => _.isNil(value) || srcDevUtil.isSalesforceDomain(value),
            failedMessage: messages.getMessage('invalidInstanceUrl', null, 'sfdxConfig')
        }
    },
    {
        key: 'apiVersion',
        hidden: true,
        input: {
            // If a value is provided validate it otherwise no value is unset.
            validator: (value) => _.isNil(value) || /[1-9]\d\.0/.test(value),
            failedMessage: messages.getMessage('invalidApiVersion', null, 'sfdxConfig')
        }
    },
    { key: consts.DEFAULT_DEV_HUB_USERNAME },
    { key: consts.DEFAULT_USERNAME }
];
const _checkEnoent = function (err) {
    if (err.code === 'ENOENT') {
        this.contents = {};
        return this.contents;
    }
    else {
        throw err;
    }
};
class SfdxConfig extends ConfigFile {
    constructor(isGlobal) {
        super(SFDX_CONFIG_FILE_NAME, isGlobal, true);
    }
    read() {
        return srcDevUtil.readJSON(this.path, false)
            .then(content => {
            this.contents = content;
            return content;
        })
            .catch(err => _checkEnoent.call(this, err));
    }
    /**
     * Sync version of read.
     * @deprecated This should only be used by legacy config.
     */
    readSync() {
        try {
            this.contents = srcDevUtil.readJSONSync(this.path, false);
        }
        catch (err) {
            return _checkEnoent.call(this, err);
        }
        return this.contents;
    }
    setPropertyValue(propertyName, value) {
        const property = SfdxConfig.getAllowedProperties().find((allowedProp) => allowedProp.key === propertyName);
        if (!property) {
            throw almError({ keyName: 'UnknownConfigKey', bundle: 'sfdxConfig' }, [propertyName]);
        }
        if (property.input) {
            if (property.input && property.input.validator(value)) {
                this.contents[property.key] = value;
            }
            else {
                throw almError({ keyName: 'invalidConfigValue', bundle: 'sfdxConfig' }, [property.input.failedMessage]);
            }
        }
        else {
            this.contents[property.key] = value;
        }
    }
    static getAllowedProperties() {
        return ALLOWED_PROPERTIES;
    }
    static set(isGlobal, property, value) {
        const config = new SfdxConfig(isGlobal);
        return config.read()
            .then(content => {
            if (_.isNil(value)) {
                delete content[property];
            }
            else {
                content[property] = value;
            }
            return config.write(content);
        });
    }
    static clear() {
        return (new SfdxConfig(true)).write({})
            .then(() => (new SfdxConfig(false)).write({}));
    }
}
SfdxConfig.OrgDefaults = OrgDefaults;
module.exports = SfdxConfig;

//# sourceMappingURL=SfdxConfig.js.map
