/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// Node
const path = require('path');
const util = require('util');
// Local
const messages = require(path.join(__dirname, '..', 'messages'))();
const CommandRegistry = require(path.join(__dirname, '..', 'commandRegistry'));
const pkg2Utils = require(path.join(__dirname, 'package2Utils'));
class Package2VersionUpdateCommand {
    constructor() {
        this.error = null;
    }
    /**
     * Convert the list of command line options to a JSON object that can be used to update an Package2Version entity.
     * @param context
     * @returns {{Id: (string|string|string), Name: (string|string), Description: (string|string), Branch: (string|string), Tag: (string|string), IsBeta: (boolean}}
     * @private
     */
    _updatePackage2VersionRequestFromContext(context) {
        const values = {};
        const mapping = {
            package2versionid: 'Id',
            installationkey: 'InstallKey',
            setasreleased: 'IsBeta'
        };
        // if --setasreleased, then IsBeta=false
        if (!util.isNullOrUndefined(context.flags.setasreleased)) {
            context.flags.setasreleased = false;
        }
        const globals = [...new Set(CommandRegistry.GLOBAL_PARAMETERS.map(global => global.name)),
            CommandRegistry.TARGET_DEV_HUB_USERNAME_PARAMETER.name
        ];
        Object.keys(context.flags).forEach((flag) => {
            if (!globals.includes(flag) && !util.isNullOrUndefined(context.flags[flag])) {
                const apiName = mapping[flag] ? mapping[flag] : flag.charAt(0).toUpperCase() + flag.slice(1);
                values[apiName] = context.flags[flag];
            }
        });
        return values;
    }
    execute(context) {
        return this._execute(context)
            .catch((err) => {
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw pkg2Utils.applyErrorAction(err);
        });
    }
    _execute(context) {
        this.org = context.org;
        this.force = context.org.force;
        pkg2Utils.validateId(pkg2Utils.BY_LABEL.PACKAGE2_VERSION_ID, context.flags.package2versionid);
        const request = this._updatePackage2VersionRequestFromContext(context);
        return this.force.toolingUpdate(this.org, 'Package2Version', request)
            .then((updateResult) => {
            if (!updateResult.success) {
                throw new Error(updateResult.errors);
            }
            return updateResult;
        })
            .catch((err) => {
            if (err.name === 'DUPLICATE_VALUE' && err.message.includes('previously released')) {
                err.action = messages.getMessage('previousReleased', [], 'package2_version_update');
            }
            throw err;
        });
    }
    getHumanSuccessMessage(result) {
        return messages.getMessage('humanSuccess', [result.id], 'package2_version_update');
    }
}
module.exports = Package2VersionUpdateCommand;

//# sourceMappingURL=package2VersionUpdateCommand.js.map
