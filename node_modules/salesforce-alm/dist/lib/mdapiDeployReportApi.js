/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const path = require('path');
const fs = require('fs');
const archiver = require('archiver');
const os = require('os');
// 3pp
const BBPromise = require("bluebird");
const _ = require('lodash');
const util = require('util');
// Local
const logger = require(path.join('..', 'lib', 'logApi'));
const almError = require(path.join(__dirname, 'almError'));
const messages = require(path.join(__dirname, 'messages'))();
const CheckStatus = require(path.join(__dirname, 'mdapiCheckStatusApi'));
const constants = require(path.join(__dirname, 'constants'));
const Stash = require(path.join(__dirname, 'stash'));
const DEPLOY_ERROR_EXIT_CODE = 1;
/**
 * API that wraps Metadata API to deploy source - directory or zip - to given org.
 *
 * @param force
 * @constructor
 */
class MdDeployReportApi {
    constructor(org, pollIntervalStrategy) {
        this.scratchOrg = org;
        this.force = org.force;
        this.logger = logger.child('md-deploy-report');
        this._fsStatAsync = BBPromise.promisify(fs.stat);
        this._print = this._print.bind(this);
        this.pollIntervalStrategy = pollIntervalStrategy;
    }
    _log(message) {
        if (this.loggingEnabled) {
            this.logger.log(message);
        }
    }
    _logError(message) {
        if (this.loggingEnabled) {
            this.logger.error(message);
        }
    }
    _print(options, result) {
        if (this.loggingEnabled) {
            const deployStart = new Date(result.createdDate).getTime();
            const deployEnd = new Date(result.completedDate).getTime();
            const totalDeployTime = deployEnd - deployStart;
            const processingHeader = this.logger.color.yellow('Status');
            const successHeader = this.logger.color.green('Result');
            const failureHeader = this.logger.color.red('Result');
            this._log('');
            if (!result.done) {
                this.logger.styledHeader(processingHeader);
            }
            else {
                if (result.completedDate) {
                    this._log(`Deployment finished in ${totalDeployTime}ms`);
                }
                this._log('');
                const header = (result.success) ? successHeader : failureHeader;
                this.logger.styledHeader(header);
            }
            const successfullComponentsMessage = (result.checkOnly) ?
                `Components checked:  ${result.numberComponentsDeployed}` :
                `Components deployed:  ${result.numberComponentsDeployed}`;
            this._log(`Status:  ${result.status}`);
            this._log(`jobid:  ${result.id}`);
            if (result.status !== 'Queued') {
                if (result.completedDate) {
                    this._log(`Completed:  ${result.completedDate}`);
                } // TODO: convert to locale
                this._log(`Component errors:  ${result.numberComponentErrors}`);
                this._log(successfullComponentsMessage);
                this._log(`Components total:  ${result.numberComponentsTotal}`);
                this._log(`Tests errors:  ${result.numberTestErrors}`);
                this._log(`Tests completed:  ${result.numberTestsCompleted}`);
                this._log(`Tests total:  ${result.numberTestsTotal}`);
                this._log(`Check only: ${result.checkOnly}`);
                if (result.details && result.details.componentFailures) {
                    if (!util.isArray(result.details.componentFailures)) {
                        result.details.componentFailures = [result.details.componentFailures];
                    }
                    // sort by filename then fullname
                    const failures = _.chain(result.details.componentFailures)
                        .sortBy([function (o) { return o.fileName ? o.fileName.toUpperCase() : o.fileName; }])
                        .sortBy([function (o) { return o.fullName ? o.fullName.toUpperCase() : o.fullName; }])
                        .value();
                    this._log('');
                    this.logger.styledHeader(this.logger.color.red(`Component Failures [${failures.length}]`));
                    this.logger.table(failures, {
                        columns: [
                            { key: 'problemType', label: 'Type' },
                            { key: 'fileName', label: 'File' },
                            { key: 'fullName', label: 'Name' },
                            { key: 'problem', label: 'Problem' }
                        ]
                    });
                }
                if (result.details.runTestResult) {
                    if (result.details.runTestResult.failures) {
                        if (!util.isArray(result.details.runTestResult.failures)) {
                            result.details.runTestResult.failures = [result.details.runTestResult.failures];
                        }
                        const tests = _.chain(result.details.runTestResult.failures)
                            .sortBy([function (o) { return o.methodName.toUpperCase(); }])
                            .sortBy([function (o) { return o.name.toUpperCase(); }])
                            .value();
                        this._log('');
                        this.logger.styledHeader(this.logger.color.red(`Test Failures [${result.details.runTestResult.numFailures}]`));
                        this.logger.table(tests, {
                            columns: [
                                { key: 'name', label: 'Name' },
                                { key: 'methodName', label: 'Method' },
                                { key: 'message', label: 'Message' },
                                { key: 'stackTrace', label: 'Stacktrace' }
                            ]
                        });
                    }
                    if (result.details.runTestResult.successes) {
                        if (!util.isArray(result.details.runTestResult.successes)) {
                            result.details.runTestResult.successes = [result.details.runTestResult.successes];
                        }
                        const tests = _.chain(result.details.runTestResult.successes)
                            .sortBy([function (o) { return o.methodName.toUpperCase(); }])
                            .sortBy([function (o) { return o.name.toUpperCase(); }])
                            .value();
                        this._log('');
                        this.logger.styledHeader(this.logger.color.green(`Test Success [${result.details.runTestResult.successes.length}]`));
                        this.logger.table(tests, {
                            columns: [
                                { key: 'name', label: 'Name' },
                                { key: 'methodName', label: 'Method' }
                            ]
                        });
                    }
                    if (result.details.runTestResult.codeCoverage) {
                        if (!util.isArray(result.details.runTestResult.codeCoverage)) {
                            result.details.runTestResult.codeCoverage = [result.details.runTestResult.codeCoverage];
                        }
                        const coverage = _.chain(result.details.runTestResult.codeCoverage)
                            .sortBy([function (o) { return o.name.toUpperCase(); }])
                            .value();
                        this._log('');
                        this.logger.styledHeader(this.logger.color.blue('Apex Code Coverage'));
                        this.logger.table(coverage, {
                            columns: [
                                { key: 'name', label: 'Name' },
                                {
                                    key: 'numLocations',
                                    label: '% Covered',
                                    format: (numLocations, row) => {
                                        numLocations = parseInt(numLocations);
                                        const numLocationsNotCovered = parseInt(row.numLocationsNotCovered);
                                        let color = this.logger.color.green;
                                        // Is 100% too high of a bar?
                                        if (numLocationsNotCovered > 0) {
                                            color = this.logger.color.red;
                                        }
                                        let pctCovered = 100;
                                        let coverageDecimal = parseFloat(((numLocations - numLocationsNotCovered) / numLocations).toFixed(2));
                                        if (numLocations > 0) {
                                            pctCovered = coverageDecimal * 100;
                                        }
                                        return color(`${pctCovered}%`);
                                    }
                                },
                                {
                                    key: 'locationsNotCovered',
                                    label: 'Uncovered Lines',
                                    format: (locationsNotCovered) => {
                                        if (!locationsNotCovered) {
                                            return '';
                                        }
                                        if (!util.isArray(locationsNotCovered)) {
                                            locationsNotCovered = [locationsNotCovered];
                                        }
                                        const uncoveredLines = [];
                                        locationsNotCovered.forEach((uncoveredLine) => {
                                            uncoveredLines.push(uncoveredLine.line);
                                        });
                                        return uncoveredLines.join(',');
                                    }
                                }
                            ]
                        });
                    }
                    if (result.details.runTestResult.successes || result.details.runTestResult.failures) {
                        this._log('');
                        this._log(`Total Test Time:  ${result.details.runTestResult.totalTime}`);
                    }
                }
                if (options.verbose && result.details.componentSuccesses) {
                    if (!util.isArray(result.details.componentSuccesses)) {
                        result.details.componentSuccesses = [result.details.componentSuccesses];
                    }
                    if (result.details.componentSuccesses.length > 0) {
                        // sort by type then filename then fullname
                        const files = result.details.componentSuccesses.length > 0 ? _.chain(result.details.componentSuccesses)
                            .sortBy([function (o) { return o.fullName ? o.fullName.toUpperCase() : o.fullName; }])
                            .sortBy([function (o) { return o.fileName ? o.fileName.toUpperCase() : o.fileName; }])
                            .sortBy([function (o) { return o.componentType ? o.componentType.toUpperCase() : o.componentType; }])
                            .value() :
                            [];
                        this._log('');
                        this.logger.styledHeader(this.logger.color.blue(`Components Deployed [${result.numberComponentsDeployed}]`));
                        this.logger.table(files, {
                            columns: [
                                { key: 'componentType', label: 'Type' },
                                { key: 'fileName', label: 'File' },
                                { key: 'fullName', label: 'Name' },
                                { key: 'id', label: 'Id' }
                            ]
                        });
                    }
                }
            }
            this._log('');
            if (result.timedOut) {
                this._log(messages.getMessage('mdDeployCommandCliWaitTimeExceededError', [options.wait]));
            }
        }
        return result;
    }
    report(options) {
        // Logging is enabled if the output is not json and logging is not disabled
        this.loggingEnabled = options.verbose || (!options.json && !options.disableLogging);
        options.wait = +(options.wait || constants.DEFAULT_MDAPI_WAIT_MINUTES);
        return BBPromise.resolve()
            .then(result => this._doDeployStatus(options))
            .then(result => this._throwErrorIfDeployFailed(result))
            .catch((err) => {
            if (err.name === 'sf:MALFORMED_ID') {
                throw almError('mdDeployCommandCliInvalidJobIdError', options.jobid);
            }
            else {
                throw err;
            }
        });
    }
    validate(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = context.flags;
            let stashedValues = yield Stash.list(Stash.Commands.MDAPI_DEPLOY);
            if (!options.jobid) {
                options.jobid = options.jobid || stashedValues.jobid;
            }
            if (!options.jobid) {
                return BBPromise.reject(almError('MissingRequiredParameter', 'jobid'));
            }
            // Wait must be a number that is greater than zero or equal to -1.
            const validWaitValue = !isNaN(+options.wait) && (+options.wait === -1 || +options.wait >= 0);
            if (options.wait && !validWaitValue) {
                return BBPromise.reject(almError('mdapiCliInvalidWaitError'));
            }
            return BBPromise.resolve(options);
        });
    }
    _doDeployStatus(options) {
        if (options.result && options.wait == 0 && !options.deprecatedStatusRequest) {
            // this will always be a timeout condition since we never call CheckStatus.handleStatus()
            options.result.timedOut = true;
            this._print.bind(this, options)(options.result);
            return options.result;
        }
        const jobid = options.jobid;
        const org = this.scratchOrg;
        return new CheckStatus(options.wait, constants.DEFAULT_MDAPI_POLL_INTERVAL_MILLISECONDS, this._print.bind(this, options), org.force.mdapiCheckDeployStatus.bind(org.force, org, jobid), this.pollIntervalStrategy).handleStatus();
    }
    _throwErrorIfDeployFailed(result) {
        if (result.status === 'Failed') {
            const err = almError('mdapiDeployFailed');
            this._setExitCode(DEPLOY_ERROR_EXIT_CODE);
            err.result = result;
            return BBPromise.reject(err);
        }
        return BBPromise.resolve(result);
    }
    _setExitCode(code) {
        process.exitCode = code;
    }
}
module.exports = MdDeployReportApi;

//# sourceMappingURL=mdapiDeployReportApi.js.map
