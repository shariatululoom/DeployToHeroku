"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
const _ = require("lodash");
const os = require("os");
const messages = require("../messages");
const almError = require("../almError");
const Alias = require("../alias");
const command_1 = require("../command");
const user_1 = require("./user");
const { getMessage } = messages();
class UserPasswordGenerateCommand extends command_1.default {
    constructor() {
        super('user:password:generate');
    }
    validate(context) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            // verify we have an org.  can't do anything without an org
            if (!context.org) {
                throw almError({ keyName: 'noOrgProvided', bundle: 'generatePassword' });
            }
            // verify that the org is a scratch org
            return context.org.checkScratchOrg(context.flags.defaultdevhubusername)
                .then(() => { this.org = context.org; })
                .then(() => _super("validate").call(this, context));
        });
    }
    execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
            this.usernames = _.map((_.get(context, 'flags.onbehalfof') || this.org.getName()).split(','), _.trim);
            // Convert any aliases to usernames
            const aliases = yield Alias.list();
            this.usernames = this.usernames.map(username => aliases[username] || username);
            let users = yield user_1.default.fetchUsers(this.org, this.usernames);
            // Generate and set passwords for all users
            users = yield Promise.all(users.map(user => user.assignPassword()));
            // Build the password data object/array to return
            this.passwordData = users.length === 1 ?
                { password: users[0].password } :
                users.map(user => ({ username: user.getField('username'), password: user.password }));
            return Promise.resolve(this.passwordData);
        });
    }
    getHumanSuccessMessage(pwdData) {
        if (pwdData.password) {
            const successMsg = getMessage('success', [pwdData.password, this.usernames[0]], 'generatePassword');
            const viewMsg = getMessage('viewWithCommand', [this.usernames[0]], 'generatePassword');
            this.logger.log(`${successMsg}${os.EOL}${viewMsg}`);
        }
        else {
            this.logger.log(getMessage('successMultiple', undefined, 'generatePassword'));
            const columnData = { columns: [{ key: 'username', label: 'USERNAME' }, { key: 'password', label: 'PASSWORD' }] };
            this.logger.table(pwdData, columnData);
        }
    }
}
exports.UserPasswordGenerateCommand = UserPasswordGenerateCommand;
exports.default = UserPasswordGenerateCommand;

//# sourceMappingURL=userPasswordGenerateCommand.js.map
