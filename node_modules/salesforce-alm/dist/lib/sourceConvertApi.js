/*
 * Copyright (c) 2017, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
// Node
const path = require('path');
const util = require('util');
const os = require('os');
// 3pp
const optional = require('optional-js');
const Promise = require('bluebird');
const fs = Promise.promisifyAll(require('fs-extra'));
// Local
const SourceWorkspaceAdapter = require(path.join(__dirname, 'sourceWorkspaceAdapter'));
const TypeDefUtil = require(path.join(__dirname, 'typeDefUtil')).TypeDefUtil;
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const sourceState = require(path.join(__dirname, 'sourceState'));
const messages = require(path.join(__dirname, 'messages'))();
class SourceConvertApi {
    constructor(org, swa) {
        this.scratchOrg = org;
        const defaultPackagePath = this.scratchOrg.config.getAppConfig().defaultPackagePath;
        this.sourceWorkspaceAdapter = swa || new SourceWorkspaceAdapter(this.scratchOrg, defaultPackagePath, true, MetadataRegistry, true);
        this.projectDir = this.scratchOrg.config.getProjectPath();
    }
    doConvert(context) {
        return Promise.resolve()
            .then(() => {
            if (srcDevUtil.pathExistsSync(context.rootDir) === false) {
                throw new Error(messages.getMessage('invalidRootDirectory', [context.rootDir], 'sourceConvertCommand'));
            }
        })
            .then(() => this.sourceWorkspaceAdapter.getAggregateSourceElements(false, context.rootDir))
            .then(sourceElementsMap => {
            if (sourceElementsMap.size === 0) {
                throw (new Error(messages.getMessage('noSourceInRootDirectory', [], 'sourceConvertCommand')));
            }
            return sourceElementsMap;
        })
            .then(sourceElementsMap => this.convertSourceToMdapi(context.outputDir, context.packagename, sourceElementsMap, false, context.unsupportedMimeTypes));
    }
    convertSourceToMdapi(targetPath, packageName, aggregateSourceElementsMap, createDestructiveChangesManifest, unsupportedMimeTypes) {
        let destructiveChangesTypeNamePairs;
        let sourceElementsForMdDir;
        return Promise.resolve()
            .then(() => [...aggregateSourceElementsMap.values()])
            .then(aggregateSourceElements => {
            [destructiveChangesTypeNamePairs, sourceElementsForMdDir] = SourceConvertApi.sortSourceElementsForMdDeploy(aggregateSourceElements, this.sourceWorkspaceAdapter.metadataRegistry);
            return SourceConvertApi.populateMdDir(targetPath, sourceElementsForMdDir, unsupportedMimeTypes);
        })
            .then(() => {
            if (createDestructiveChangesManifest) {
                return this.scratchOrg.force.toolingFind(this.scratchOrg, 'SourceMember', { IsNameObsolete: true }, ['MemberType', 'MemberName'])
                    .then((sourceMembers) => {
                    destructiveChangesTypeNamePairs.forEach((descructiveChange, index) => {
                        if (!util.isNullOrUndefined(sourceMembers.find(sm => sm.MemberType === descructiveChange.type && sm.MemberName === descructiveChange.name))) {
                            destructiveChangesTypeNamePairs.splice(index, 1);
                        }
                        return []; // keep eslint happy
                    });
                })
                    .then(() => SourceConvertApi.createPackageManifests(targetPath, packageName, destructiveChangesTypeNamePairs, sourceElementsForMdDir, this.scratchOrg));
            }
            return SourceConvertApi.createPackageManifests(targetPath, packageName, [], sourceElementsForMdDir, this.scratchOrg);
        })
            .then(() => [sourceElementsForMdDir, destructiveChangesTypeNamePairs]);
    }
    /**
     * Sorts the source elements into those that should be added to the destructiveChangesPost.xml
     * and those that should be added to the package.xml
     * @param {Array} aggregateSourceElements - the updated aggregateSourceElements
     * @returns {[[],[]]} - the array of destructive changes and the array of elements to be added to the package.xml
     * @private
     */
    static sortSourceElementsForMdDeploy(aggregateSourceElements, metadataRegistry) {
        const destructiveChangeTypeNamePairs = [];
        const updatedSourceElements = [];
        aggregateSourceElements.forEach(aggregateSourceElement => {
            if (aggregateSourceElement.isDeleted() && !aggregateSourceElement.typeDef.deleteSupported) {
                return;
            }
            // if the whole source element should be deleted, then there's no need to process each pending workspace file
            const deleteAggregate = aggregateSourceElement.isDeleted() && !aggregateSourceElement.isRenamed() && (!aggregateSourceElement.typeDef.hasStandardMembers || aggregateSourceElement.getAggregateFullName().includes('__'));
            if (deleteAggregate) {
                destructiveChangeTypeNamePairs.push({
                    type: aggregateSourceElement.typeDef.metadataName,
                    name: aggregateSourceElement.getAggregateFullName()
                });
            }
            else {
                let aggregateSourceElementWasChanged = false;
                if (!TypeDefUtil.hasIndividuallyAddressableChildWorkspaceElements(metadataRegistry, aggregateSourceElement.typeDef)) {
                    aggregateSourceElementWasChanged = true;
                }
                else {
                    aggregateSourceElement.getWorkspaceElements().forEach(workspaceElement => {
                        if (!workspaceElement.getIsStandardMember() && workspaceElement.getState() === sourceState.DELETED && workspaceElement.getTypeDef().isAddressable && !aggregateSourceElement.isRenamed()) {
                            destructiveChangeTypeNamePairs.push({
                                type: workspaceElement.getTypeDef().metadataName,
                                name: workspaceElement.getFullName()
                            });
                        }
                        else {
                            aggregateSourceElementWasChanged = true;
                        }
                    });
                }
                if (aggregateSourceElementWasChanged) {
                    updatedSourceElements.push(aggregateSourceElement);
                }
            }
        });
        return [destructiveChangeTypeNamePairs, updatedSourceElements];
    }
    static populateMdDir(targetPath, aggregateSourceElements, unsupportedMimeTypes) {
        // Create the metadata deploy root directory
        srcDevUtil.ensureDirectoryExistsSync(targetPath);
        const decompositionDir = path.join(os.tmpdir(), `decomposition_${Date.now()}`);
        srcDevUtil.ensureDirectoryExistsSync(decompositionDir);
        const translationsMap = {};
        return Promise.map(aggregateSourceElements, element => {
            const translations = element.getFilePathTranslations(targetPath, decompositionDir, unsupportedMimeTypes);
            return Promise.map(translations, translation => {
                // check for duplicates since fs.copyAsync will throw an EEXIST error on duplicate files/dirs
                if (util.isNullOrUndefined(translationsMap[translation.mdapiPath])) {
                    translationsMap[translation.mdapiPath] = translation.sourcePath;
                    return Promise.resolve(translation.sourcePath)
                        .then((sourcePath) => fs.copyAsync(sourcePath, translation.mdapiPath));
                }
                else {
                    return Promise.resolve();
                }
            }).catch((err) => {
                this.revert = true;
                this.err = err;
            });
        })
            .then(() => {
            if (this.revert !== undefined) {
                fs.removeAsync(decompositionDir);
                srcDevUtil.deleteDirIfExistsSync(targetPath);
                throw this.err;
            }
            return fs.removeAsync(decompositionDir);
        });
    }
    static createPackageManifests(outputdir, packageName, destructiveChangesTypeNamePairs, updatedAggregateSourceElements, scratchOrg) {
        const keys = new Set();
        const updatedTypeNamePairs = updatedAggregateSourceElements.map(se => ({ type: se.typeDef.metadataName, name: se.getAggregateFullName(), workspaceElements: se.getWorkspaceElements() }))
            .reduce((typeNamePairs, typeNamePair) => {
            if (typeNamePair.type.endsWith('Folder')) {
                SourceConvertApi.addNoDupes(typeNamePairs, typeNamePair, keys);
            }
            else if (typeNamePair.type === 'StaticResource' || typeNamePair.type === 'AuraDefinitionBundle') {
                // add these types to the package.xml if anything within them has changed
                SourceConvertApi.addNoDupes(typeNamePairs, { type: typeNamePair.type, name: typeNamePair.name }, keys);
            }
            else {
                typeNamePair.workspaceElements.forEach(workspaceElement => {
                    const elementTypeDef = workspaceElement.getTypeDef();
                    if ((workspaceElement.getState() !== sourceState.DELETED) &&
                        elementTypeDef.isAddressable) {
                        SourceConvertApi.addNoDupes(typeNamePairs, { type: workspaceElement.getTypeDef().metadataName, name: workspaceElement.getFullName() }, keys);
                        if (TypeDefUtil.requiresIndividuallyAddressableMembersInPackage(elementTypeDef)) {
                            elementTypeDef.childXmlNames.forEach(childXmlName => {
                                SourceConvertApi.addNoDupes(typeNamePairs, { type: childXmlName, name: '*' }, keys);
                            });
                        }
                    }
                });
            }
            return typeNamePairs;
        }, []);
        const configSourceApiVersion = scratchOrg.config.getAppConfig().sourceApiVersion;
        const sourceApiVersion = optional.ofNullable(configSourceApiVersion).orElse(scratchOrg.config.getApiVersion());
        const ManifestCreateApi = require(path.join(__dirname, 'manifestCreateApi')); // eslint-disable-line global-require
        // TODO: This should come from source tracking database
        const manifestCreateApi = new ManifestCreateApi(scratchOrg);
        // Create the package.xml
        return manifestCreateApi.createManifest({ outputdir, sourceApiVersion }, packageName, updatedTypeNamePairs)
            .then(() => {
            if (destructiveChangesTypeNamePairs.length > 0) {
                // Create the destructiveChangesPost.xml
                return manifestCreateApi.createManifest({
                    outputdir,
                    sourceApiVersion,
                    outputfile: 'destructiveChangesPost.xml'
                }, packageName, destructiveChangesTypeNamePairs);
            }
            else {
                return Promise.resolve();
            }
        });
    }
    static addNoDupes(typeNamePairs, typeNamePair, keys) {
        const key = `${typeNamePair.type}#${typeNamePair.name}`;
        if (!keys.has(key)) {
            typeNamePairs.push(typeNamePair);
            keys.add(key);
        }
    }
}
module.exports = SourceConvertApi;

//# sourceMappingURL=sourceConvertApi.js.map
