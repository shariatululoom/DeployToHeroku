/*
 * Copyright, 1999-2016, salesforce.com
 * All Rights Reserved
 * Company Confidential
 */
'use strict';
const util = require('util');
const path = require('path');
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const sourceState = require(path.join(__dirname, 'sourceState'));
const logger = require(path.join(__dirname, 'logApi'));
const AggregateSourceElement = require(path.join(__dirname, 'aggregateSourceElement')).AggregateSourceElement;
const WorkspaceElement = require(path.join(__dirname, 'workspaceElement')).WorkspaceElement;
const TypeDefUtil = require(path.join(__dirname, 'typeDefUtil')).TypeDefUtil;
const messages = require(path.join(__dirname, 'messages'))();
/**
 * Utility to convert between metadata fullnames and workspace paths
 * @param sourceFileInfos - Source elements to manage
 * @private
 * @constructor
 */
function _SourceLocations(sourceFileInfos, metadataRegistry) {
    this.typeAndFullNameToMetadataPath = new Map();
    for (const sourceFileInfo of sourceFileInfos) {
        if (sourceFileInfo.isMetadataFile) {
            const typeDef = metadataRegistry.getTypeDefinitionByFileName(sourceFileInfo.sourcePath);
            if (!util.isNullOrUndefined(typeDef)) {
                let fullName = srcDevUtil.getFqnForPath(typeDef, sourceFileInfo.sourcePath, sourceFileInfo.isMetadataFile, metadataRegistry);
                if (typeDef.metadataName === 'AuraDefinitionBundle') {
                    fullName = path.dirname(fullName);
                }
                const typeAndFullName = `${typeDef.metadataName}__${fullName}`;
                const sourcePath = TypeDefUtil.getAggregateMetadataFilePathFromWorkspacePath(metadataRegistry, typeDef, sourceFileInfo.sourcePath);
                this.typeAndFullNameToMetadataPath.set(typeAndFullName, sourcePath);
            }
        }
    }
}
/**
 * Adapter between scratch org source metadata and a local workspace
 * @param {String} org - The org that the source workspace files belong to
 * @param {String} defaultPackagePath - The name of the default package path to which new source will be added
 * @param {Boolean} usingMdapi - true if using the mdapi false for tooling
 * @constructor
 */
function SourceWorkspaceAdapter(org, defaultPackagePath, usingMdapi, MetadataRegistry, fromConvert) {
    this.logger = logger.child('sourceWorkspaceAdapter');
    const SourcePathStatusManager = require(path.join(__dirname, 'sourcePathStatusManager')); // eslint-disable-line global-require
    this.spsm = new SourcePathStatusManager(org);
    this.metadataRegistry = new MetadataRegistry(org);
    this.sourceLocations = new _SourceLocations(this.spsm.workspacePathInfos.values(), this.metadataRegistry);
    this.wsPath = org.config.getProjectPath();
    this.namespace = org.config.getAppConfig().namespace;
    this.defaultSrcDir = path.join(this.wsPath, defaultPackagePath, 'main', 'default');
    this.fromMdapiConvert = fromConvert || false;
    this.forceIgnore = this.spsm.forceIgnore;
    this.defaultPackagePath = org.config.getAppConfig().defaultPackagePath;
    // mdapi:convert and source:convert do not need to load changed aggregate source elements.
    // The cache is specific to push, pull, status commands, but sourceWorkspaceAdapter is
    // initialized for all source-related commands 
    if (!this.fromMdapiConvert) {
        this.changedSourceElementsCache = this.getAggregateSourceElements(true);
    }
}
SourceWorkspaceAdapter.prototype.revertSourcePathInfos = function () {
    this.spsm.revert();
};
SourceWorkspaceAdapter.prototype.backupSourcePathInfos = function () {
    this.spsm.backup();
};
/**
 * private helper to log when a metadata type isn't supported
 * @param {string} metadataName - the metadata type name
 * @param {string} filePath - the filepath to the metadata item
 * @private
 */
const _logUnsupported = function (metadataName, filePath) {
    if (!util.isNullOrUndefined(filePath)) {
        this.logger.warn(`Unsupported source member ${metadataName} at ${filePath}`);
    }
    else {
        this.logger.warn(`Unsupported source member ${metadataName}`);
    }
};
/**
 * Get the source elements in the workspace
 * @param changesOnly - If true then return only the updated source elements (changed, new, or deleted)
 * @param packageDirectory - the package directory from which to fetch source
 * @returns {*{}} - Map of aggregate source element key to aggregateSourceElement
 * ex. { 'ApexClass__myApexClass' : aggregateSourceElement }
 */
SourceWorkspaceAdapter.prototype.getAggregateSourceElements = function (changesOnly, packageDirectory) {
    if (!changesOnly && this.allAggregateSourceElementsCache) {
        return this.allAggregateSourceElementsCache;
    }
    this.pendingSourcePathInfos = new Map();
    // Array of sourcePathInfos for directories
    this.pendingDirectories = [];
    const aggregateSourceElements = new Map();
    // Signify beta as undefined workspace version
    let workspaceVersion; // eslint-disable-line no-unused-vars
    // Retrieve all source which has changed locally
    const pendingChanges = this.spsm.getSourcePathInfos(changesOnly, packageDirectory);
    pendingChanges.forEach((change) => {
        // Skip the directories
        if (change.isDirectory) {
            this.pendingDirectories.push(change);
            return;
        }
        const aggregateTypeDef = this.metadataRegistry.getTypeDefinitionByFileName(change.sourcePath);
        // If this is isn't a source file skip it
        if (util.isNullOrUndefined(aggregateTypeDef)) {
            return;
        }
        // Does the metadata registry have this type blacklisted.
        if (!this.metadataRegistry.isSupported(aggregateTypeDef.metadataName)) {
            _logUnsupported.call(this, aggregateTypeDef, change.sourcePath);
            return;
        }
        const workspaceElementTypeDef = this.metadataRegistry.getTypeDefinitionByFileName(change.sourcePath, true);
        const aggregateFullName = TypeDefUtil.getAggregateFullNameForFilePath(this.metadataRegistry, workspaceElementTypeDef, change.sourcePath);
        const aggregateMetadataFilePath = TypeDefUtil.getAggregateMetadataFilePathFromWorkspacePath(this.metadataRegistry, aggregateTypeDef, change.sourcePath);
        const newAggregateSourceElement = new AggregateSourceElement(aggregateTypeDef, aggregateFullName, aggregateMetadataFilePath, this.metadataRegistry);
        const workspaceFullName = TypeDefUtil.getFullNameForFilePath(this.metadataRegistry, workspaceElementTypeDef, change.sourcePath);
        const isStandardMember = workspaceElementTypeDef.hasStandardMembers && !workspaceFullName.includes('__');
        const workspaceElement = new WorkspaceElement(workspaceElementTypeDef, workspaceFullName, change.sourcePath, change.state, isStandardMember);
        const key = newAggregateSourceElement.getKey();
        let aggregateSourceElement;
        if (aggregateSourceElements.has(key)) {
            aggregateSourceElement = aggregateSourceElements.get(key);
        }
        else {
            aggregateSourceElement = newAggregateSourceElement;
        }
        aggregateSourceElement.addWorkspaceElement(workspaceElement);
        aggregateSourceElements.set(key, aggregateSourceElement);
        this.pendingSourcePathInfos.set(change.sourcePath, change);
    });
    if (!changesOnly) {
        this.allAggregateSourceElementsCache = aggregateSourceElements;
    }
    return aggregateSourceElements;
};
/**
 * Commit pending changed file infos
 * @param sourceElements - Source elements to commit
 * @returns {boolean} - Was the commit successful
 */
SourceWorkspaceAdapter.prototype.commitPendingChanges = function () {
    if (util.isNullOrUndefined(this.pendingSourcePathInfos)
        && util.isNullOrUndefined(this.pendingDirectories)) {
        // getChanges or getAll must have been called prior to find the list
        //   of pending changes
        return false;
    }
    let pendingChanges = [];
    if (!util.isNullOrUndefined(this.pendingDirectories)) {
        pendingChanges = pendingChanges.concat(this.pendingDirectories);
    }
    this.pendingSourcePathInfos.forEach(pendingSourcePathInfo => {
        pendingChanges.push(pendingSourcePathInfo);
    });
    this.spsm.commitChangedPathInfos(pendingChanges);
    return true;
};
/**
 * Update the source stored in the workspace
 * @param sourceElements - Collection of source elements to update
 */
SourceWorkspaceAdapter.prototype.updateSource = function (sourceElements, force, sOrgApi, manifest, checkForDuplicates, unsupportedMimeTypes) {
    let updatedPaths = [];
    let deletedPaths = [];
    if (checkForDuplicates) {
        sourceElements.forEach(se => se.checkForDuplicates());
    }
    sourceElements.forEach(sourceElement => {
        const [newPathsForElements, updatedPathsForElements, deletedPathsForElements] = sourceElement.commit(manifest, unsupportedMimeTypes);
        updatedPaths = updatedPaths.concat(newPathsForElements, updatedPathsForElements);
        deletedPaths = deletedPaths.concat(deletedPathsForElements);
    });
    this.spsm.updateInfosForPaths(updatedPaths, deletedPaths);
    return sourceElements;
};
const _getSourceLocationKey = function (metadataType, fullName) {
    return `${metadataType}__${fullName}`;
};
const _getMetadataTypeFromFilePropertyAttributes = function (type, fullName, metadataRegistry) {
    if (type === 'AuraDefinition') {
        return metadataRegistry.typeDefs.AuraDefinitionBundle;
    }
    const typeDef = metadataRegistry.getTypeDefinitionByMetadataName(type);
    if (!util.isNullOrUndefined(typeDef) && typeDef.inFolder && fullName.split(path.sep).length === 1) {
        return typeDef.folderTypeDef;
    }
    return typeDef;
};
const _getMetadataTypeFromFileProperty = function (fileProperty, metadataRegistry) {
    return _getMetadataTypeFromFilePropertyAttributes(fileProperty.type, fileProperty.fullName, metadataRegistry);
};
const _isInFolderType = function (fileProperty) {
    return fileProperty.type === 'Document' || fileProperty.type === 'EmailTemplate'
        || fileProperty.type === 'Report' || fileProperty.type === 'Dashboard';
};
/**
 * Get the fullname from the file property filename for Territory2Model, Territory2Rule, and Territory2 entities
 * @param filePropertyFileName
 * @param typeDef
 * @param metadataRegistry
 * @returns {string}
 * @private
 */
const _getFullNameFromFileName = function (filePropertyFileName, typeDef, metadataRegistry) {
    if (metadataRegistry.typeDefs.Territory2Model.metadataName === typeDef.metadataName) {
        return path.basename(filePropertyFileName, `.${metadataRegistry.typeDefs.Territory2Model.ext}`);
    }
    else {
        // for Territory2 and Territory2Rule
        const modelName = filePropertyFileName.split('/')[2];
        const name = path.basename(filePropertyFileName).split('.')[0];
        return `${modelName}.${name}`;
    }
};
/**
 * Create a source element representation of a metadata change in the local workspace
 * @param fileProperty - The file property from the retrieve result
 * @returns {null} - A source element or null if metadataType is not supported
 */
SourceWorkspaceAdapter.prototype.processMdapiFileProperty = function (changedSourceElements, retrieveRoot, fileProperty, auraBundleFileProperties) {
    let fullName = _isInFolderType(fileProperty) ? fileProperty.fullName.split('.')[0] : fileProperty.fullName;
    let aggregateMetadataPath;
    if (!this.metadataRegistry.isSupported(fileProperty.type)) {
        return null;
    }
    const typeDef = _getMetadataTypeFromFileProperty(fileProperty, this.metadataRegistry);
    if ((typeDef.metadataName === this.metadataRegistry.typeDefs.SamlSsoConfig.metadataName || typeDef.metadataName === this.metadataRegistry.typeDefs.DuplicateRule.metadataName)
        && !util.isNullOrUndefined(this.namespace)) {
        fullName = fullName.replace(`${this.namespace}__`, '');
    }
    if (typeDef.metadataName === this.metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
        fullName = fullName.split(path.sep)[0];
    }
    // Territory2, Territory2Model, and Territory2Rule fileProperties have empty strings for fullNames
    if ((typeDef.metadataName === this.metadataRegistry.typeDefs.Territory2Model.metadataName ||
        typeDef.metadataName === this.metadataRegistry.typeDefs.Territory2.metadataName ||
        typeDef.metadataName === this.metadataRegistry.typeDefs.Territory2Rule.metadataName) &&
        fullName === '') {
        fullName = _getFullNameFromFileName(fileProperty.fileName, typeDef, this.metadataRegistry);
    }
    const aggregateTypeDef = !util.isNullOrUndefined(typeDef.parent) ? typeDef.parent : typeDef;
    aggregateMetadataPath = this.sourceLocations.getMetadataPath(typeDef.metadataName, fullName);
    if (!util.isNullOrUndefined(aggregateMetadataPath) && this.fromMdapiConvert && !this.defaultSrcDir.includes(this.defaultPackagePath) && !aggregateMetadataPath.includes(this.defaultSrcDir)) {
        // if user specified a destination folder outside the default package directory and
        // a file with same type and name exists but in a different pacakge directory then ignore it
        aggregateMetadataPath = null;
    }
    const deletedWorkspaceElements = [];
    if (typeDef.metadataName === this.metadataRegistry.typeDefs.Document.metadataName && !util.isNullOrUndefined(aggregateMetadataPath)) {
        const existingDocumentFilePath = TypeDefUtil.getContentPathWithNonStdExtFromMetadataPath(this.metadataRegistry, typeDef, aggregateMetadataPath);
        const existingDocumentFileTypeExtension = path.extname(existingDocumentFilePath).replace('.', '');
        const retrievedDocumentExtension = path.extname(fileProperty.fullName).replace('.', '');
        if (existingDocumentFileTypeExtension !== retrievedDocumentExtension) {
            const deletedWorkspaceElement = new WorkspaceElement(typeDef, fullName, existingDocumentFilePath, sourceState.DELETED, false);
            deletedWorkspaceElements.push(deletedWorkspaceElement);
        }
    }
    // If the metadata path wasn't found we will use the default source directory
    if (util.isNullOrUndefined(aggregateMetadataPath)) {
        aggregateMetadataPath = TypeDefUtil.getDefaultAggregateMetadataPath(fullName, aggregateTypeDef, this.defaultSrcDir, this.metadataRegistry, auraBundleFileProperties);
        // Add the new path to the location mapping
        this.sourceLocations.addMetadataPath(typeDef.metadataName, fullName, aggregateMetadataPath);
    }
    if (!(this.forceIgnore !== null && this.forceIgnore.denies(aggregateMetadataPath.substr(this.wsPath.length)))) {
        const aggregateFullName = TypeDefUtil.getAggregateFullNameForFilePath(this.metadataRegistry, aggregateTypeDef, aggregateMetadataPath);
        const newAggregateSourceElement = new AggregateSourceElement(aggregateTypeDef, aggregateFullName, aggregateMetadataPath, this.metadataRegistry);
        const key = AggregateSourceElement.getKeyFromMetadataNameAndFullName(aggregateTypeDef.metadataName, aggregateFullName);
        let aggregateSourceElement;
        if (changedSourceElements.has(key)) {
            aggregateSourceElement = changedSourceElements.get(key);
        }
        else {
            aggregateSourceElement = newAggregateSourceElement;
        }
        if (deletedWorkspaceElements.length > 0) {
            deletedWorkspaceElements.forEach(deletedElement => {
                aggregateSourceElement.addPendingDeletedWorkspaceElement(deletedElement);
            });
        }
        if (aggregateSourceElement.typeDef.hasContent) {
            let hasMetadata = true;
            if (aggregateSourceElement.typeDef.metadataName === this.metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
                const auraTypeDef = this.metadataRegistry.getLightningDefByFileName(fileProperty.fileName);
                if (!auraTypeDef.hasMetadata) {
                    hasMetadata = false;
                }
            }
            if (hasMetadata) {
                const filename = `${fileProperty.fileName}${this.metadataRegistry.metadataFileExt}`;
                const retrievedMetadataPath = path.join(retrieveRoot, filename);
                if (srcDevUtil.pathExistsSync(retrievedMetadataPath)) {
                    aggregateSourceElement.retrievedMetadataPath = retrievedMetadataPath;
                }
                else {
                    // W-3903546 older AuraDefinitionBundles do not require a -meta.xml file
                    if (aggregateSourceElement.typeDef.metadataName !== this.metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName) {
                        const err = new Error();
                        err.name = 'Missing metadata file';
                        err.message = messages.getMessage('MissingMetadataFile', retrievedMetadataPath);
                        throw err;
                    }
                }
            }
            const retrievedContentPath = path.join(retrieveRoot, fileProperty.fileName);
            if (srcDevUtil.pathExistsSync(retrievedContentPath)) {
                if (util.isNullOrUndefined(aggregateSourceElement.retrievedContentPaths)) {
                    aggregateSourceElement.retrievedContentPaths = [];
                }
                aggregateSourceElement.retrievedContentPaths.push(retrievedContentPath);
            }
        }
        else {
            let retrievedFilePath = path.join(retrieveRoot, fileProperty.fileName);
            if (typeDef.metadataName.endsWith('Folder') && !retrievedFilePath.endsWith(this.metadataRegistry.metadataFileExt)) {
                retrievedFilePath = `${retrievedFilePath}${this.metadataRegistry.metadataFileExt}`;
            }
            if (srcDevUtil.pathExistsSync(retrievedFilePath)) {
                aggregateSourceElement.retrievedMetadataPath = retrievedFilePath;
            }
        }
        changedSourceElements.set(key, aggregateSourceElement);
        return aggregateSourceElement;
    }
    return null;
};
/**
 * Create a source element representation of a deleted metadata change in the local workspace
 * @param obsoleteName - The obsolete item, a map of full name and type
 * @returns {null} - A source element or null if metadataType is not supported
 */
SourceWorkspaceAdapter.prototype.handleObsoleteSource = function (changedSourceElements, fullName, type) {
    const sourceMemberTypeDef = _getMetadataTypeFromFilePropertyAttributes(type, fullName, this.metadataRegistry); // should really be "getTypeDefFromSourceMemberType()"
    const aggregateTypeDef = !util.isNullOrUndefined(sourceMemberTypeDef.parent) ? sourceMemberTypeDef.parent : sourceMemberTypeDef; // should really be "getAggregateTypeDefFromSourceMemberType()"
    const aggregateFullName = TypeDefUtil.getAggregateFullNameFromSourceMemberName(this.metadataRegistry, sourceMemberTypeDef, fullName);
    const metadataPath = this.sourceLocations.getMetadataPath(aggregateTypeDef.metadataName, aggregateFullName);
    if (metadataPath !== undefined) {
        const key = AggregateSourceElement.getKeyFromMetadataNameAndFullName(aggregateTypeDef.metadataName, aggregateFullName);
        let aggregateSourceElement;
        if (changedSourceElements.has(key)) {
            aggregateSourceElement = changedSourceElements.get(key);
        }
        else {
            aggregateSourceElement = new AggregateSourceElement(aggregateTypeDef, aggregateFullName, metadataPath, this.metadataRegistry);
        }
        const deletedTypeMatchesAggregateSourceType = type === aggregateSourceElement.typeDef.metadataName;
        if (deletedTypeMatchesAggregateSourceType) {
            aggregateSourceElement.markForDelete();
        }
        else {
            const sourcePathsToDelete = aggregateSourceElement.getWorkspacePathsForTypeAndFullName(sourceMemberTypeDef, fullName);
            sourcePathsToDelete.forEach(sourcePathToDelete => {
                const deletedWorkspaceElement = new WorkspaceElement(sourceMemberTypeDef, fullName, sourcePathToDelete, sourceState.DELETED, false);
                aggregateSourceElement.addPendingDeletedWorkspaceElement(deletedWorkspaceElement);
            });
        }
        changedSourceElements.set(key, aggregateSourceElement);
        return aggregateSourceElement;
    }
    return null;
};
/**
 * Get the metadata file path for a fullname
 * @param metadataType - The type of the source
 * @param fullName - The SFDC fullname
 * @returns {path} - The path to the metadata file for the source
 */
_SourceLocations.prototype.getMetadataPath = function (metadataType, fullName) {
    return this.typeAndFullNameToMetadataPath.get(_getSourceLocationKey(metadataType, fullName));
};
/**
 * Add a metadata file path for a fullName
 * @param metadataType - The type of the source
 * @param fullName - The SFDC fullname
 * @param metadataPath - The path to the metadata file for the source
 */
_SourceLocations.prototype.addMetadataPath = function (metadataType, fullName, metadataPath) {
    this.typeAndFullNameToMetadataPath.set(_getSourceLocationKey(metadataType, fullName), metadataPath);
};
/**
 * Remove the metadata file path for fullName
 * @param metadataType - The type of the source
 * @param fullName - The SFDC fullname
 */
_SourceLocations.prototype.removeMetadataPath = function (metadataType, fullName) {
    this.typeAndFullNameToMetadataPath.delete(_getSourceLocationKey(metadataType, fullName));
};
module.exports = SourceWorkspaceAdapter;

//# sourceMappingURL=sourceWorkspaceAdapter.js.map
