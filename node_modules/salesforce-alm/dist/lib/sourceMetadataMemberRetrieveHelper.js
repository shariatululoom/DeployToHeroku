/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
// Node
const path = require('path');
const util = require('util');
// Thirdparty
const Promise = require('bluebird');
const fsx = require('fs-extra');
const parser = require('gitignore-parser');
// Local
const MdapiPackage = require(path.join(__dirname, 'mdapiPackage'));
const almError = require(path.join(__dirname, 'almError'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
/**
 * private helper to ensure the revision is a valid int.
 * @param {number} revision - the revision number
 * @returns {number} revision as a primitive integer
 * @private
 */
const _parseRevisionIntOrZero = function (revision) {
    let localRev = 0;
    if (srcDevUtil.isInt(revision)) {
        localRev = parseInt(revision);
    }
    return localRev;
};
const _parseEntityQualifiedMemberRequiringPlurals = function (memberType, memberName) {
    const parentEntity = memberName.split('.')[0];
    return Promise.resolve({ fullName: parentEntity, type: `${memberType}s` });
};
const _parseEntityQualifiedMemberRequiringWildcards = function (memberType, memberName) {
    const parentEntity = memberName.split('.')[0];
    return Promise.resolve({ fullName: `${parentEntity}.*`, type: memberType });
};
/**
 * Handling for special memberTypes/memberNames in SourceMember
 * @param {object} sourceMember - the SourceMember item containing the name to parse
 * @returns {Promise}
 * @private
 */
const _parseSourceMemberFormat = function (sourceMember) {
    const memberType = sourceMember.MemberType;
    const memberName = sourceMember.MemberName;
    if (util.isNullOrUndefined(memberType) || util.isNullOrUndefined(memberName)) {
        throw almError('fullNameIsRequired');
    }
    // Convert individually tracked members to the appropriate container.
    // All deletions become changes of the container.
    if (memberType === 'CustomLabel') {
        return Promise.resolve({ fullName: '*', type: 'CustomLabels' });
    }
    else if (memberType === 'AutoResponseRule' || memberType === 'AssignmentRule' || memberType === 'EscalationRule' || memberType === 'MatchingRule') {
        return _parseEntityQualifiedMemberRequiringPlurals(memberType, memberName);
    }
    else if (memberType === 'SharingOwnerRule' || memberType === 'SharingCriteriaRule' || memberType === 'SharingTerritoryRule') {
        return _parseEntityQualifiedMemberRequiringWildcards(memberType, memberName, sourceMember.IsNameObsolete);
    }
    const isNameObsolete = sourceMember.IsNameObsolete;
    return Promise.resolve({ fullName: memberName, type: memberType, obsoleteName: isNameObsolete });
};
/**
 * Helper that checks if the md item was set to obsolete in the org and returns true if so
 * @param mdApiItem
 * @returns {boolean} true - if the item is obsolete and should not be part of the md package
 * @private
 */
const _shouldExcludeFromMetadataPackage = function (mdApiItem, obsoleteNames, metadataRegistry, forceIgnore) {
    let mdFullName = mdApiItem.fullName;
    // Aura Definition Bundle requires special handling
    if (mdApiItem.type === 'AuraDefinitionBundle') {
        const names = mdApiItem.fullName.trim().split(path.sep);
        mdFullName = names[0];
    }
    if (mdApiItem.obsoleteName) {
        obsoleteNames.push({ fullName: mdFullName, type: mdApiItem.type });
        return true;
    }
    // check if the entity is a supported type
    if (!metadataRegistry.isSupported(mdApiItem.type)) {
        return true;
    }
    if (forceIgnore != null) {
        // if user wants to ignore a permissionset with fullname abc then we check if forceignore accepts abc.permissionset
        const typeDef = metadataRegistry.getTypeDefinitionByMetadataName(mdApiItem.type);
        if (!util.isNullOrUndefined(typeDef)) {
            const filename = `${mdFullName}.${typeDef.ext}`;
            if (forceIgnore.denies(filename)) {
                return true;
            }
        }
    }
    return false;
};
/**
 * Class used to derive changed org metadata.
 */
class SourceMetadataMemberRetrieveHelper {
    constructor(metadataRegistry) {
        this.metadataRegistry = metadataRegistry;
        this.scratchOrg = metadataRegistry.org;
        this.force = this.scratchOrg.force;
        try {
            this.forceIgnore = parser.compile(fsx.readFileSync(path.join(this.scratchOrg.config.getProjectPath(), '.forceignore'), 'utf8'));
        }
        catch (err) {
            this.forceIgnore = null;
        }
    }
    /**
     * returns the last edit revision count on the scratch org.
     * @returns {Promise}
     */
    // TODO: We should be able to get this when we are querying the SourceMember initially.
    getLatestSourceRevisionCount() {
        const query = 'SELECT MAX(RevisionNum) maxRev from SourceMember';
        return this.force.toolingQuery(this.scratchOrg, query)
            .then((result) => {
            if (!util.isNullOrUndefined(result) && result.records.length > 0) {
                return Promise.resolve(result.records[0].maxRev);
            }
            return Promise.reject(almError('invalidResponseFromQuery', [query]));
        });
    }
    /**
     * gets all source metadata revisions from the server from <fromRevision>.
     * @param {number} fromRevision - get all changes after this revision number
     * @returns
     * "Package": {
     *   "$": {
     *     "xmlns": "http://soap.sforce.com/2006/04/metadata"
     *   },
     *   "types": [
     *     {
     *       "name": "ApexClass",
     *       "members": [...]
     *     },
     *     ...
     *   ],
     *   "version": 38
     *}
     */
    getRevisionsAsPackage(fromRevision, obsoleteNames) {
        const localFromRevision = _parseRevisionIntOrZero(fromRevision);
        const mdPackage = new MdapiPackage();
        const whereClause = { RevisionNum: { $gt: localFromRevision } };
        return this.force.toolingFind(this.scratchOrg, 'SourceMember', whereClause, ['MemberIdOrName', 'RevisionNum', 'MemberType', 'MemberName', 'IsNameObsolete'])
            .then((results) => {
            const parsePromises = results.map((element) => _parseSourceMemberFormat.call(this, element));
            return Promise.all(parsePromises);
        })
            .then((promisedResults) => {
            promisedResults.forEach((mdApiItem) => {
                if (mdApiItem !== null && !_shouldExcludeFromMetadataPackage.call(this, mdApiItem, obsoleteNames, this.metadataRegistry, this.forceIgnore)) {
                    mdPackage.addMember(mdApiItem.fullName, mdApiItem.type);
                }
            });
            return mdPackage;
        });
    }
}
module.exports = SourceMetadataMemberRetrieveHelper;

//# sourceMappingURL=sourceMetadataMemberRetrieveHelper.js.map
