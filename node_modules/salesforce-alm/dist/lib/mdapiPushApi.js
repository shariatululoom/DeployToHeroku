/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// 3pp
const optional = require('optional-js');
const Promise = require('bluebird');
// Node
const path = require('path');
const fs = Promise.promisifyAll(require('fs-extra'));
const os = require('os');
const util = require('util');
// Local
const logger = require(path.join('..', 'lib', 'logApi'));
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const MdapiPollIntervalStrategy = require(path.join(__dirname, 'mdapiPollIntervalStrategy'));
const messages = require(path.join(__dirname, 'messages'))();
const syncCommandHelper = require(path.join(__dirname, 'syncCommandHelper'));
const SrcStatusApi = require(path.join(__dirname, 'srcStatusApi'));
class MdapiPushApi {
    constructor(org) {
        this.scratchOrg = org;
        this.force = org.force;
        const appConfig = this.force.getConfig().getAppConfig();
        this.metadataRegistry = new MetadataRegistry(org);
        this.logger = logger.child('md-push');
        const usingMdapi = true;
        const SourceWorkspaceAdapter = require(path.join(__dirname, 'sourceWorkspaceAdapter')); // eslint-disable-line global-require
        this.swa = new SourceWorkspaceAdapter(this.scratchOrg, appConfig.defaultPackagePath, usingMdapi, MetadataRegistry);
        this.swa.backupSourcePathInfos();
    }
    doPush(options) {
        // Remove this when push has been modified to support the new mdapi wait functionality;
        if (isNaN(options.wait)) {
            options.wait = this.force.config.getConfigContent().defaultSrcWaitMinutes;
        }
        // Create a temp directory
        options.deploydir = optional.ofNullable(options.deploydir).orElse(path.join(os.tmpdir(), `mdpkg_${Date.now()}`));
        return Promise.resolve()
            .then(() => this._checkForConflicts(options))
            .then((changedAggregateSourceElements) => {
            if (changedAggregateSourceElements.size > 0) {
                const SourceConvertApi = require(path.join(__dirname, 'sourceConvertApi')); // eslint-disable-line global-require
                const sourceConvertApi = new SourceConvertApi(this.scratchOrg, this.swa);
                return sourceConvertApi.convertSourceToMdapi(options.deploydir, null, changedAggregateSourceElements, true /** createDestructiveChangesManifest **/, options.unsupportedMimeTypes)
                    .then(([sourceElementsToUpsert, deletedTypeNamePairs]) => {
                    const pollIntervalStrategy = new MdapiPollIntervalStrategy(sourceElementsToUpsert, deletedTypeNamePairs);
                    return this._mdapiPush(options, pollIntervalStrategy);
                })
                    .catch(err => {
                    if (err.name === 'mdapiDeployFailed') {
                        return err.result;
                    }
                    throw err;
                })
                    .then(result => MdapiPushApi._cleanUpTemp(options, result))
                    .then(result => this._processResults(result, changedAggregateSourceElements));
            }
            return Promise.resolve({ outboundFiles: [] });
        })
            .catch((err) => {
            this.swa.revertSourcePathInfos();
            throw err;
        });
    }
    _checkForConflicts(options) {
        if (options.forceoverwrite) {
            return this.swa.changedSourceElementsCache;
        }
        else {
            const statusApi = new SrcStatusApi(this.scratchOrg, this.swa);
            return statusApi.doStatus({ local: true, remote: true })
                .then(() => statusApi.getLocalConflicts())
                .catch((err) => {
                if (err.errorCode === 'INVALID_TYPE') {
                    const error = new Error(messages.getMessage('NonScratchOrgPush'));
                    error.name = 'NonScratchOrgPush';
                    throw error;
                }
                else {
                    throw err;
                }
            })
                .then((conflicts) => {
                if (conflicts.length > 0) {
                    const error = new Error('Conflicts found during push');
                    error.name = 'SourceConflict';
                    error.sourceConflictElements = conflicts;
                    throw error;
                }
                else {
                    return this.swa.changedSourceElementsCache; // if no conflicts return original elements to push
                }
            });
        }
    }
    _commitChanges() {
        if (!util.isNullOrUndefined(this.swa.pendingSourcePathInfos)) {
            return this.swa.commitPendingChanges();
        }
        return Promise.resolve(false);
    }
    _mdapiPush(options, pollIntervalStrategy) {
        // Push the source
        options.disableLogging = !util.isNullOrUndefined(options.disableLogging) ? options.disableLogging : true;
        // Deploy params (lowercase convert to camelcase in MdapiDeployApi)
        options.autoUpdatePackage = false;
        options.rollbackonerror = !util.isNullOrUndefined(options.rollbackonerror) ? options.rollbackonerror : true;
        options.testlevel = options.testlevel || 'NoTestRun';
        const MdapiDeployApi = require(path.join(__dirname, 'mdapiDeployApi')); // eslint-disable-line global-require
        return new MdapiDeployApi(this.scratchOrg, pollIntervalStrategy).deploy(options);
    }
    _processResults(result, changedAggregateSourceElements) {
        // Update deleted items even if the deploy fails so the worksapce is consistent
        this.swa.updateSource(changedAggregateSourceElements, undefined, undefined);
        // We need to check both success and status because a status of 'SucceededPartial' returns success === true even though rollbackOnError is set.
        if (result.success && result.status === 'Succeeded') {
            return Promise.resolve(this._commitChanges()).then(() => {
                let deployedWorkspaceElements = [];
                changedAggregateSourceElements.forEach((changedAggregateSourceElement) => {
                    deployedWorkspaceElements = deployedWorkspaceElements.concat(changedAggregateSourceElement.getWorkspaceElements());
                });
                const outboundFiles = deployedWorkspaceElements.map(workspaceElement => ({
                    state: workspaceElement.getState(),
                    fullName: workspaceElement.getFullName(),
                    type: workspaceElement.getTypeDef().metadataName,
                    filePath: workspaceElement.getSourcePath(),
                    isStandardMember: workspaceElement.getIsStandardMember()
                }));
                result.outboundFiles = outboundFiles;
                return Promise.resolve(result);
            });
        }
        else {
            const deployFailed = new Error();
            if (result.timedOut) {
                deployFailed.name = 'PollingTimeout';
            }
            else {
                deployFailed.name = 'DeployFailed';
                deployFailed.failures = syncCommandHelper.getDeployFailures(result, this.swa.getAggregateSourceElements(false));
            }
            return Promise.reject(deployFailed);
        }
    }
    static _cleanUpTemp(options, result) {
        // Remove the temp directory and zip file
        return options.debug ? Promise.resolve(result) : Promise.all([fs.removeAsync(options.deploydir), fs.removeAsync(`${options.deploydir}.zip`)])
            .then(() => result);
    }
}
module.exports = MdapiPushApi;

//# sourceMappingURL=mdapiPushApi.js.map
