/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
const path = require('path');
const _ = require('lodash');
const almError = require(path.join(__dirname, '..', 'almError'));
const consts = require(path.join(__dirname, '..', 'constants'));
const logger = require(path.join(__dirname, '..', 'logApi'));
const messages = require(path.join(__dirname, '..', 'messages'));
const { Time } = require(path.join(__dirname, '..', 'time'));
const ApexTestApi = require(path.join(__dirname, '..', 'apex', 'apexTestApi'));
const ApexCacheService = require(path.join(__dirname, '..', 'apex', 'apexPreCompile'));
const Promise = require('bluebird');
const _socketTimeoutHandler = function (message, api) {
    if (!_.isNil(api.testrunid)) {
        throw almError('genericTimeoutMessage', [], 'genericTimeoutCommandWaitMessageAction', [`force:apex:test:report -i ${api.testrunid}`]);
    }
    else {
        throw almError('genericTimeoutMessage', [], 'genericTimeoutWaitMessageAction');
    }
};
class ApexTestCommand {
    constructor() {
        this.logger = logger.child('ApexTestCommand');
    }
    validate(context) {
        this.org = context.org;
        const options = context.flags;
        if (options.codecoverage && !options.resultformat) {
            return Promise.reject(almError('CoverageWithoutReporter'));
        }
        // Check of precompilewait is specified.
        if (options.precompilewait) {
            // if so validate it's a number
            if (!_.isNaN(_.toNumber(options.precompilewait))) {
                // normalize to milliseconds. Minutes is appropriate for the UI but millis is appropriate for the service.
                options.precompilewait = new Time(options.precompilewait).milliseconds;
            }
            else {
                return Promise.reject(almError({ keyName: 'invalidTimeout', bundle: 'apexPreCompileCommand' }, 
                // error message should specify minutes not millis.
                consts.DEFAULT_TIMEOUT.minutes));
            }
        }
        // validate against the api service
        if (options.precompilewait && options.precompilewait <= ApexCacheService.DEFAULT_TIMEOUT) {
            return Promise.reject(almError({ keyName: 'invalidTimeout', bundle: 'apexPreCompileCommand' }, 
            // error message should specify minutes not millis.
            consts.DEFAULT_TIMEOUT.minutes));
        }
        // Display deprecation message when resultformat flag is used without a wait flag
        if (options.resultformat && !options.wait) {
            logger.warnUser(context, messages().getMessage('apexTestCommandResultFormatDeprecation', [], 'apex'));
        }
        if (options.synchronous && !options.resultformat) {
            options.resultformat = 'human';
        }
        return Promise.resolve(options);
    }
    execute(context) {
        const testApi = new ApexTestApi(this.org);
        testApi.waitInMinutes = context.wait;
        testApi.socketTimeoutHandler = _socketTimeoutHandler;
        // context.precompilewait is converted to millis in validate.
        const precompileTimeout = context.precompilewait || ApexCacheService.DEFAULT_TIMEOUT;
        return testApi.initialize(context)
            .then(() => new ApexCacheService(this.org, precompileTimeout)
            .precompileSync()
            .catch((err) => {
            // Due to the limited states that are returned from the apex cache service. We will just let the apex
            // tests run if any error is returned from the service.
            this.logger.info('ApexCacheService reported an error. Continuing to run the tests.');
            this.logger.info(err.message);
            return null;
        }))
            .then(() => testApi.runTests())
            .then(res => {
            // If any tests failed, change the exit code to 100
            if (_.get(res, 'summary.failing')) {
                process.exitCode = 100;
            }
            return res;
        });
    }
}
module.exports = ApexTestCommand;

//# sourceMappingURL=apexTestCommand.js.map
