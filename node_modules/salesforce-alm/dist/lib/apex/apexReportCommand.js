/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
const path = require('path');
const Promise = require('bluebird');
const _ = require('lodash');
const almError = require(path.join(__dirname, '..', 'almError'));
const messages = require(path.join(__dirname, '..', 'messages'))();
const ApexTestApi = require(path.join(__dirname, 'apexTestApi'));
const _socketTimoeoutHandler = function () {
    throw almError('genericTimeoutMessage', [], 'genericTimeoutWaitMessageAction');
};
class ApexReportCommand {
    reject(...args) {
        const msg = messages.getMessage(...args);
        return Promise.reject(new Error(msg));
    }
    validate(context) {
        this.org = context.org;
        const testId = context.flags.testrunid;
        if (_.isNil(testId)) {
            return this.reject('apexReportCommandNoJobId');
        }
        // validate prefix of job id
        if (!/^707/.test(testId)) {
            return this.reject('apexReportCommandInvalidJobId', testId);
        }
        return Promise.resolve(context.flags);
    }
    /**
     * Retrieve test results.
     *
     * @param {object} context - Options object having following flags/inputs:
     *      - runTestId (array, required): Run test job id.
     *      - testArtifactDir (string):          file and path to log output
     *      - codeCoverage (boolean):      true to retrieve code coverage results
     */
    execute(context) {
        const testApi = new ApexTestApi(this.org);
        testApi.waitInMinutes = context.wait;
        testApi.socketTimeoutHandler = _socketTimoeoutHandler;
        // Set the default
        if (!context.resultformat) {
            context.resultformat = 'human';
        }
        return testApi.initialize(context)
            .bind(testApi)
            .then(testApi.jobCheck)
            .then(job => {
            const promise = Promise.resolve();
            promise.then(() => testApi.reporter.emit('start', job.Id));
            return promise.then(() => job);
        })
            .then(job => {
            if (job.Status === 'Completed') {
                testApi.finished = true;
                // If we want to check the progress of the tests as
                // they are running, we can move this check outside of
                // this conditional.
                return testApi.checkProgress();
            }
            else {
                testApi.socketTimeoutHandler = _socketTimoeoutHandler;
                const waitTillConnected = testApi.waitForResult();
                const waitTillDone = testApi.finish;
                // After waiting for the results via streaming, check the job again
                // to make sure it didn't complete in the time it took us to connect
                return waitTillConnected
                    .then(() => testApi.jobCheck())
                    .then(job2 => {
                    if (job2.Status === 'Completed') {
                        testApi.finished = true;
                        testApi.stream.disconnect();
                        return testApi.checkProgress();
                    }
                    else {
                        return waitTillDone;
                    }
                });
            }
        })
            .then(res => {
            // If any tests failed, change the exit code to 100
            if (_.get(res, 'summary.failing')) {
                process.exitCode = 100;
            }
            return res;
        });
    }
}
module.exports = ApexReportCommand;

//# sourceMappingURL=apexReportCommand.js.map
