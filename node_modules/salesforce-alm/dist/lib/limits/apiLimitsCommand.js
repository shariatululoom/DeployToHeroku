"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Config = require("../../lib/force-cli-config");
const Error = require("../../lib/force-cli-error");
const Display = require("../../lib/force-cli-display");
const logApi = require("../logApi");
const util = require("util");
let logger;
class ApiLimitsCommand {
    constructor() {
        logger = logApi.child('limits:api:display');
    }
    validate(context) {
    }
    execute(context, doneCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let conn = yield Config.getActiveConnection(context);
                let geturl = util.format('%s/services/data/v%s/limits', conn.instanceUrl, conn.version);
                let limits;
                yield conn.requestGet(geturl, function (err, response) {
                    if (err) {
                        logger.error(err);
                        Error.exitWithMessage(err.message);
                    }
                    limits = exports.parseResponse(response);
                    Display.apiLimits(limits);
                });
                return limits;
            }
            catch (err) {
                logger.error(err);
                Error.exitWithMessage(err.message);
            }
        });
    }
}
exports.ApiLimitsCommand = ApiLimitsCommand;
/**
 * constructs ApiLimit objects from server response
 * exposed for unit testing
 * @param {Object} response
 * @returns {ApiLimit[]}
 */
exports.parseResponse = function (response) {
    let limits = [];
    for (let limitName in response) {
        if (response.hasOwnProperty(limitName)) {
            limits.push({
                name: limitName,
                max: response[limitName]['Max'],
                remaining: response[limitName]['Remaining'],
            });
        }
    }
    return limits;
};

//# sourceMappingURL=apiLimitsCommand.js.map
