"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResponseParser = require("../../lib/force-cli-responseParser");
const Display = require("../../lib/force-cli-display");
const Error = require("../../lib/force-cli-error");
const Config = require("../../lib/force-cli-config");
const Messages = require("../../lib/force-cli-messages");
const logApi = require("../logApi");
const fs = require("fs");
const util = require("util");
const readline = require("readline");
const soapTemplate = `<env:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"
		xmlns:cmd="http://soap.sforce.com/2006/08/apex"
		xmlns:apex="http://soap.sforce.com/2006/08/apex">
			<env:Header>
				<cmd:SessionHeader>
					<cmd:sessionId>%s</cmd:sessionId>
				</cmd:SessionHeader>
				%s
			</env:Header>
			<env:Body>
				<%s xmlns="http://soap.sforce.com/2006/08/apex">
				    %s
				</%s>
			</env:Body>
		</env:Envelope>`;
let logger;
class ApexExecuteCommand {
    constructor() {
        logger = logApi.child('apex:execute');
    }
    validate(context) {
    }
    execute(context, doneCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (context.flags.apexcodefile === undefined) {
                return yield exports.apexFromUserInput(context, doneCallback);
            }
            else if (context.flags.apexcodefile) {
                return yield exports.apexFromFile(context, doneCallback);
            }
            else {
                Error.exitDisplayHelp(context.command);
            }
        });
    }
}
exports.ApexExecuteCommand = ApexExecuteCommand;
/**
 * get apex code from stdin when no filepath arg provided
 * exposed for unit testing (mocked)
 */
exports.apexFromUserInput = function (context, doneCallback) {
    Display.info(Messages.get('ApexExecTypingPrompt'));
    return new Promise((resolve, reject) => {
        let readInterface = readline.createInterface(process.stdin, process.stdout);
        let apexCode = '';
        readInterface.on('line', function (input) {
            apexCode = apexCode + input + '\n';
        });
        readInterface.on('close', function () {
            return __awaiter(this, void 0, void 0, function* () {
                yield exports.execute(context, apexCode, function (response) {
                    exports.handleResult(ResponseParser.getExecuteAnonymousResponse(response), ResponseParser.getDebugInfo(response), resolve);
                });
            });
        });
    });
};
/**
 *  get apex code from provided file
 *  exposed for unit testing (mocked)
 *  @param {string} filepath - file containing apex code
 */
exports.apexFromFile = function (context, doneCallback) {
    return new Promise((resolve, reject) => {
        fs.readFile(context.flags.apexcodefile, (err, data) => __awaiter(this, void 0, void 0, function* () {
            if (err) {
                return reject(err);
            }
            yield exports.execute(context, data.toString(), function (response) {
                exports.handleResult(ResponseParser.getExecuteAnonymousResponse(response), ResponseParser.getDebugInfo(response), resolve);
            });
        }));
    });
};
/**
 * creates and sends SOAP request
 * exposed for unit testing
 * @param {string} apexCode - code to debug
 * @param {function} callback - function that accepts the xml response from the server
 */
exports.execute = function (context, apexCode, callback) {
    return __awaiter(this, void 0, void 0, function* () {
        // fetch saved connection to send the execute request on
        try {
            const connection = yield Config.getActiveConnection(context);
            // create the exec anonymous request
            const action = 'executeAnonymous';
            const debugHeader = '<apex:DebuggingHeader><apex:debugLevel>DEBUGONLY</apex:debugLevel></apex:DebuggingHeader>';
            let actionBody = '<apexcode><![CDATA[%s]]></apexcode>';
            actionBody = util.format(actionBody, apexCode);
            const postEndpoint = connection.instanceUrl + '/services/Soap/s/' + connection.version + '/' + connection.accessToken.split('!')[0];
            const requestHeaders = {
                'Content-Type': 'text/xml',
                soapaction: action,
            };
            const request = {
                method: 'POST',
                url: postEndpoint,
                body: util.format(soapTemplate, connection.accessToken, debugHeader, action, actionBody, action),
                headers: requestHeaders
            };
            const postOptions = {
                headers: Object.assign({}, requestHeaders)
            };
            let response = yield connection.request(request, postOptions)
                .catch(function (err) {
                logger.error(err);
                return Error.exitWithMessage(err.message);
            });
            callback(response);
        }
        catch (err) {
            logger.error(err);
            return Error.exitWithMessage(err.message);
        }
    });
};
/**
 *  output results to user
 *  exposed for unit testing
 *  @param {ExecuteAnonymousResult} result
 *  @param {string} debugInfo
 */
exports.handleResult = function (result, debugInfo, doneCallback) {
    // check for compile errors
    if (result.compiled) {
        Display.success(Messages.get('ApexExecCompileSuccess'));
    }
    else {
        Display.failure(Messages.get('ApexExecCompileFailed'));
        let errMsg = Messages.get('ApexExecCompileFailedErrorMessage', result.line, result.column, result.compileProblem);
        Error.errorMessage(errMsg);
    }
    // check for runtime erorrs
    if (result.success) {
        Display.success(Messages.get('ApexExecExecutionSuccess'));
        Display.info(debugInfo);
    }
    else {
        Display.failure(Messages.get('ApexExecExecutionFailure'));
        if (result.exceptionMessage) {
            Error.errorMessage(result.exceptionMessage);
        }
        if (result.exceptionStackTrace) {
            Error.errorMessage(result.exceptionStackTrace);
        }
    }
    if (doneCallback) {
        doneCallback(Object.assign(result, { logs: debugInfo }));
    }
};

//# sourceMappingURL=apexExecuteCommand.js.map
