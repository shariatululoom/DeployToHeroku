/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const varargsCommand_1 = require("./varargsCommand");
// Node
const fs = require('fs');
const path = require('path');
// Thirdparty
const Bluebird = require('bluebird');
const _ = require('lodash');
// Local
const Org = require(path.join(__dirname, 'scratchOrgApi'));
const ScratchOrgInfoApi = require(path.join(__dirname, 'scratchOrgInfoApi'));
const StreamClient = require(path.join(__dirname, 'status'));
const consts = require(path.join(__dirname, 'constants'));
const Alias = require(path.join(__dirname, 'alias'));
const almError = require(path.join('..', 'lib', 'almError'));
const envTypes = require(path.join('..', 'lib', 'envTypes'));
const fs_readFile = Bluebird.promisify(fs.readFile);
const messages = require(path.join(__dirname, 'messages'))();
const srcDevUtil = require(path.join('..', 'lib', 'srcDevUtil'));
const scratchOrgInfoGenerator = require(path.join(__dirname, 'scratchOrgInfoGenerator'));
const defaultConnectedAppInfo = require(path.join(__dirname, 'defaultConnectedApp'));
const _ENV_TYPES = envTypes;
const _DEFAULT_ENV_TYPE = '';
const TOPIC = '/event/OrgLifecycleNotification';
const _getClientSecretError = function () {
    const error = new Error(messages.getMessage('ClientSecretRequired'));
    error.name = 'ClientSecretRequired';
    return error;
};
const _getClientSecret = function (stdinValues, org) {
    if (!_.isNil(stdinValues)) {
        // If the user provided anything via stdin, it has to be a non-null, non-whitespace secret.
        const clientSecret = stdinValues.get('secret');
        if (_.isNil(clientSecret) || _.isNil(clientSecret.trim())) {
            return Promise.reject(_getClientSecretError());
        }
        return Promise.resolve(clientSecret.trim());
    }
    else {
        // The user didn't provide a secret, so get it from the Hub config, if it exists.
        return org.getConfig()
            .then((hubOrgConfig) => {
            let hubOrgClientSecret = hubOrgConfig.clientSecret;
            if (!_.isNil(hubOrgClientSecret)) {
                hubOrgClientSecret = hubOrgClientSecret.trim();
                if (_.isNil(hubOrgClientSecret)) {
                    return Promise.reject(_getClientSecretError());
                }
                return hubOrgClientSecret;
            }
            else if (_.isNil(hubOrgConfig.privateKey)) {
                // The clientSecret and privateKey are both missing, using an access token so use the default connected app
                if (org.usingAccessToken) {
                    return defaultConnectedAppInfo.clientSecret;
                }
                return Promise.reject(_getClientSecretError());
            }
            else {
                // JWT OAuth flow. There'd better be a privateKey in the Hub, or else
                // we're going to have no way to authenticate into the resulting org.
                return null;
            }
        }).catch(err => Promise.reject(err));
    }
};
// A validator function to ensure any options parameters entered by the user adhere 
// to a whitelist of valid option settings. Because org:create allows options to be
// input either key=value pairs or within the definition file, this validator is
// executed within the ctor and also after parsing/normalization of the definition file.
const optionsValidator = (key, value) => {
    if (key.toLowerCase() === 'durationdays') {
        throw almError('unrecognizedScratchOrgOption', 'durationDays');
    }
};
/**
 * constructs a create command helper
 * @param force - the force api
 * @constructor
 */
class OrgCreateCommand extends varargsCommand_1.default {
    constructor() {
        super('org:create', [optionsValidator]);
        this.workspaceType = _DEFAULT_ENV_TYPE;
    }
    /**
     * secondary validation from the cli interface. this is a protocol style function intended to be represented by other
     * commands
     * @param context - this cli context
     * @returns {Promise}
     */
    validate(context) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            // validate varargs
            yield _super("validate").call(this, context);
            this.org = context.org;
            this.force = this.org.force;
            const fixedContext = srcDevUtil.fixCliContext(context);
            // Ensure we have an org config input source.
            if (!fixedContext.definitionjson && !fixedContext.definitionfile && !_.get(context, 'args.length')) {
                const message = messages.getMessage('cliForceCreateNoConfig');
                return Promise.reject(new Error(message));
            }
            if (!_.isNil(fixedContext.env) && !Object.hasOwnProperty.call(_ENV_TYPES, fixedContext.env)) {
                const envError = new Error(messages.getMessage('unsupportedValueForEnv', fixedContext.env));
                envError.name = 'UnsupportedValueForCreateEnv';
                return Promise.reject(envError);
            }
            if (!_.isNil(fixedContext.durationdays)) {
                const durationNum = parseFloat(fixedContext.durationdays);
                if (!_.isInteger(durationNum) || !_.inRange(durationNum, 1, 31)) {
                    throw almError('unsupportedValueForDuration', fixedContext.durationdays);
                }
            }
            return this.org.getConfig()
                .then(config => {
                // If the env flag is not specified and the url is not an internal salesforce url.
                if (_.isNil(fixedContext.env) && !srcDevUtil.isInternalUrl(config.instanceUrl)) {
                    fixedContext.env = _ENV_TYPES.sandbox;
                }
                this.workspaceType = fixedContext.env || this.workspaceType;
                return fixedContext;
            })
                .catch(e => {
                if (e.name === 'InvalidProjectWorkspace' && !fixedContext.targetdevhubusername) {
                    const newErrorKey = 'NoWorkspaceOrUser';
                    e.name = newErrorKey;
                    e.message = messages.getMessage('NoWorkspaceOrUser');
                }
                throw e;
            });
        });
    }
    _streamingCallback(message, asyncStatusClient, scratchOrgInfoId, resolve, reject) {
        // This happens if the stream listener is aborted.
        // We will report back to the user, understanding there is no auth stored for this org because of the
        // timeout. Without a password or token this org is basically in an abandsrc/lib/scratchOrgCreateCommand.jssrc/lib/scratchOrgCreateCommand.jsoned state.
        if (!_.isNil(message.errorName) && message.errorName === consts.LISTENER_ABORTED_ERROR_NAME) {
            if (!_.isNil(scratchOrgInfoId)) {
                return reject(almError('genericTimeoutMessage', [], 'genericTimeoutCommandWaitMessageAction', [`sfdx force:data:soql:query -q "SELECT Status FROM ScratchOrgInfo WHERE Id='${scratchOrgInfoId}'"`]));
            }
            else {
                return reject(almError('genericTimeoutMessage', [], 'genericTimeoutWaitMessageAction'));
            }
        }
        if (message.payload.LifecycleRequestId === scratchOrgInfoId) {
            if (message.payload.Status === 'Active') {
                asyncStatusClient.disconnect();
                return resolve(message.payload.LifecycleRequestId);
            }
            else if (message.payload.Status === 'Error') {
                asyncStatusClient.disconnect();
                const errorMessage = messages.getMessage('signupFailed', message.payload.StatusCode);
                const error = new Error(errorMessage);
                error.name = 'ScratchOrgInfoError';
                return reject(error);
            }
        }
        // Something we're not interested in but we don't want to resolve the promise yet.
        return undefined;
    }
    /**
     * executes the command. this is a protocol style function intended to be represented by other commands.
     * @param context - the cli context
     * @param stdinValues - param values obtained from stdin
     * @returns {Promise}
     */
    execute(context, stdinValues) {
        return __awaiter(this, void 0, void 0, function* () {
            const scratchOrgInfoApi = new ScratchOrgInfoApi(this.force, this.org);
            const scratchOrgApi = new Org(this.force);
            let scratchOrgInfo;
            const asyncStatusClient = new StreamClient(this.org);
            asyncStatusClient.waitInMinutes = context.wait;
            /**
             * This performs three functions.
             * 1) Setup a stream listener for a OrgLifecycleNotification
             * 2) Prepares the cli input for the scratchOrgInfo request
             * 3) Calls the server to create a scratchOrgInfo
             * @returns {Promise}
             * @private
             */
            const _promiseToCreateOrg = () => new Promise((resolve, reject) => {
                let scratchOrgInfoId;
                return this._getScratchOrgInfo(this.org, context)
                    .then((request) => {
                    scratchOrgInfo = request;
                    return asyncStatusClient.subscribe(TOPIC, (message) => this._streamingCallback(message, asyncStatusClient, scratchOrgInfoId, resolve, reject));
                })
                    .then(() => scratchOrgInfoApi.request(scratchOrgInfo))
                    .then((requestResponse) => {
                    scratchOrgInfoId = requestResponse.id;
                })
                    .catch(err => {
                    asyncStatusClient.disconnect();
                    return reject(err);
                });
            });
            // The outer promises are wrappers for the inner composite promises. Because of the stream listener and
            // the need to perform a retrieve (promise) inside the stream handler. The outer promises manage resolution or
            // rejection
            return new Promise((resolve, reject) => _promiseToCreateOrg()
                .then(scratchOrgInfoResultId => scratchOrgInfoApi.retrieveScratchOrgInfo(scratchOrgInfoResultId))
                .then(scratchOrgInfoResult => _getClientSecret(stdinValues, this.org)
                .then(clientSecret => {
                scratchOrgApi.alias = context.setalias;
                return scratchOrgInfoApi.processScratchOrgInfoResult(scratchOrgInfoResult, clientSecret, scratchOrgApi, !!context.setdefaultusername);
            }))
                .then(orgData => {
                const response = { orgId: orgData.orgId, username: scratchOrgApi.getName() };
                if (context.setalias) {
                    return Alias.set(context.setalias, scratchOrgApi.getName())
                        .then(() => resolve(response));
                }
                return resolve(response);
            })
                .catch(err => reject(err)));
        });
    }
    // Returns a valid signup json object
    _getScratchOrgInfo(masterOrg, context) {
        // Varargs input overrides definitionjson (-j option; hidden/deprecated)
        const definitionJson = context.definitionjson ? JSON.parse(context.definitionjson) : {};
        const orgConfigInput = Object.assign(definitionJson, this.keyValuePairs || {});
        let scratchOrgInfoPayloadPromise;
        // the -f option
        if (context.definitionfile) {
            scratchOrgInfoPayloadPromise = fs_readFile(context.definitionfile)
                .then(defFileContents => Object.assign({}, JSON.parse(defFileContents), orgConfigInput))
                .catch(err => {
                err = srcDevUtil.processReadAndParseJsonFileError(err, context.definitionfile);
                return Promise.reject(err);
            });
        }
        else {
            scratchOrgInfoPayloadPromise = Bluebird.resolve(orgConfigInput);
        }
        return scratchOrgInfoPayloadPromise
            .then((scratchOrgInfoPayload) => {
            // Verify that the scratchOrgInfoPayload does not have upper case keys; throw if it does.  Must be heads down camelcase.
            const upperCaseKey = srcDevUtil.findUpperCaseKeys(scratchOrgInfoPayload);
            if (upperCaseKey) {
                throw almError('InvalidJsonCasing', [upperCaseKey, JSON.stringify(scratchOrgInfoPayload, null, 4)]);
            }
            // Now run the fully resolved user input against the validator
            _.forEach(scratchOrgInfoPayload, (value, key) => optionsValidator(key, value));
            // the -i option
            if (!_.isNil(context.clientid)) {
                scratchOrgInfoPayload.connectedAppConsumerKey = context.clientid;
            }
            // the -d option
            if (!_.isNil(context.durationdays)) {
                scratchOrgInfoPayload.durationDays = context.durationdays;
            }
            return scratchOrgInfoGenerator.generateScratchOrgInfo(masterOrg, scratchOrgInfoPayload, 'scratch', context.nonamespace, context.noancestors);
        });
    }
    parseSignupErrorCode(err) {
        const messageToParse = err.name + err.errorCode + err.message;
        return messageToParse.match(/[A-Z]-[0-9]{4}/);
    }
    /**
     * returns a human readable message for cli output
     * @param org - the result oif execute
     * @returns {string}
     */
    getHumanSuccessMessage(org) {
        return messages.getMessage('createOrgCommandSuccess', [org.orgId, org.username]);
    }
    /**
     * returns a human readable error message for cli output
     * @returns {string}
     */
    getHumanErrorMessage(err) {
        let message;
        try {
            // try and get a message associated with an embedded error code.
            const errorCode = this.parseSignupErrorCode(err);
            if (!_.isNil(errorCode) && errorCode.length > 0) {
                message = messages.getMessage(errorCode[0], [this.force.config.getWorkspaceConfigFilename()], 'signup');
            }
            else {
                message = messages.getMessage(err.errorCode, [this.force.config.getWorkspaceConfigFilename()], 'signup');
            }
        }
        // getMessage throws an error when a key is not found.
        catch (e) {
            // Use the standard error message
            message = null;
        }
        return message;
    }
}
module.exports = OrgCreateCommand;

//# sourceMappingURL=scratchOrgCreateCommand.js.map
