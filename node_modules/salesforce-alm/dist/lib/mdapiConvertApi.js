/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
const fsx = require('fs-extra');
const path = require('path');
const util = require('util');
const Promise = require('bluebird');
const optional = require('optional-js');
const _ = require('lodash');
const parser = require('gitignore-parser');
const Force = require(path.join(__dirname, 'force'));
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const SourceWorkspaceAdapter = require(path.join(__dirname, 'sourceWorkspaceAdapter'));
const almError = require(path.join(__dirname, 'almError'));
const logger = require(path.join(__dirname, 'logApi'));
const glob = Promise.promisify(require('glob'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const messages = require(path.join(__dirname, 'messages'))();
const sourceState = require(path.join(__dirname, 'sourceState'));
const fsx_ensureDir = Promise.promisify(fsx.ensureDir);
/**
 * Helper to normalize a path
 * @param {string} targetValue - the raw path
 * @returns {string} - a trimmed path without a trailing slash.
 * @private
 */
const _normalizePath = function (targetValue) {
    let localTargetValue = targetValue.trim();
    if (localTargetValue.endsWith(path.sep)) {
        localTargetValue = localTargetValue.substr(0, localTargetValue.length - 1);
    }
    return path.resolve(localTargetValue);
};
/**
 * Process a file from the metadata package.
 * @param {object} typeDef - object type from the metadata registry
 * @param {string} pathWithPackage - the filepath including the metadata package
 * @param {string} fullName - the computed full name  @see _getFullName
 * @param sourceWorkspaceAdapter - the org/source workspace adapter
 * @param {[]} sourceElements - accumulator of created source elements
 * @private
 */
const _processFile = function (typeDef, pathWithPackage, fullName, sourceWorkspaceAdapter, sourceElements) {
    const fileProperties = {
        type: typeDef.metadataName,
        fileName: pathWithPackage,
        fullName
    };
    const retrieveRoot = path.join(this._package_root, '..');
    // Each Aura bundle has a definition file that has one of the suffixes: .app, .cmp, .design, .evt, etc.
    // In order to associate each sub-component of an aura bundle (e.g. controller, style, etc.) with
    // its parent aura definition type, we must find the parent's file properties
    // and pass those along to processMdapiFileProperty()
    const auraDefinitionProperty = [];
    if (fileProperties.type === 'AuraDefinitionBundle') {
        const bundleDirPath = path.join(retrieveRoot, path.dirname(fileProperties.fileName));
        const bundlePaths = glob.sync(path.join(bundleDirPath, '*'));
        const bundleDefinitionPath = bundlePaths.find(bundlePath => {
            const lightningDefType = sourceWorkspaceAdapter.metadataRegistry.getLightningDefByFileName(bundlePath);
            if (!util.isNullOrUndefined(lightningDefType)) {
                const isDefinitionFile = lightningDefType.hasMetadata;
                return isDefinitionFile;
            }
            return false;
        });
        const auraDefinitionFileProperties = {
            type: typeDef.metadataName,
            fileName: path.relative(retrieveRoot, bundleDefinitionPath),
            fullName: path.basename(bundleDefinitionPath, path.extname(bundleDefinitionPath))
        };
        auraDefinitionProperty.push(auraDefinitionFileProperties);
    }
    const element = sourceWorkspaceAdapter.processMdapiFileProperty(sourceElements, retrieveRoot, fileProperties, auraDefinitionProperty);
    if (util.isNullOrUndefined(element)) {
        this.logger.warn(`Unsupported type: ${typeDef.metadataName} path: ${pathWithPackage}`);
    }
};
/**
 * Process metadata fullnames
 * @param {object} typeDef - object type from metadata registry
 * @param {object} metadataRegistry - describe metadata
 * @param {string} pathElements - package relative path elements - "type-dir", ["container-dir",] "file"
 * @param {object} file - base file name
 * @returns {string} represent the metadata fullname
 * @private
 */
const _getFullName = function (typeDef, metadataRegistry, pathElements, file) {
    let fullName;
    switch (typeDef.metadataName) {
        case metadataRegistry.typeDefs.Document.metadataName:
        case metadataRegistry.typeDefs.Dashboard.metadataName:
        case metadataRegistry.typeDefs.Report.metadataName:
        case metadataRegistry.typeDefs.EmailTemplate.metadataName:
        case metadataRegistry.typeDefs.AuraDefinitionBundle.metadataName:
            fullName = pathElements[1];
            if (pathElements.length === 3) {
                fullName = path.join(pathElements[1], pathElements[2]);
            }
            break;
        case metadataRegistry.typeDefs.DocumentFolder.metadataName:
        case metadataRegistry.typeDefs.DashboardFolder.metadataName:
        case metadataRegistry.typeDefs.ReportFolder.metadataName:
        case metadataRegistry.typeDefs.EmailFolder.metadataName:
            fullName = path.basename(file, metadataRegistry.metadataFileExt);
            break;
        case metadataRegistry.typeDefs.Territory2.metadataName:
        case metadataRegistry.typeDefs.Territory2Rule.metadataName:
            if (pathElements.length === 4) {
                fullName = `${pathElements[pathElements.length - 3]}.${pathElements[pathElements.length - 1]}`;
            }
            break;
        default:
            fullName = path.basename(file, path.extname(file));
            break;
    }
    return fullName;
};
/**
 * Process one file path within a metadata package directory
 * @param {object} item - the path item
 * @param {object} metadataRegistry - describe metadata
 * @param {object} sourceWorkspaceAdapter - workspace adapter
 * @param {array} sourceElements - accumulator of created source elements
 * @private
 */
const _processPath = function (item, metadataRegistry, sourceWorkspaceAdapter, sourceElements) {
    const pkgRelativePath = path.relative(this._package_root, item.path);
    if (pkgRelativePath.length > 0) {
        const pathElements = pkgRelativePath.split(path.sep); // ["type-dir", ["container-dir",]] "file"
        let isFolderType;
        if (pathElements.length > 1) {
            const type = pathElements[0];
            const file = pathElements[pathElements.length - 1];
            const possibleTypeDefs = metadataRegistry.getTypeDefinitionsByDirectoryName(type);
            let typeDef;
            if (possibleTypeDefs.length === 1) {
                typeDef = possibleTypeDefs[0];
            }
            else {
                const inFolderType = possibleTypeDefs.find(_typeDef => _typeDef.inFolder);
                if (!util.isNullOrUndefined(inFolderType)) {
                    isFolderType = !util.isNullOrUndefined(inFolderType) && pathElements.length === 2;
                    if (isFolderType) {
                        typeDef = inFolderType.folderTypeDef;
                    }
                    else {
                        typeDef = inFolderType;
                    }
                }
                else {
                    typeDef = metadataRegistry.getTypeDefinitionByFileName(file);
                }
            }
            // Territory2 and Territory2Rule exist in the Territory2Model directory, but they are separate entities
            // so we need to reload the typeDef accordingly
            const isTerritory2Model = !util.isNullOrUndefined(typeDef) && typeDef.metadataName === metadataRegistry.typeDefs.Territory2Model.metadataName;
            if (isTerritory2Model && pathElements.length === 4) {
                const terrType = pathElements[2];
                if (terrType === metadataRegistry.typeDefs.Territory2.defaultDirectory) {
                    typeDef = metadataRegistry.typeDefs.Territory2;
                }
                else {
                    typeDef = metadataRegistry.typeDefs.Territory2Rule;
                }
            }
            if (!item.path.endsWith(MetadataRegistry.getMetadataFileExt()) || isFolderType) {
                if (!util.isNullOrUndefined(typeDef)) {
                    const pathWithPackage = path.join(path.basename(this._package_root), pkgRelativePath);
                    const fullName = _getFullName(typeDef, metadataRegistry, pathElements, file);
                    if (item.stats.isFile()) {
                        _processFile.call(this, typeDef, pathWithPackage, fullName, sourceWorkspaceAdapter, sourceElements);
                    }
                }
                else {
                    this.logger.warn(`The type definition cannot be found for ${type} by file or directory name.`);
                }
            }
            else {
                if (typeDef.hasContent) {
                    const indexOfMetaExt = item.path.indexOf(MetadataRegistry.getMetadataFileExt());
                    const retrievedContentPath = item.path.substring(0, indexOfMetaExt);
                    if (!srcDevUtil.pathExistsSync(retrievedContentPath)) {
                        const err = new Error();
                        err.name = 'Missing content file';
                        err.message = messages.getMessage('MissingContentFile', retrievedContentPath);
                        throw err;
                    }
                }
            }
        }
    }
};
/**
 * Converts an array of aggregateSourceElements into objects suitable for a return to the caller.
 * @param {[]} aggregateSourceElements - array of aggregateSourceElements
 * @returns {[{state, fullName, type, filePath}]}
 */
const _mapToOutputElements = function (aggregateSourceElements) {
    let allWorkspaceElements = [];
    aggregateSourceElements.forEach(aggregateSourceElement => {
        allWorkspaceElements = allWorkspaceElements.concat(aggregateSourceElement.getWorkspaceElements());
    });
    return allWorkspaceElements.map(workspaceElement => {
        const fullFilePath = workspaceElement.getSourcePath();
        const paths = fullFilePath.split(this.projectPath);
        let filePath = paths[paths.length - 1];
        // Remove the leading slash
        if (!util.isNullOrUndefined(filePath) && path.isAbsolute(filePath)) {
            filePath = filePath.substring(1);
        }
        return {
            fullName: workspaceElement.getFullName(),
            type: workspaceElement.getTypeDef().metadataName,
            filePath,
            state: sourceState.toString(workspaceElement.getState())
        };
    });
};
/**
 * Finds the filepath root containing the package.xml
 * @private
 */
const _setPackageRoot = function () {
    const packageDotXmlPath = `${this.root}${path.sep}package.xml`;
    return glob(packageDotXmlPath)
        .then((outerfiles) => {
        if (outerfiles.length > 0) {
            this._package_root = this.root;
            return Promise.resolve();
        }
        else {
            const packageDotXmlGlobPath = `${this.root}${path.sep}**${path.sep}package.xml`;
            if (this.logger.isDebugEnabled()) {
                this.logger.debug(`Looking for package.xml here ${packageDotXmlGlobPath}`);
            }
            return glob(packageDotXmlGlobPath)
                .then((innerfiles) => {
                if (innerfiles.length < 1) {
                    const error = new Error();
                    error.code = 'ENOENT';
                    throw error;
                }
                this._package_root = path.dirname(innerfiles[0]);
                return Promise.resolve();
            });
        }
    });
};
/**
 * An api class for converting a source directory in mdapi package format into source compatible with an SFDX workspace.
 */
class MdapiConvertApi {
    constructor(force) {
        this.force = optional.ofNullable(force).orElse(new Force());
        this.projectPath = this.force.getConfig().getProjectPath();
        this._outputDirectory = this.force.getConfig().getAppConfig().defaultPackagePath;
        this.logger = logger.child('mdapiConvertApi');
    }
    /**
     * @returns {string} the directory for the output
     */
    get outputDirectory() {
        return this._outputDirectory;
    }
    /**
     * set the value of the output directory
     * @param {string} outputDirectory - the new value of the output directory.
     */
    set outputDirectory(outputDirectory) {
        if (_.isString(outputDirectory) && !_.isEmpty(outputDirectory)) {
            if (path.isAbsolute(outputDirectory)) {
                this._outputDirectory = path.relative(process.cwd(), outputDirectory);
            }
            else {
                this._outputDirectory = outputDirectory;
            }
        }
        else {
            throw almError('InvalidParameter', ['outputdir', outputDirectory]);
        }
    }
    /**
     * @returns {string} value of the root directory to convert. default to the project directory
     */
    get root() {
        return this._root;
    }
    /**
     * set the value of the root directory to convert
     * @param {string} sourceRootValue - a directory containing a package.xml file. Is should represents a valid mdapi
     * package.
     */
    set root(sourceRootValue) {
        if (sourceRootValue && (typeof sourceRootValue === 'string') && sourceRootValue.trim().length > 0) {
            this._root = _normalizePath(sourceRootValue);
        }
        else {
            throw almError('InvalidParameter', ['sourceRootValue', sourceRootValue]);
        }
    }
    isValidSourcePath(sourcePath) {
        let isValid = true;
        if (this.forceIgnore !== null) {
            const rootRelativePath = sourcePath.substr(this._package_root.length);
            isValid = this.forceIgnore.accepts(rootRelativePath);
        }
        // Skip directories/files beginning with '.' and that should be ignored
        return isValid && !path.basename(sourcePath).startsWith('.');
    }
    /**
     * Returns a promise to convert a metadata api directory package into SFDX compatible source.
     * @returns {Promise}
     */
    convertSource(org) {
        // Walk the metadata package elements.
        return org.resolveDefaultName()
            .then(() => fsx_ensureDir(this.root))
            .then(() => fsx_ensureDir(this._outputDirectory))
            .then(() => _setPackageRoot.call(this))
            .then(() => {
            if (this.logger.isDebugEnabled()) {
                [{ name: 'root', value: this.root }, { name: 'outputdir', value: this._outputDirectory }]
                    .forEach((attribute) => {
                    this.logger.debug(`Processing mdapi convert with ${attribute.name}: ${attribute.value}`);
                });
            }
            this.logger.debug(`Processing mdapi convert with package root: ${this._package_root}`);
            const sourceWorkspaceAdapter = new SourceWorkspaceAdapter(org, path.relative(this.projectPath, this.outputDirectory), true, MetadataRegistry, true);
            const metadataRegistry = new MetadataRegistry(org);
            const aggregateSourceElements = new Map();
            try {
                this.forceIgnore = parser.compile(fsx.readFileSync(path.join(this._package_root, '.forceignore'), 'utf8'));
            }
            catch (err) {
                this.forceIgnore = null;
            }
            // Use a "new" promise to block the promise chain until the source metadata package is processed.
            return new Promise((resolve, reject) => {
                let errorFoundProcessingPath = false;
                fsx.walk(this._package_root)
                    .on('data', (item) => {
                    try {
                        if (this.isValidSourcePath(item.path)) {
                            _processPath.call(this, item, metadataRegistry, sourceWorkspaceAdapter, aggregateSourceElements);
                        }
                    }
                    catch (e) {
                        errorFoundProcessingPath = true;
                        if (e.name === 'Missing metadata file' || e.name === 'Missing content file') {
                            reject(e);
                        }
                        else {
                            reject(almError({ keyName: 'errorProcessingPath', bundle: 'mdapiConvertApi' }, [item.path]));
                        }
                    }
                })
                    .on('end', () => {
                    if (!errorFoundProcessingPath && aggregateSourceElements.size > 0) {
                        sourceWorkspaceAdapter.updateSource(aggregateSourceElements, undefined, undefined, undefined, true /** checkForDuplicates */, this.unsupportedMimeTypes);
                        if (this.logger.isDebugEnabled()) {
                            const allPaths = [];
                            aggregateSourceElements.forEach(aggregateSourceElement => {
                                const workspaceElements = aggregateSourceElement.getWorkspaceElements();
                                workspaceElements.forEach(workspaceElement => {
                                    allPaths.push(workspaceElement.getSourcePath());
                                });
                            });
                            this.logger.debug(allPaths);
                        }
                    }
                    resolve(_mapToOutputElements.call(this, aggregateSourceElements));
                })
                    .on('error', (err, item) => {
                    reject(almError({ keyName: 'errorProcessingPath', bundle: 'mdapiConvertApi' }, [item.path]));
                });
            });
        })
            .catch((err) => {
            // Catch invalid source package.
            if (err.code && err.code === 'ENOENT') {
                throw almError({ keyName: 'invalidPath', bundle: 'mdapiConvertApi' });
            }
            else {
                throw err;
            }
        });
    }
}
module.exports = MdapiConvertApi;

//# sourceMappingURL=mdapiConvertApi.js.map
