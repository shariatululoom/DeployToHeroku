/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
/**
 * Force.com Continuous Integration CLI Test APIs to invoke tests and retrieve test results.
 *
 * $ force:apex:test:run    - invokes tests of given Apex Class Ids or Apex Suite Ids.
 * $ force:apex:test:report  - gets test results for given testrunid
 *
 */
'use strict';
const TEST_RESULT_FILE_PREFIX = 'test-result';
const TEST_RUN_ID_FILE = 'test-run-id.txt';
const TOPIC = '/systemTopic/TestResult';
// ** external modules **
const fs = require('fs');
const path = require('path');
const util = require('util');
const Promise = require('bluebird');
const _ = require('lodash');
const moment = require('moment');
const mkdirp = Promise.promisify(require('mkdirp'));
const writeFile = Promise.promisify(fs.writeFile);
const logger = require(path.join(__dirname, '..', 'logApi'));
const StreamClient = require(path.join(__dirname, '..', 'status'));
const consts = require(path.join(__dirname, '..', 'constants'));
const messages = require(path.join(__dirname, '..', 'messages'));
const almError = require(path.join(__dirname, '..', 'almError'));
const Reporters = require(path.join(__dirname, '..', 'test', 'reporter'));
const TestResults = require(path.join(__dirname, '..', 'test', 'testResults'));
const TEST_LEVELS = {
    all: 'RunAllTestsInOrg',
    local: 'RunLocalTests',
    specific: 'RunSpecifiedTests'
};
/**
 * Turn a value into a string. Right now, only handles string values, otherwise
 * it just returns the value.
 *
 * @param {any} val The value to turn into a string
 * @return {array} The array representation of the value
 */
function arrayify(value) {
    if (util.isString(value)) {
        return value.split(',');
    }
    return value;
}
/**
 * Output the test results in a human readable way
 */
class ApexHumanReporter extends Reporters.HumanReporter {
    constructor(testApi) {
        super(testApi.logger);
    }
    static getDefaultCodeCoveragePercentage() {
        return 75;
    }
    onFinished(apexTestResults) {
        if (apexTestResults.coverage) {
            this.logTable('Apex Code Coverage', apexTestResults.coverage.coverage, [
                { key: 'id', label: 'Id' },
                { key: 'name', label: 'Name' },
                { key: 'coveredPercent',
                    label: '% Covered',
                    format: percent => {
                        let color = this.logger.color.red;
                        // Keep the color as the apex code requirement, or allow
                        // for custom requirements.
                        if (percent >= (process.env.SFDX_CODE_COVERAGE_REQUIREMENT ||
                            ApexHumanReporter.getDefaultCodeCoveragePercentage())) {
                            color = this.logger.color.green;
                        }
                        return color(`${percent}%`);
                    } },
                { key: 'lines',
                    label: 'Uncovered Lines',
                    format: lines => {
                        const uncoveredNumbers = Object.keys(_.pickBy(lines, line => !line)).join(',');
                        if (uncoveredNumbers.length > 0) {
                            return this.logger.color.red(uncoveredNumbers);
                        }
                        return '';
                    } }
            ]);
        }
        super.onFinished(apexTestResults);
    }
}
/**
 * Apex TAP reporter implementation.
 */
class ApexTapReporter extends Reporters.TapReporter {
    constructor(testApi) {
        super(testApi.logger);
        this.api = testApi;
        this.results = {};
    }
    onStart(testrunid) {
        return this.api.force.getApexTestRunResult(this.api.org, testrunid)
            .then(res => {
            if (_.get(res.records, 'length')) {
                this.logTapStart(res.records[0].MethodsEnqueued);
            }
        });
    }
    /**
     * Receive notifications on progress to output TAP lines as the tests finish.
     * NOTE: This will use more API calls since it will query the queue items every
     *  streaming event.
     */
    onProgress(queueItems) {
        const promise = this.api.force.getAsyncTestResults(this.api.org, queueItems)
            .then(res => {
            res.records.forEach(testResult => {
                if (!this.results[testResult.Id]) {
                    this.results[testResult.Id] = testResult;
                    this.logTapResult(testResult);
                }
            });
        });
        this.operations.push(promise);
        return promise;
    }
    getFullTestName(testResult) {
        return `${testResult.ApexClass.Name}.${testResult.MethodName}`;
    }
    onFinished(apexTestResults) {
        if (this.api.synchronous && apexTestResults) {
            this.logTapStart(apexTestResults.total);
            apexTestResults.tests.forEach(testResult => {
                this.logTapResult(testResult);
            });
        }
        else {
            let reportArgs = `-i ${this.api.testrunid}`;
            if (this.api.username) {
                reportArgs += ` -u ${this.api.username}`;
            }
            this.log(this.api.messages.getMessage('apexTestApiReportForFormatHint', [reportArgs], 'apex'));
            super.onFinished();
        }
    }
}
class ApexJUnitReporter extends Reporters.JUnitReporter {
    constructor(testApi) {
        super(testApi.logger);
    }
}
class ApexJsonReporter extends Reporters.JsonReporter {
    constructor(testApi) {
        super(testApi.logger);
    }
}
/**
 * A list of the accepted reporter types
 */
Reporters.Reporter.Types = {
    human: ApexHumanReporter,
    tap: ApexTapReporter,
    json: ApexJsonReporter,
    junit: ApexJUnitReporter
};
/**
 *  A container for the apex test results that provides helpers around formating
 *  and logging test results.
 */
class ApexTestResults extends TestResults {
    constructor(testApi, tests, runResultSummaries, config) {
        super(testApi.testrunid, testApi.startTime, 'force.apex', tests, runResultSummaries, config);
    }
    getTestContainerName(test) {
        return test.ApexClass.Name;
    }
    getTestNamespace(test) {
        return test.ApexClass.NamespacePrefix;
    }
    getTestName(test) {
        return test.MethodName;
    }
}
class ApexTestApi {
    /**
     * The API class that manages running of apex tests. By default it will run
     * all local namespaced tests unless initialized with other options.
     *
     * @param org {object} The org for running tests.
     */
    constructor(org) {
        this.org = org;
        this.force = org.force;
        this.config = org.config;
        this.messages = messages(this.force.config.getLocale());
        this.startTime = moment();
        this.logger = logger.child('apexTestApi', { username: org.getName() });
        // no-op report that will log; may be overriden by --resultformat
        this.reporter = new Reporters.NoOpReporter(this.logger);
        this.waitForResults = false;
        // Apply defaults
        Object.assign(this, {
            suitenames: [],
            classnames: [],
            suiteids: [],
            prefix: '',
            codecoverage: false,
            synchronous: false,
            testlevel: TEST_LEVELS.local
        });
    }
    /**
     * Sets the function to call once the StreamClient socket times out
     * @param callback {function} - the function to invoke;
     */
    set socketTimeoutHandler(callback) {
        if (!_.isNil(callback) && _.isFunction(callback)) {
            this._socketTimeoutHandler = callback;
        }
        else {
            throw almError({ keyName: 'invalidValueForSocketTimeoutHandler', bundle: 'apex' });
        }
    }
    /**
     * Gets the socket timeout handler function.
     * @returns {function}
     */
    get socketTimeoutHandler() {
        return this._socketTimeoutHandler;
    }
    /**
     * Sets the wait timeout in minutes
     * @param value {number} - wait timeout in minutes
     */
    set waitInMinutes(value) {
        this._wait = StreamClient.validateWaitValue(value);
    }
    /**
     * Sets the get timeout in minutes
     * @returns {number}
     */
    get waitInMinutes() {
        return this._wait;
    }
    hasOutputDirectory() {
        return _.isString(this.outputdir) && !_.isEmpty(this.outputdir);
    }
    /**
     * Create the output directory the the test results will be stored if doesn't exist
     */
    setupOutputDirectory() {
        const outputdir = this.outputdir;
        if (this.hasOutputDirectory()) {
            this.files = [];
            return mkdirp(outputdir)
                .then(() => outputdir)
                .catch(error => {
                // It is ok if the directory already exist
                if (error.name !== 'EEXIST') {
                    throw error;
                }
            });
        }
        return Promise.resolve();
    }
    /**
     * Initialize the apex test api to specify additional options and setup the
     * output directory if needed.
     *
     * @param {object} options The options used to run the tests. You can see a
     * list of valid options in the by looking at the defaults in the constructor.
     * @param {object} logger The logger object, which should typically be the
     * heroku cli.
     */
    initialize(options = {}) {
        // Apply all the user defined setting (will override defaults)
        _.merge(this, options);
        // Disallow specifying both classnames and suitenames
        if (options.classnames && options.suitenames) {
            return Promise.reject(almError('apexTestApiInvalidParams'));
        }
        if (this.resultformat || this.wait) {
            // Validate the reporter
            this.resultformat = this.resultformat || 'human';
            let reporter = Reporters.Reporter.Types[this.resultformat];
            if (!reporter) {
                return Promise.reject(almError('apexTestApiInvalidReporter', Object.keys(Reporters.Reporter.Types).join(',')));
            }
            // The --json flag overrides resultformat as mentioned in --help.
            // Don't do this above, as we still validate the reporter
            if (this.json) {
                this.resultformat = 'json';
                // Reset the reporter with new result format
                reporter = Reporters.Reporter.Types[this.resultformat];
            }
            if (this.resultformat === 'json') {
                // If the reporter is json, make sure the json flag is also set
                this.json = true;
                options.json = true;
            }
            this.reporter = new reporter(this);
            this.waitForResults = true;
        }
        // Validate the testLevel if user provided
        if (options.testlevel) {
            const allLevels = _.values(TEST_LEVELS);
            if (!_.includes(allLevels, options.testlevel)) {
                return Promise.reject(almError('apexTestApiInvalidTestLevel', [options.testlevel, _.join(allLevels)]));
            }
        }
        this.suitenames = arrayify(this.suitenames);
        this.classnames = arrayify(this.classnames);
        // Run specified tests if the user specified tests
        if (this.suitenames.length || this.classnames.length) {
            // When specifying suites or classes and a testlevel, the testlevel must be "RunSpecifiedTests"
            if (options.testlevel && options.testlevel !== TEST_LEVELS.specific) {
                return Promise.reject(almError('apexTestApiIncorrectTestLevel'));
            }
            this.testlevel = TEST_LEVELS.specific;
        }
        this.completed = {};
        this.synchronous = options.synchronous;
        return this.setupOutputDirectory()
            .then(() => {
            if (this.hasOutputDirectory() && !this.reporter.isType(Reporters.NoOpReporter)) {
                const writeStream = fs.createWriteStream(this.getResultFilePath());
                this.files.push({ format: this.reporter.getFormat(), file: this.getResultFilePath() });
                this.reporter.addStream(writeStream);
                return new Promise((res, rej) => {
                    writeStream.on('open', res);
                    writeStream.on('error', rej);
                });
            }
            return Promise.resolve();
        });
    }
    getResultFilePath() {
        return path.join(this.outputdir, `${TEST_RESULT_FILE_PREFIX}.${this.reporter.getFormat()}`);
    }
    isRunAllTest() {
        return _.includes([TEST_LEVELS.local, TEST_LEVELS.all], this.testlevel);
    }
    /**
     * Map the results to an array of ids.
     * TODO this should be removed when we can pass names to the server.
     */
    resultToIds(nameField, result, original) {
        if (!util.isObject(result) || !util.isArray(result.records)) {
            throw almError('apexReportCommandInvalidResponse', original);
        }
        if (result.records.length <= 0) {
            throw almError('apexReportCommandNoTestFound', (util.isArray(original) ? original.join(',') : original));
        }
        const ids = [];
        const registry = {};
        // Name to Test mapping
        result.records.forEach(record => {
            registry[record[nameField]] = record;
        });
        original.forEach(name => ids.push(registry[name].Id));
        return ids;
    }
    // TODO Remove when we can specify names to the API
    queryClassIds() {
        let query = 'SELECT Id, Name FROM ApexClass';
        query += ` WHERE Name IN ('${this.classnames.join("','")}')`;
        return this.force.toolingQuery(this.org, query)
            .then(results => (this.synchronous ? {
            tests: [{ classId: this.resultToIds('Name', results, this.classnames).join(',') }]
        } : {
            classids: this.resultToIds('Name', results, this.classnames).join(',')
        }));
    }
    // TODO remove when we can specify names to the API
    querySuiteIds() {
        let query = 'SELECT Id, TestSuiteName FROM ApexTestSuite';
        query += ` WHERE TestSuiteName IN ('${this.suitenames.join("','")}')`;
        return this.force.toolingQuery(this.org, query)
            .then(results => ({
            suiteids: this.resultToIds('TestSuiteName', results, this.suitenames).join(',')
        }));
    }
    /**
     * Run the tests specified on this apexTestApi object by creating an apex
     * test run job. Depending on the options specified in this apexTestApi,
     * it will also wait for those results via the streaming API which will
     * also log and store those results.
     */
    runTests() {
        const runAsync = data => {
            let waitTillConnected = Promise.resolve();
            let waitTillDone = Promise.resolve();
            // Start to listen to results before we kick off the test,
            // so we don't miss any of the action.
            if (this.waitForResults) {
                waitTillConnected = this.waitForResult();
                waitTillDone = this.finish;
            }
            return waitTillConnected
                .then(() => {
                if (this.verbose) {
                    this.reporter.log(this.targetusername ? `Invoking Apex tests using ${this.targetusername}...` : 'Invoking Apex tests...');
                }
            })
                .then(() => this.force.runTestsAsynchronous(this.org, data))
                .then((res) => {
                const promise = Promise.resolve();
                if (this.waitForResults) {
                    promise.then(() => this.reporter.emit('start', res));
                }
                return promise.then(() => res);
            })
                .then(res => this.processResultId(res))
                .then((res) => {
                if (!this.waitForResults) {
                    return res;
                }
                else {
                    return waitTillDone;
                }
            })
                .catch((err) => {
                let error = almError('InvalidAsyncTestJob', err.message);
                if (err.errorCode && err.errorCode === 'UNKNOWN_EXCEPTION') {
                    // I've ran into cases where the returned error only has this message: 'Unable to invoke async test job: An unknown exception occurred.'
                    // Not very helpful. After some investigation it turns out to be org limits. 'AsyncApexTests - Limit Exceeded'
                    error = almError({ keyName: 'InvalidAsyncTestJob', bundle: 'default' }, [err.message], { keyName: 'InvalidAsyncTestJobUnknownAction', bundle: 'default' });
                }
                if (err.name === 'INVALID_INPUT') {
                    error = almError('InvalidAsyncTestJobNoneFound', err.message);
                }
                if (this.stream) {
                    this.stream.disconnect();
                    this.finishReject(error);
                    return waitTillDone;
                }
                throw error;
            });
        };
        const runSync = data => {
            if (this.verbose) {
                this.reporter.log(this.targetusername ? `Invoking Apex tests using ${this.targetusername}...` : 'Invoking Apex tests...');
            }
            let config;
            return this.org.getConfig()
                .then(c => {
                config = c;
            })
                .then(() => this.force.runTestsSynchronous(this.org, data))
                .then((res) => {
                const tests = this.convertSynchronousResultsToApexTestResult(res.successes, res.failures);
                const runResultSummary = [this.convertSynchronousResultsToRunSummary(res)];
                this.testResults = new ApexTestResults(this, tests, runResultSummary, config);
            })
                .then(() => {
                if (this.codecoverage) {
                    return this.retrieveApexCodeCoverage();
                }
                return undefined;
            })
                .then(coverage => {
                this.testResults.coverage = coverage;
            })
                .then(() => this.logTestArtifacts())
                .then(() => {
                this.reporter.emit('finished', this.testResults);
            })
                .then(() => this.testResults.toJson())
                .catch(err => {
                const error = almError({ keyName: 'apexTestSynchronousRunFailed', bundle: 'apex' }, [err.message]);
                throw error;
            });
        };
        if (this.synchronous && (this.suitenames.length > 0 || this.classnames.length !== 1)) {
            return Promise.reject(almError({ keyName: 'apexTestCommandInvalidSynchronousParams', bundle: 'apex' }));
        }
        else if (this.synchronous && this.classnames.length === 1) {
            return this.queryClassIds().then(runSync);
        }
        else if (this.isRunAllTest()) {
            return runAsync({
                testLevel: this.testlevel
            });
        }
        else if (this.classnames.length > 0) {
            return this.queryClassIds().then(runAsync);
        }
        else if (this.suitenames.length > 0) {
            return this.querySuiteIds().then(runAsync);
        }
        else {
            return Promise.reject(almError(this.messages.getMessage('apexTestCommandInvalidTestlevel', [], 'apex')));
        }
    }
    processResultId(results) {
        this.testrunid = results;
        if (this.verbose) {
            this.reporter.log(`Started async test run job: ${this.testrunid}`);
        }
        const logHelp = () => {
            // Tell the user how to get the results
            if (!this.waitForResults) {
                let reportArgs = `-i ${this.testrunid}`;
                if (this.targetusername) {
                    reportArgs += ` -u ${this.targetusername}`;
                }
                this.logger.log(this.messages.getMessage('apexTestApiReportHint', [reportArgs], 'apex'));
                return {
                    testRunId: this.testrunid
                };
            }
            return {};
        };
        // write testrunid to file
        if (this.hasOutputDirectory()) {
            const file = path.join(this.outputdir, TEST_RUN_ID_FILE);
            this.files.push({ format: 'txt', file });
            return writeFile(file, this.testrunid).then(() => {
                if (this.verbose) {
                    this.reporter.log(`Test run id written to ${file}`);
                }
                return logHelp();
            });
        }
        else {
            return Promise.resolve(logHelp());
        }
    }
    checkProgress() {
        return this.force.getAsyncTestStatus(this.org, this.testrunid)
            .then(statuses => {
            let allCompleted = true;
            statuses.records.forEach(status => {
                if (!this.completed[status.Id]) {
                    if (status.Status === 'Completed' || status.Status === 'Failed') {
                        this.completed[status.Id] = status;
                    }
                    else {
                        allCompleted = false;
                    }
                }
            });
            let progress = Promise.resolve();
            if (this.waitForResults && this.reporter.progressRequired) {
                progress = progress.then(() => this.reporter.emit('progress', statuses.records.map(rec => rec.Id)));
            }
            // If this is called each time we get a stream, the overall test run
            // may not be finished, so check before processing results.
            if (allCompleted && this.finished) {
                progress = progress.then(() => this.retrieveAndStoreTestResults(Object.keys(this.completed)));
            }
            return progress;
        });
    }
    handleMessage(message) {
        if (!_.isNil(message.errorName) && message.errorName === consts.LISTENER_ABORTED_ERROR_NAME) {
            if (!_.isNil(this.socketTimeoutHandler)) {
                try {
                    this.socketTimeoutHandler(message, this);
                }
                catch (err) {
                    this.finishReject(err);
                }
            }
            return this.finish;
        }
        const jobId = message.sobject.Id;
        if (this.verbose) {
            this.reporter.log(`Processing event for job ${jobId}`);
        }
        if (jobId.match(`^${this.testrunid}`)) {
            return this.force.retrieve(this.org, 'AsyncApexJob', this.testrunid)
                .then(job => {
                if (job.Status === 'Completed') {
                    this.finished = true;
                    this.stream.disconnect();
                    return this.checkProgress();
                }
                // If the reporter wants progress updates, checkProgress every time,
                // otherwise don't waste the resources
                if (this.waitForResults && this.reporter.progressRequired) {
                    return this.checkProgress();
                }
                return Promise.resolve();
            })
                .catch(err => {
                this.finishReject();
                throw err;
            });
        }
        return Promise.resolve();
    }
    waitForResult() {
        if (this.verbose) {
            this.reporter.log('Listening for results');
        }
        this.stream = new StreamClient(this.org);
        this.stream.waitInMinutes = this.waitInMinutes;
        // Set up a finish handler that can be resolve when streaming finishes,
        // or right when the run is completed
        this.finish = new Promise((resolve, reject) => {
            this.finishResolve = resolve;
            this.finishReject = reject;
        });
        return this.stream.subscribe(TOPIC, this.handleMessage.bind(this), true);
    }
    // check for valid job
    jobCheck() {
        return this.force.getAsyncJob(this.org, this.testrunid)
            .then(resp => {
            if (!resp || !resp.records || resp.records.length === 0) {
                return Promise.reject(almError('apexTestApiInvalidTestRunId', this.testrunid));
            }
            else {
                return resp.records[0];
            }
        });
    }
    /**
     * Retrieve the test results and code coverage for the completed queued items,
     * then store them by logging the test results to the client and filesystem.
     *
     * @param {array} apexTestQueueItemIds An array of *completed* apex queue record Ids.
     */
    retrieveAndStoreTestResults(apexTestQueueItemIds) {
        if (this.verbose) {
            this.reporter.log(`Retrieving test results for job ${this.testrunid}...\n`);
        }
        let config;
        const testrunid = this.testrunid;
        return this.org.getConfig()
            .then(c => {
            config = c;
        })
            .then(() => Promise.all([
            this.force.getAsyncTestResults(this.org, apexTestQueueItemIds),
            this.force.getApexTestRunResult(this.org, testrunid) // gets summary info
        ]))
            .then(results => {
            this.testResults = new ApexTestResults(this, results[0].records, results[1].records, config);
        })
            .then(() => {
            if (this.codecoverage) {
                return this.retrieveApexCodeCoverage();
            }
            return undefined;
        })
            .then(coverage => {
            this.testResults.coverage = coverage;
        })
            .then(() => this.logTestArtifacts())
            .then(() => {
            if (this.waitForResults) {
                return this.reporter.emit('finished', this.testResults);
            }
            return Promise.resolve();
        })
            .then(() => {
            const json = this.testResults.toJson();
            // Check if it was kicked off via runTest
            if (util.isFunction(this.finishResolve)) {
                return this.finishResolve(json);
            }
            else {
                return json;
            }
        })
            .catch(err => {
            err.name = 'TestResultRetrievalFailed';
            this.messages.getMessage('apexReportCommandTestResultRetrievalFailed', [this.testrunid, err.message]);
            throw err;
        });
    }
    /**
     * Log test results to the console and/or the filesystem depending on the options
     */
    logTestArtifacts() {
        // write test results files - junit and json
        if (this.hasOutputDirectory()) {
            return Promise.resolve()
                .then(() => {
                // Write junit file
                const junit = {
                    format: 'junit',
                    file: path.join(this.outputdir, this.testrunid ? `${TEST_RESULT_FILE_PREFIX}-${this.testrunid}-junit.xml`
                        : `${TEST_RESULT_FILE_PREFIX}-junit.xml`)
                };
                this.files.push(junit);
                return writeFile(junit.file, this.testResults.generateJunit());
            })
                .then(() => {
                // Write JSON file
                const json = {
                    format: 'json',
                    file: path.join(this.outputdir, this.testrunid ? `${TEST_RESULT_FILE_PREFIX}-${this.testrunid}.json`
                        : `${TEST_RESULT_FILE_PREFIX}.json`)
                };
                this.files.push(json);
                return writeFile(json.file, JSON.stringify(this.testResults.toJson(), null, 4));
            })
                .then(() => {
                if (this.codecoverage && this.testResults.coverage && this.testResults.coverage.coverage) {
                    // Write JSON file
                    const json = {
                        format: 'json',
                        file: path.join(this.outputdir, `${TEST_RESULT_FILE_PREFIX}-codecoverage.json`)
                    };
                    this.files.push(json);
                    return writeFile(json.file, JSON.stringify(this.testResults.coverage.coverage, null, 4));
                }
                return Promise.resolve();
            })
                .then(() => {
                this.reporter.logTable('Test Reports', this.files, [
                    { key: 'format', label: 'Format' },
                    { key: 'file', label: 'File' }
                ]);
            });
        }
        return Promise.resolve();
    }
    /**
     * Apex code coverage has a record for each test method invoked multiplied by the
     * apex class or triggers executed in those tests. This method iterates over
     * all those records to determine the code coverage per class and trigger.
     *
     * For example, it we have testMethod1 that executes code on classA and classB, and
     * testMethod2 that executes code on classA, then there will be 3 apex code coverage
     * records: testMethod1.classA, testMethod1.classB, testMethod2.classA. That means
     * that the TOTAL lines covered in classA is an aggregate between the testMethod1
     * and testMethod2 coverage records.
     */
    retrieveApexCodeCoverage() {
        return this.force.getApexCodeCoverage(this.org)
            .then(coverageResponse => {
            const records = util.isArray(coverageResponse.records) ? coverageResponse.records : [];
            const coverageMap = {};
            const coverage = [];
            // Combine coverage results to get coverage by class and trigger
            records.forEach(record => {
                const id = record.ApexClassOrTrigger.Id;
                const covered = record.Coverage.coveredLines;
                const uncovered = record.Coverage.uncoveredLines;
                const totalLines = record.NumLinesCovered + record.NumLinesUncovered;
                // If we haven't ran into the apex class or trigger yet, create a
                // new coverage record for it so we can aggregate all results
                if (!coverageMap[id]) {
                    coverageMap[id] = {
                        id,
                        name: record.ApexClassOrTrigger.Name,
                        totalLines,
                        // Use a map to easily update lines with new test results
                        // that come in for the same class or trigger
                        lines: {},
                        totalCovered: record.NumLinesCovered,
                        coveredPercent: (covered.length / totalLines) * 100
                    };
                    coverage.push(coverageMap[id]);
                    covered.forEach(line => {
                        coverageMap[id].lines[line] = 1;
                    });
                    uncovered.forEach(line => {
                        coverageMap[id].lines[line] = 0;
                    });
                }
                else {
                    // We only have to update covered lines, since any future test
                    // results on this apex can only improve the coverage
                    covered.forEach(line => {
                        if (!coverageMap[id].lines[line]) {
                            coverageMap[id].lines[line] = 1;
                            coverageMap[id].totalCovered++;
                        }
                    });
                    // Update the total covered lines. The total covered lines is a
                    // combination of all tests
                    coverageMap[id].coveredPercent =
                        Math.round((coverageMap[id].totalCovered / totalLines) * 100);
                }
            });
            return { coverage, records };
        })
            .catch(err => {
            err.name = 'CodeCoverageRetrievalFailed';
            this.messages.getMessage('apexReportCommandCodeCoverageRetrievalFailed', [this.testrunid, err.message]);
            throw err;
        });
    }
    convertSynchronousResultsToApexTestResult(successes, failures) {
        const apexTestResults = [];
        const mapTestResultFields = function (result, outcome) {
            return {
                ApexClass: {
                    attributes: {
                        type: 'ApexClass'
                    },
                    Id: result.id,
                    Name: result.name,
                    NamespacePrefix: result.namespace
                },
                MethodName: result.methodName,
                Outcome: outcome,
                RunTime: result.time,
                Message: result.message,
                StackTrace: result.stackTrace
            };
        };
        if (Array.isArray(successes)) {
            successes.forEach(successResult => {
                apexTestResults.push(mapTestResultFields(successResult, 'Pass'));
            });
        }
        if (Array.isArray(failures)) {
            failures.forEach(failureResult => {
                apexTestResults.push(mapTestResultFields(failureResult, 'Fail'));
            });
        }
        return apexTestResults;
    }
    convertSynchronousResultsToRunSummary(result) {
        return {
            TestTime: result.totalTime
        };
    }
}
ApexTestApi.reporter = Reporters.Reporter;
ApexTestApi.TEST_LEVELS = TEST_LEVELS;
module.exports = ApexTestApi;
module.exports.ApexHumanReporter = ApexHumanReporter;

//# sourceMappingURL=apexTestApi.js.map
