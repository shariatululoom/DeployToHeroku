/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
// Node
const path = require('path');
const util = require('util');
const fs = require('fs');
// 3pp
const optional = require('optional-js');
const bluebird = require('bluebird');
const xml2js = require('xml2js');
const _ = require('lodash');
// Local
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const BlacklistManager = require(path.join(__dirname, 'blacklistManager'));
const ScratchOrg = require(path.join(__dirname, 'scratchOrgApi'));
const fs_readFile = bluebird.promisify(fs.readFile);
const xml2jsParseString = bluebird.promisify(xml2js.parseString);
const messages = require(path.join(__dirname, 'messages'));
const describeMetadataDecompositionConfig_1 = require("./describeMetadataDecompositionConfig");
const customObjectTranslationDecompositionConfig_1 = require("./customObjectTranslationDecompositionConfig");
const nonDecomposedContentAndMetadataDecompositionConfig_1 = require("./nonDecomposedContentAndMetadataDecompositionConfig");
const staticResourceDecompositionConfig_1 = require("./staticResourceDecompositionConfig");
const inFolderDecompositionConfig_1 = require("./inFolderDecompositionConfig");
// Constants
const METADATA_FILE_EXT = '-meta.xml';
const _lightningDefTypes = {
    APPLICATION: {
        defType: 'APPLICATION',
        format: 'XML',
        fileSuffix: '.app',
        hasMetadata: true
    },
    CONTROLLER: {
        defType: 'CONTROLLER',
        format: 'JS',
        fileSuffix: 'Controller.js'
    },
    COMPONENT: {
        defType: 'COMPONENT',
        format: 'XML',
        fileSuffix: '.cmp',
        hasMetadata: true
    },
    EVENT: {
        defType: 'EVENT',
        format: 'XML',
        fileSuffix: '.evt',
        hasMetadata: 'true'
    },
    HELPER: {
        defType: 'HELPER',
        format: 'JS',
        fileSuffix: 'Helper.js'
    },
    INTERFACE: {
        defType: 'INTERFACE',
        format: 'XML',
        fileSuffix: '.intf',
        hasMetadata: true
    },
    RENDERER: {
        defType: 'RENDERER',
        format: 'JS',
        fileSuffix: 'Renderer.js'
    },
    STYLE: {
        defType: 'STYLE',
        format: 'CSS',
        fileSuffix: '.css'
    },
    PROVIDER: {
        defType: 'PROVIDER',
        format: 'JS',
        fileSuffix: 'Provider.js'
    },
    MODEL: {
        defType: 'MODEL',
        format: 'JS',
        fileSuffix: 'Model.js'
    },
    TESTSUITE: {
        defType: 'TESTSUITE',
        format: 'JS',
        fileSuffix: 'Test.js'
    },
    DOCUMENTATION: {
        defType: 'DOCUMENTATION',
        format: 'XML',
        fileSuffix: '.auradoc'
    },
    TOKENS: {
        defType: 'TOKENS',
        format: 'XML',
        fileSuffix: '.tokens',
        hasMetadata: true
    },
    DESIGN: {
        defType: 'DESIGN',
        format: 'XML',
        fileSuffix: '.design'
    },
    SVG: {
        defType: 'SVG',
        format: 'SVG',
        fileSuffix: '.svg'
    }
};
// Metadata types that require special handling
const _typeDefOverrides = {
    ApexComponent: {
        nameForMsgs: 'Visualforce Component',
        nameForMsgsPlural: 'Visualforce Components'
    },
    ApexPage: {
        nameForMsgs: 'Visualforce Page',
        nameForMsgsPlural: 'Visualforce Pages'
    },
    AuraDefinitionBundle: {
        nameForMsgs: 'Lightning Component Bundle',
        nameForMsgsPlural: 'Lightning Component Bundles',
        ext: 'aurabundle',
        hasContent: true
    },
    CustomPageWebLink: {
        ext: 'custompageweblink'
    },
    Document: {
        ext: 'document',
        contentIsBinary: true
    },
    EmailTemplate: {
        contentIsBinary: true,
        nameForFolder: 'Email'
    },
    Report: {
        contentIsBinary: true
    },
    Dashboard: {
        contentIsBinary: true
    },
    StaticResource: {
        contentIsBinary: true
    },
    Territory2: {
        defaultDirectory: 'territories'
    },
    Territory2Rule: {
        defaultDirectory: 'rules'
    }
};
const _hasOverrides = function (metadataName) {
    return !util.isNullOrUndefined(_typeDefOverrides[metadataName]);
};
const _isWhitelistedForDecomposition = function (typeDef) {
    return typeDef.metadataName === 'CustomObject' || typeDef.metadataName === 'CustomObjectTranslation';
};
const _hasChildXmlNames = function (typeDef) {
    return !util.isNullOrUndefined(typeDef.childXmlNames) && typeDef.childXmlNames.length > 0;
};
const _createMetadataInfos = function (metadataDescribeResults) {
    const metadataObjects = metadataDescribeResults.metadataObjects;
    const processedInfos = {};
    for (let i = 0; i < metadataObjects.length; i++) {
        const info = metadataObjects[i];
        const metadataName = info.xmlName;
        let singularMetadataName;
        if (!util.isNullOrUndefined(info.childXmlNames) && metadataName.endsWith('s')) {
            singularMetadataName = metadataName.slice(0, -1);
        }
        else {
            singularMetadataName = metadataName;
        }
        if (!BlacklistManager.isBlacklisted(metadataName)) {
            const hasOverride = _hasOverrides(metadataName);
            const typeDefOverride = hasOverride ? _typeDefOverrides[metadataName] : {};
            const typeDef = {};
            typeDef.metadataName = metadataName;
            typeDef.ext = optional.ofNullable(typeDefOverride.ext).orElse(info.suffix);
            typeDef.hasContent = optional.ofNullable(typeDefOverride.hasContent).orElse(info.metaFile);
            typeDef.defaultDirectory = optional.ofNullable(typeDefOverride.defaultDirectory).orElse(info.directoryName);
            const nameWithSpaces = singularMetadataName.replace(/([A-Z])/g, ' $1').trim();
            typeDef.nameForMsgs = optional.ofNullable(typeDefOverride.nameForMsgs).orElse(nameWithSpaces);
            const pluralName = nameWithSpaces.endsWith('s') ? `${nameWithSpaces}es` : `${nameWithSpaces}s`;
            typeDef.nameForMsgsPlural = optional.ofNullable(typeDefOverride.nameForMsgsPlural).orElse(pluralName);
            typeDef.contentIsBinary = optional.ofNullable(typeDefOverride.contentIsBinary).orElse(false);
            typeDef.isAddressable = true;
            typeDef.isSourceTracked = true;
            if (!util.isNullOrUndefined(info.childXmlNames) && info.childXmlNames.length > 0) {
                typeDef.childXmlNames = info.childXmlNames;
            }
            typeDef.hasStandardMembers = metadataName === 'CustomObject' || metadataName === 'CustomObjectTranslation' || metadataName === 'StandardValueSet' || metadataName === 'Settings';
            typeDef.deleteSupported = metadataName != 'Settings';
            processedInfos[metadataName] = typeDef;
            // create the folder type for metadata types with folders
            if (info.inFolder) {
                const folderTypeDef = {};
                folderTypeDef.metadataName = hasOverride && typeDefOverride.nameForFolder !== undefined ? `${typeDefOverride.nameForFolder}Folder` : `${metadataName}Folder`;
                folderTypeDef.ext = `${typeDef.ext}Folder`;
                folderTypeDef.hasContent = false;
                folderTypeDef.defaultDirectory = typeDef.defaultDirectory;
                folderTypeDef.nameForMsgs = `${typeDef.nameForMsgs} Folder`;
                folderTypeDef.nameForMsgsPlural = `${typeDef.nameForMsgs} Folders`;
                folderTypeDef.contentIsBinary = false;
                folderTypeDef.isAddressable = false;
                folderTypeDef.isSourceTracked = true;
                processedInfos[folderTypeDef.metadataName] = folderTypeDef;
                typeDef.inFolder = true;
                typeDef.folderTypeDef = folderTypeDef;
            }
        }
    }
    return processedInfos;
};
const _getMetadataWsdlJson = function () {
    // const headers = {
    //     'content-type': 'application/x-www-form-urlencoded',
    //     'user-agent': srcDevUtil.getSfdxCLIClientId(),
    //     'cookie': true
    // };
    // return scratchOrg.force.request(scratchOrg, 'GET', '/services/wsdl/metadata', headers);
    const metadataWsdlPath = path.join(__dirname, '..', '..', 'metadata', 'metadata.wsdl');
    return fs_readFile(metadataWsdlPath, 'utf8')
        .then((wsdl) => xml2jsParseString(wsdl, { explicitArray: false }));
};
const _findFragmentName = function (elements, childXmlName) {
    if (elements instanceof Array) {
        for (const element of elements) {
            if (element.$.type === `tns:${childXmlName}` && !util.isNullOrUndefined(element.$.maxOccurs)) {
                return element.$.name;
            }
        }
        return null;
    }
    else {
        return elements.$.name;
    }
};
const _getXmlFragmentNames = function (complexType, childXmlNames) {
    const fragmentNames = [];
    for (const childXmlName of childXmlNames) {
        fragmentNames.push(_findFragmentName(complexType['xsd:complexContent']['xsd:extension']['xsd:sequence']['xsd:element'], childXmlName));
    }
    return fragmentNames;
};
const _findComplexType = function (complexTypes, parentXmlName) {
    for (const complexType of complexTypes) {
        if (parentXmlName === complexType.$.name) {
            return complexType;
        }
    }
    return null;
};
const _isEmptyContainer = function (complexType, childXmlNames) {
    const elements = complexType['xsd:complexContent']['xsd:extension']['xsd:sequence']['xsd:element'];
    if (elements instanceof Array) {
        return elements.length === childXmlNames.length;
    }
    else {
        return true;
    }
};
const _lowerFirstCap = function (s) {
    return `${s.substring(0, 1).toLowerCase()}${s.substring(1)}`;
};
const _singular = function (s) {
    if (!s.endsWith('s')) {
        return s;
    }
    const softConsonant = s.endsWith('ses') || s.endsWith('shes');
    const truncateCount = softConsonant ? 2 : 1; // I think we can safely assume English for metadata
    return s.substring(0, s.length - truncateCount);
};
const _getDecompositionExtensionFromFragmentName = function (typeDef, fragmentName) {
    let ext = _singular(_lowerFirstCap(fragmentName));
    if (typeDef.metadataName === 'CustomObjectTranslation') {
        ext = `${ext}Translation`;
    }
    return ext;
};
const _getMetadataEntityNameElement = function (typeDef, xmlFragmentName) {
    if (typeDef.metadataName === 'CustomObjectTranslation') {
        if (xmlFragmentName === 'layouts') {
            return 'layout';
        }
        else {
            return 'name';
        }
    }
    return 'fullName';
};
const _addMetadataDecompositions = function (typeDef, xmlFragmentNames) {
    for (let i = 0; i < typeDef.childXmlNames.length; ++i) {
        const metadataName = typeDef.childXmlNames[i];
        const xmlFragmentName = xmlFragmentNames[i];
        const decomposition = new describeMetadataDecompositionConfig_1.DescribeMetadataDecomposedSubtypeConfig();
        decomposition.metadataName = metadataName;
        decomposition.metadataEntityNameElement = _getMetadataEntityNameElement(typeDef, xmlFragmentName);
        decomposition.xmlFragmentName = xmlFragmentName;
        decomposition.defaultDirectory = typeDef.isGlobal ? typeDef.defaultDirectory : xmlFragmentName;
        decomposition.ext = _getDecompositionExtensionFromFragmentName(typeDef, xmlFragmentName);
        decomposition.hasStandardMembers = metadataName === 'CustomField';
        decomposition.isAddressable = typeDef.metadataName !== 'CustomObjectTranslation';
        typeDef.decompositionConfig.decompositions.push(decomposition);
    }
};
const _addVirtualTypeDefs = function (typeDefs, parentTypeDef, xmlFragmentNames) {
    parentTypeDef.hasVirtualSubtypes = true;
    for (let i = 0; i < parentTypeDef.childXmlNames.length; ++i) {
        const metadataName = parentTypeDef.childXmlNames[i];
        if (util.isNullOrUndefined(typeDefs[metadataName])) {
            const xmlFragmentName = xmlFragmentNames[i];
            const typeDef = {};
            typeDef.parent = parentTypeDef;
            typeDef.metadataName = metadataName;
            typeDef.defaultDirectory = typeDef.isGlobal ? typeDef.defaultDirectory : xmlFragmentName;
            typeDef.ext = _getDecompositionExtensionFromFragmentName(typeDef.parent, xmlFragmentName);
            typeDef.hasStandardMembers = metadataName === 'CustomField';
            typeDef.hasContent = false;
            typeDef.contentIsBinary = false;
            typeDef.isAddressable = typeDef.parent.metadataName !== 'CustomObjectTranslation';
            typeDef.isSourceTracked = typeDef.parent.metadataName !== 'CustomObjectTranslation';
            typeDef.nameForMsgs = metadataName.replace(/([A-Z])/g, ' $1').trim();
            typeDef.nameForMsgsPlural = typeDef.nameForMsgs.endsWith('s') ? `${typeDef.nameForMsgs}es` : `${typeDef.nameForMsgs}s`;
            typeDefs[typeDef.metadataName] = typeDef;
        }
    }
};
const _getXmlFragmentNamesWithComplexType = function (typeDef, json) {
    const complexType = _findComplexType(json.definitions.types['xsd:schema']['xsd:complexType'], typeDef.metadataName);
    return _getXmlFragmentNames(complexType, typeDef.childXmlNames);
};
const _augmentMetadataInfosWithDecompositions = function (typeDefs) {
    return _getMetadataWsdlJson()
        .then((json) => {
        Object.keys(typeDefs).forEach((metadataName) => {
            const typeDef = typeDefs[metadataName];
            const globalMetadataTypes = ['CustomLabels'];
            if (typeDef.metadataName === 'CustomObjectTranslation') {
                typeDef.childXmlNames = ['CustomFieldTranslation'];
            }
            typeDef.hasVirtualSubtypes = false;
            if (typeDef.metadataName === 'SharingRules') {
                _addVirtualTypeDefs(typeDefs, typeDef, _getXmlFragmentNamesWithComplexType(typeDef, json));
            }
            if (typeDef.metadataName === 'CustomObjectTranslation') {
                typeDef.decompositionConfig = new customObjectTranslationDecompositionConfig_1.CustomObjectTranslationDecompositionConfig(typeDef, typeDef.metadataName, typeDef.isGlobal, typeDef.isEmptyContainer);
            }
            else if (typeDef.metadataName === 'CustomObject') {
                typeDef.decompositionConfig = new describeMetadataDecompositionConfig_1.DescribeMetadataDecompositionConfig(typeDef, typeDef.metadataName, typeDef.isGlobal, typeDef.isEmptyContainer, true);
            }
            else if (typeDef.metadataName === 'StaticResource') {
                typeDef.decompositionConfig = new staticResourceDecompositionConfig_1.StaticResourceDecompositionConfig(typeDef, typeDef.metadataName, typeDef.isGlobal, typeDef.isEmptyContainer);
            }
            else if (typeDef.inFolder) {
                typeDef.decompositionConfig = new inFolderDecompositionConfig_1.InFolderDecompositionConfig(typeDef, typeDef.metadataName, typeDef.isGlobal, typeDef.isEmptyContainer);
            }
            else {
                typeDef.decompositionConfig = new nonDecomposedContentAndMetadataDecompositionConfig_1.NonDecomposedContentAndMetadataDecompositionConfig(typeDef, typeDef.metadataName, typeDef.isGlobal, typeDef.isEmptyContainer);
            }
            if (_isWhitelistedForDecomposition(typeDef) && _hasChildXmlNames(typeDef)) {
                const complexType = _findComplexType(json.definitions.types['xsd:schema']['xsd:complexType'], typeDef.metadataName);
                if (!util.isNullOrUndefined(complexType)) {
                    const xmlFragmentNames = _getXmlFragmentNames(complexType, typeDef.childXmlNames);
                    _addMetadataDecompositions(typeDef, xmlFragmentNames);
                    typeDef.decompositionConfig.isEmptyContainer = _isEmptyContainer(complexType, typeDef.childXmlNames);
                    typeDef.decompositionConfig.isGlobal = globalMetadataTypes.includes(typeDef.metadataName);
                    _addVirtualTypeDefs(typeDefs, typeDef, xmlFragmentNames);
                }
            }
        });
        return typeDefs;
    });
};
const _typeDefMatchesDecompositionExtension = function (typeDef, typeExtension) {
    if (!util.isNullOrUndefined(typeDef.decompositionConfig) && !util.isNullOrUndefined(typeDef.decompositionConfig.decompositions)) {
        for (const decomposition of typeDef.decompositionConfig.decompositions) {
            if (decomposition.ext.toLowerCase() === typeExtension.toLowerCase()) {
                return true;
            }
        }
    }
    return false;
};
const _typeDefMatchesExtension = function (typeDef, typeExtension, includeDecomposedSubtypes) {
    if (!util.isNullOrUndefined(typeDef.ext) && typeDef.ext.toLowerCase() === typeExtension) {
        return true;
    }
    else if (includeDecomposedSubtypes) {
        return _typeDefMatchesDecompositionExtension(typeDef, typeExtension);
    }
    else {
        return false;
    }
};
const _getDecompositionByName = function (typeDefs, value) {
    if (util.isNullOrUndefined(value)) {
        return null;
    }
    let foundDecomposition;
    Object.keys(typeDefs).forEach((key) => {
        if (!util.isNullOrUndefined(typeDefs[key].decompositionConfig)) {
            typeDefs[key].decompositionConfig.decompositions.forEach((decomposition) => {
                if (decomposition.metadataName === value) {
                    foundDecomposition = decomposition;
                }
            });
        }
    });
    return util.isNullOrUndefined(foundDecomposition) ? null : foundDecomposition;
};
class MetadataRegistry {
    constructor(org) {
        this.org = org;
        this.typeDefs = this.getMetadataTypeDefs();
        this.lightningDefTypes = _lightningDefTypes;
        this.typeDefsByExtension = this.getTypeDefsByExtension();
        this.metadataFileExt = METADATA_FILE_EXT;
    }
    isSupported(metadataName) {
        if (BlacklistManager.isBlacklisted(metadataName)) {
            return false;
        }
        const isSupportedType = !util.isNullOrUndefined(this.getTypeDefinitionByMetadataName(metadataName));
        if (isSupportedType) {
            return true;
        }
        const decomposedSubtype = _getDecompositionByName(this.typeDefs, metadataName);
        return !util.isNullOrUndefined(decomposedSubtype) && decomposedSubtype.isAddressable;
    }
    static getMetadataFileExt() {
        return METADATA_FILE_EXT;
    }
    static initializeMetadataTypeInfos(orgApi) {
        const scratchOrg = !util.isNullOrUndefined(orgApi) ? orgApi : new ScratchOrg();
        const force = scratchOrg.force;
        const appConfig = force.getConfig().getAppConfig();
        const sourceApiVersion = optional.ofNullable(appConfig.sourceApiVersion).orElse(force.getConfig().getApiVersion());
        // If a new org is created above, make sure we resolve the default name
        return scratchOrg.resolveDefaultName()
            .then(() => force.mdapiDescribe(scratchOrg, sourceApiVersion))
            .then(describeResults => _createMetadataInfos(describeResults))
            .then(typeDefs => _augmentMetadataInfosWithDecompositions(typeDefs))
            .then(typeDefs => {
            const metadataInfosFile = scratchOrg.getMetadataTypeInfos();
            metadataInfosFile.delete();
            const metadataInfos = {
                sourceApiVersion,
                typeDefs
            };
            return metadataInfosFile.write(metadataInfos);
        })
            .then(() => Promise.resolve())
            .catch((err) => {
            if (err.message === 'Unsupported state or unable to authenticate data') {
                err.message = messages(force.getConfig().getLocale()).getMessage('authorizeCommandError');
            }
            if (err.name === 'NoOrgFound') {
                const locale = force.getConfig().getLocale();
                if (err.message === messages(locale).getMessage('defaultOrgNotFound')) {
                    err.message = `${err.message}. ${messages(locale).getMessage('manifestCreateOrgRequired')}`;
                }
                else {
                    const splitString = err.message.split(' ');
                    err.name = 'NamedOrgNotFound';
                    err.message = messages(locale).getMessage('namedOrgNotFound', splitString[splitString.length - 1]);
                }
            }
            return Promise.reject(err);
        });
    }
    handleIfSharingRuleElement(sourceElement) {
        const sharingRules = this.typeDefs.SharingRules;
        if (sharingRules.childXmlNames.indexOf(sourceElement.type) >= 0) {
            sourceElement.type = sharingRules.metadataName;
            sourceElement.fullName = sourceElement.fullName.substring(0, sourceElement.fullName.indexOf('.'));
        }
        return sourceElement;
    }
    getMetadataTypeDefs() {
        if (util.isNullOrUndefined(this.typeDefs)) {
            const metadataInfos = this.org.getMetadataTypeInfos();
            try {
                const infos = metadataInfos.read();
                return infos.typeDefs;
            }
            catch (error) {
                throw srcDevUtil.processReadAndParseJsonFileError(error, metadataInfos.path);
            }
        }
        else {
            return this.typeDefs;
        }
    }
    getTypeDefsByExtension() {
        const typeDefsByExtension = new Map();
        Object.keys(this.typeDefs).forEach((metadataName) => {
            const metadataTypeExtension = this.typeDefs[metadataName].ext;
            typeDefsByExtension.set(metadataTypeExtension, this.typeDefs[metadataName]);
        });
        return typeDefsByExtension;
    }
    getLightningDefByFileName(fileName) {
        return this.lightningDefTypes[Object.keys(this.lightningDefTypes).find(key => {
            const lightningDefType = this.lightningDefTypes[key];
            return fileName.endsWith(lightningDefType.fileSuffix);
        })];
    }
    getLightningDefByType(type) {
        return this.lightningDefTypes[Object.keys(this.lightningDefTypes).find(key => {
            const lightningDefType = this.lightningDefTypes[key];
            return type === lightningDefType.defType;
        })];
    }
    /**
     * Returns the array of typeDefs where the default directory of each typeDef matches the passed in 'name' param
     * @param name
     * @returns {any[]}
     */
    getTypeDefinitionsByDirectoryName(name) {
        const metadataNames = Object.keys(this.typeDefs).filter(key => this.typeDefs[key].defaultDirectory === name);
        return metadataNames.map(metadataName => this.typeDefs[metadataName]);
    }
    getTypeDefinitionByMetadataName(metadataName) {
        let typeDef = this.typeDefs[metadataName];
        if (util.isNullOrUndefined(typeDef) && metadataName.endsWith('Settings')) {
            // even though there is one "Settings" in the describeMetadata response when you retrieve a setting it comes
            // down as "AccountSettings", "CaseSettings", etc. so here we account for that scenario.
            typeDef = this.typeDefs['Settings'];
        }
        return typeDef;
    }
    // given file extension, return type def
    getTypeDefinitionByFileName(fileName, useTrueExtType) {
        if (util.isNullOrUndefined(fileName)) {
            return null;
        }
        if (fileName.includes(`${path.sep}aura${path.sep}`)) {
            return this.typeDefs.AuraDefinitionBundle;
        }
        if (fileName.includes(`${path.sep}${this.typeDefs.CustomSite.defaultDirectory}${path.sep}`)) {
            return this.typeDefs.CustomSite;
        }
        // CustomObject file names are special, they are all named "object-meta.xml"
        if (path.basename(fileName) === this.typeDefs.CustomObject.ext + this.metadataFileExt) {
            return this.typeDefs.CustomObject;
        }
        const typeDefWithNonStandardExtension = this.getTypeDefinitionByFileNameWithNonStandardExtension(fileName);
        if (!_.isNil(typeDefWithNonStandardExtension)) {
            return typeDefWithNonStandardExtension;
        }
        if (fileName.endsWith(this.metadataFileExt)) {
            fileName = fileName.substring(0, fileName.indexOf(this.metadataFileExt));
        }
        let typeExtension = path.extname(fileName);
        if (util.isNullOrUndefined(typeExtension)) {
            return null;
        }
        typeExtension = typeExtension.replace('.', '');
        let typeDef = this.typeDefsByExtension.get(typeExtension);
        if (!_.isNil(typeDef)) {
            if (!_.isNil(useTrueExtType) && useTrueExtType) {
                return typeDef;
            }
            if (!_.isNil(typeDef.parent)) {
                return typeDef.parent;
            }
            return typeDef;
        }
        return null;
    }
    getDecompositionDefinitionByFileName(fileName) {
        let typeDef = this.getTypeDefinitionByFileName(fileName);
        if (!util.isNullOrUndefined(typeDef)) {
            if (!util.isNullOrUndefined(typeDef.parent)) {
                typeDef = typeDef.parent;
            }
            if (!util.isNullOrUndefined(typeDef.decompositionConfig)) {
                if (fileName.endsWith(this.metadataFileExt)) {
                    fileName = fileName.substring(0, fileName.indexOf(this.metadataFileExt));
                }
                let typeExtension = path.extname(fileName);
                typeExtension = typeExtension.substring(1);
                for (const decomposition of typeDef.decompositionConfig.decompositions) {
                    if (decomposition.ext.toLowerCase() === typeExtension.toLowerCase()) {
                        return decomposition;
                    }
                }
            }
        }
        return null;
    }
    // A document must be co-resident with its metadata file.
    // A file from an exploded zip static resource must be within a directory that is co-resident with its metadata file.
    getTypeDefinitionByFileNameWithNonStandardExtension(fileName, isDirectoryPathElement, typeDefsToCheck) {
        const supportedTypeDefs = [this.typeDefs.Document, this.typeDefs.StaticResource];
        const candidateTypeDefs = util.isNullOrUndefined(typeDefsToCheck) ? supportedTypeDefs : typeDefsToCheck;
        let typeDef = this.getTypeDefinitionByFileNameWithCoresidentMetadataFile(fileName, candidateTypeDefs, false);
        if (util.isNullOrUndefined(typeDef) && candidateTypeDefs.includes(this.typeDefs.StaticResource)) {
            typeDef = this.getTypeDefinitionByFileNameWithCoresidentMetadataFile(path.dirname(fileName), [this.typeDefs.StaticResource], true);
        }
        if (util.isNullOrUndefined(typeDef)) {
            typeDef = this.getTypeDefinitionByFileNameMatchingDefaultDirectory(fileName, isDirectoryPathElement, candidateTypeDefs);
        }
        return typeDef;
    }
    getTypeDefinitionByFileNameWithCoresidentMetadataFile(fileName, typeDefsToCheck, recurse) {
        const dir = path.dirname(fileName);
        if (this.isDirPathExpended(dir)) {
            return null;
        }
        const fullName = path.basename(fileName, path.extname(fileName));
        const typeDef = typeDefsToCheck.find((typeDef) => srcDevUtil.pathExistsSync(path.join(dir, `${fullName}.${typeDef.ext}${this.metadataFileExt}`)));
        if (!util.isNullOrUndefined(typeDef)) {
            return typeDef;
        }
        return recurse ? this.getTypeDefinitionByFileNameWithCoresidentMetadataFile(dir, typeDefsToCheck, true) : null;
    }
    getTypeDefinitionByFileNameMatchingDefaultDirectory(fileName, isDirectoryPathElement, typeDefsToCheck) {
        const dir = path.dirname(fileName);
        if (this.isDirPathExpended(dir)) {
            return null;
        }
        if (typeDefsToCheck.includes(this.typeDefs.Document) && !isDirectoryPathElement) {
            const pathElements = fileName.split(path.sep);
            if (pathElements.length >= 3 && pathElements[pathElements.length - 3] === this.typeDefs.Document.defaultDirectory) {
                return this.typeDefs.Document;
            }
        }
        if (typeDefsToCheck.includes(this.typeDefs.StaticResource)) {
            if (isDirectoryPathElement) {
                if (path.basename(fileName) === this.typeDefs.StaticResource.defaultDirectory) {
                    return this.typeDefs.StaticResource;
                }
            }
            return this.getTypeDefinitionByFileNameMatchingDefaultDirectory(dir, true, [this.typeDefs.StaticResource]);
        }
        return null;
    }
    isDirPathExpended(dir) {
        return util.isNullOrUndefined(dir) || dir === path.parse(dir).root || dir === '.';
    }
    isValidAuraSuffix(suffix) {
        const auraTypeDefKey = Object.keys(this.lightningDefTypes).find(key => {
            const fileSuffix = this.lightningDefTypes[key].fileSuffix;
            return fileSuffix && fileSuffix === suffix;
        });
        return !util.isNullOrUndefined(auraTypeDefKey);
    }
    isValidMetadataExtension(ext) {
        const extWithoutPeriod = ext.replace('.', '');
        const isValidMetadataExtension = !util.isNullOrUndefined(this.typeDefsByExtension.get(extWithoutPeriod));
        return isValidMetadataExtension || this.isValidAuraSuffix(ext);
    }
    isValidDecompositionExtension(ext) {
        const extWithoutPeriod = ext.replace('.', '');
        const includeDecomposedSubtypes = true;
        const typeDefKey = Object.keys(this.typeDefs).find(key => _typeDefMatchesExtension(this.typeDefs[key], extWithoutPeriod, includeDecomposedSubtypes));
        const typeDef = this.typeDefs[typeDefKey];
        return !util.isNullOrUndefined(typeDefKey) && typeDef.ext.toLowerCase() !== extWithoutPeriod.toLowerCase();
    }
    isValidSourceFilePath(sourcePath) {
        let fileName = path.basename(sourcePath);
        if (fileName.endsWith(this.metadataFileExt)) {
            fileName = fileName.substring(0, fileName.indexOf(this.metadataFileExt));
        }
        // Aura is special
        if (sourcePath.includes(`${path.sep}aura${path.sep}`)) {
            const cmpName = path.basename(path.dirname(sourcePath));
            const suffix = fileName.substring(cmpName.length, fileName.length);
            return this.isValidAuraSuffix(suffix);
        }
        else {
            const ext = path.extname(fileName);
            if (!util.isNullOrUndefined(ext) && ext.length > 0) {
                return this.isValidMetadataExtension(ext) || this.isValidDecompositionExtension(ext) || this.getTypeDefinitionByFileNameWithNonStandardExtension(sourcePath) !== null;
            }
            else {
                return this.isValidMetadataExtension(fileName) || this.getTypeDefinitionByFileNameMatchingDefaultDirectory(sourcePath, false, [this.typeDefs.Document, this.typeDefs.StaticResource]) !== null;
            }
        }
    }
    isCustomName(name) {
        const customNameRegex = new RegExp(/.*__.$/);
        return customNameRegex.test(name);
    }
}
module.exports = MetadataRegistry;

//# sourceMappingURL=metadataRegistry.js.map
