Buffer.prototype.writeUInt64BE = function(value, pointer) {

	//console.log("writeUInt64BE: "+value);
	//console.log('Pointer: '+pointer);
	//console.log('Buffer length: '+this.length);

	var bigNumberAsBinaryStr = value.toString(2); // '100000000000000000000000000000000000000000000000000000'
	// Convert the above binary str to 64 bit (actually 52 bit will work) by padding zeros in the left
	var bigNumberAsBinaryStr2 = ''; 
	for (var i = 0; i < 64 - bigNumberAsBinaryStr.length; i++) {
	bigNumberAsBinaryStr2 += '0'; 
	}; 

	bigNumberAsBinaryStr2 += bigNumberAsBinaryStr;

	var lowInt = parseInt(bigNumberAsBinaryStr2.substring(0, 32), 2);
	var highInt = parseInt(bigNumberAsBinaryStr2.substring(32), 2);
	//console.log(lowInt);
	//console.log(highInt)
	this.writeUInt32BE(lowInt, pointer);
	this.writeUInt32BE(highInt, pointer+4);
};
Buffer.prototype.readUInt64BE = function(pointer) {
	var lowInt = this.readUInt32BE(pointer);
	var highInt = this.readUInt32BE(pointer+4);

	return  (lowInt * Math.pow(2, 32) + highInt);
};
if (!('toJSON' in Error.prototype))
	Object.defineProperty(Error.prototype, 'toJSON', {
	    value: function () {
	        var alt = {};

	        Object.getOwnPropertyNames(this).forEach(function (key) {
	            alt[key] = this[key];
	        }, this);

	        return alt;
	    },
	    configurable: true,
	    writable: true
	});
/*
*	PRIVATE VARIABLES
*/
var TYPE_STRING = 10,
	TYPE_INTEGER = 20,
	TYPE_INTEGER64 = 21,
	TYPE_BOOL = 22,
	TYPE_FLOAT = 25,
	TYPE_OBJECT = 30,
	TYPE_ARRAY = 40,
	TYPE_BUFFER = 50,
	TYPE_UNDEFINED = 70,
	TYPE_NULL = 75;
var CHAR_SIZE =2, 
	TYPE_SIZE = 1, 
	PARAM_LENGTH = 4;

/*
*	METHODS FOR CREATING/READING BUFFER
*/
function isType(value) {
	if (value === undefined) {
		return TYPE_UNDEFINED;
	}
	if ( value === null) {
		return TYPE_NULL;
	}
	if(typeof value == 'object'){
		if (Array.isArray(value)) {
			return TYPE_ARRAY;
		}else if(typeof File != 'undefined' && value instanceof File){
			return TYPE_BUFFER;
		}else{
			return TYPE_OBJECT;
		}
	}else if (typeof value == 'number') {
		if (Number.isInteger(value))
			if ( bytesSizeInt(value) === 8 )
				return TYPE_INTEGER64;
			else
				return TYPE_INTEGER;
		else
			return TYPE_FLOAT;
	}else if (typeof value == 'string') {
		return TYPE_STRING;
	}else if (typeof value == 'boolean') {
		return TYPE_BOOL;
	}
	return TYPE_UNDEFINED;
}
function bytesSizeInt(value){
	var size = Math.ceil((Math.log(value)/Math.log(2))/8);
	if(size <= 1){
		return 2;
	}else if (size <=2) {
		return 2;
	}else if (size <=4){
		return 4;
	}else{
		return 8;
	}
}
const Buff_Nums = {
	dv8: new Buffer(8),
	dv16: new Buffer(16),
	dv32: new Buffer(32),
	dv64: new Buffer(64),
}
function bytesSizeInt(value){
	var sizes = ['Int8', 'Int16BE', 'Int32BE', 'UInt64BE'];
	var numberType = sizes.find(s=>{
		try{
			Buff_Nums.dv64[`write${s}`](value, 0);
			return Buff_Nums.dv64[`read${s}`](0) == value;
		}catch(er){
			return false
		}
	})
	switch(numberType){
		case 'Int8':
			return 1
		break;
		case 'Int16BE':
			return 2
		break;
		case 'Int32BE':
			return 4
		break;

		case 'UInt64BE':
			return 8
		break;
	}
}
function bytesSize(value) {
	var typeId = isType(value);
	switch(typeId){
		case TYPE_UNDEFINED:
			return 0;
		break;
		case TYPE_NULL:
			return 0;
		break;
		case TYPE_STRING:
			return value.length * CHAR_SIZE;
		break;
		case TYPE_BOOL:
			return 1;
		break;
		case TYPE_INTEGER:
			return bytesSizeInt(value);
		break;
		case TYPE_INTEGER64:
			return 8;
		break;
		case TYPE_FLOAT:
			return 4;
		break;
		case TYPE_OBJECT:
			value = JSON.stringify( value );
			if (value) return value.length * CHAR_SIZE;
			else return 0;
		break;
		case TYPE_ARRAY:
			value = JSON.stringify( value );
			if (value) return value.length * CHAR_SIZE;
			else return 0;
		break;
		case TYPE_BUFFER:
			return value.byteLength;
		break;
		default:
			console.log('--- ERROR UNDEFINED TYPE ---');
			return 0;
	}
	return 0;
}
function readString(buffer, pointer, size) {
	var end = pointer + size;
	var val = '';
	for (pointer; pointer < end; pointer+=CHAR_SIZE) {
		switch(CHAR_SIZE){
			case 1:
				val += String.fromCharCode( buffer.readInt8(pointer) );
			break;
			case 2:
				val += String.fromCharCode( buffer.readUInt16BE(pointer) );
			break;
		}
	}
	return val;
}
function readArgument(buffer, start) {
	//console.log('+++ Fetching argument +++');//LV1
	//console.log('* pointer: '+start);//LV1

	var var_bytes, typeId;
	var result = {
		pointer: start
	};
	if (result.pointer+PARAM_LENGTH >= buffer.byteLength ) 
		return buffer.byteLength;

	switch(PARAM_LENGTH){
		case 1:
			var_bytes = buffer.readInt8(result.pointer);
		break;
		case 2:
			var_bytes = buffer.readInt16BE(result.pointer);
		break;
		case 4:
			var_bytes = buffer.readInt32BE(result.pointer);
		break;
	}
	var_bytes = parseInt(var_bytes);

	result.pointer += PARAM_LENGTH;
	//console.log('* Var bytes: '+var_bytes); //LV2

	typeId = buffer.readInt8(result.pointer);
	result.pointer++;
	console.log('* TypeId: '+typeId); //LV2

	if (typeId == TYPE_UNDEFINED || typeId == TYPE_NULL ) {
		//console.log('* Value: '+ result.value); //LV2
		result.value = typeId == TYPE_UNDEFINED? undefined:null;
		return result;
	}

	switch(typeId){
		case TYPE_STRING:
			result.value = readString(buffer, result.pointer, var_bytes);
		break;
		case TYPE_INTEGER:
			switch(var_bytes){
				case 1:
					result.value = buffer.readInt8(result.pointer);
				break;
				case 2:
					result.value = buffer.readInt16BE(result.pointer);
				break;
				case 4:
					result.value = buffer.readInt32BE(result.pointer);
				break;
				case 8:
					result.value = buffer.readUInt64BE(result.pointer);
				break;
			}
		break;
		case TYPE_INTEGER64:
			result.value = buffer.readUInt64BE(result.pointer);
		break;
		case TYPE_BOOL:
			console.log('-> Read as boolean');
			result.value = buffer.readInt8(result.pointer) === 1? true:false;
		break;
		case TYPE_FLOAT:
			console.log('-> Read as FloatBE');
			result.value = buffer.readFloatBE(result.pointer);
		break;
		case TYPE_OBJECT:
			try{
				result.value = JSON.parse( readString(buffer, result.pointer, var_bytes) );
			}catch(err){
				console.log('--- Error parsing string to object ---');
				console.log(err)
			}
		break;
		case TYPE_ARRAY:
			try{
				result.value = JSON.parse( readString(buffer, result.pointer, var_bytes) );
			}catch(err){
				console.log('--- Error parsing string to Array ---');
				console.log(err)
			}
		break;
		case TYPE_BUFFER:
			try{
				result.value = buffer.buffer.slice(result.pointer, result.pointer+(var_bytes-1) );
			}catch(er){
				console.log('--- ERROR SPLICE BUFFER ---');
				console.log(er);
			}
		break;
		default:
			console.log('--- ERROR UNDEFINED TYPE ---');
			result.pointer == buffer.byteLength;
			return result.pointer;
	}
	result.pointer += var_bytes;

	//console.log('* Value: '+ result.value);

	return result;
}
function writeString(buffer, pointer, val) {
	var start=pointer;
	for (pointer, s=0; s < val.length; pointer+=CHAR_SIZE, s++) {
		if(pointer < buffer.byteLength && s < val.length){
			try{
				switch(CHAR_SIZE){
					case 1:
						buffer.writeInt8(val.charCodeAt(s), pointer);
					break;
					case 2:
						buffer.writeUInt16BE(val.charCodeAt(s), pointer);
					break;
				}
			}catch(err){
				console.log('--- Error writing on buffer ---');
				console.log('* Char Code: '+val.charCodeAt(s));
				console.log('* Pointer: '+pointer);
				console.log(err);
			}
		}
		else{
			console.log('---	ERROR Can´t WRITE ON BUFFER OUT OF SIZE ---');
			console.log('Buffer Size: '+buffer.byteLength);
			console.log('Tring index: '+pointer);
			console.log('---	ERROR Can´t READ FROM STRING OUT OF SIZE ---');
			console.log('String Size: '+val.length);
			console.log('Tring index: '+s);
			break;
		}
	}
	//console.log("* Writen String: "+ val.substr(0, 600));
	//console.log('* Read test: '+readString(buffer, start, bytesSize(val)));
	return pointer;
}
function writeOnBuffer(buffer, start, val, var_bytes) {
	//console.log('+++ WRITING PARAMETER +++');
	//console.log('* Value: '+val);

	var typeId = isType(val);
	var result = {
		pointer: start
	}
	//console.log('* TypeId: '+typeId);
	//console.log('* Pointer: '+result.pointer);

	//	WRITE THE SIZE
	var var_bytes = var_bytes == undefined? bytesSize(val) : var_bytes;
	//console.log('* Var bytes: '+var_bytes);
	switch(PARAM_LENGTH){
		case 1:
			buffer.writeInt8(var_bytes, result.pointer);
		break;
		case 2:
			buffer.writeInt16BE(var_bytes, result.pointer);
		break;
		case 4:
			buffer.writeInt32BE(var_bytes, result.pointer);
		break;
	}
	result.pointer += PARAM_LENGTH;

	//	WRITE THE TYPE
	buffer.writeInt8(typeId, result.pointer); result.pointer++;

	if (typeId == TYPE_UNDEFINED || typeId == TYPE_NULL) {
		//console.log('* Undefined parameter.');
		return result.pointer;
	}

	switch(typeId){
		case TYPE_STRING:
			writeString(buffer, result.pointer, val);
		break;
		case TYPE_INTEGER:
			switch(var_bytes){
				case 1:
					buffer.writeInt8(val, result.pointer);
				break;
				case 2:
					buffer.writeInt16BE(val, result.pointer);
				break;
				case 4:
					buffer.writeInt32BE(val, result.pointer);
				break;
				case 8:
					buffer.writeUInt64BE(val, result.pointer);
				break;
			}
			//console.log('--> Pointer when write: '+result.pointer);
		break;
		case TYPE_INTEGER64:
			buffer.writeUInt64BE(val, result.pointer);
			//console.log('--> Pointer when write: '+result.pointer);
		break;
		case TYPE_BOOL:
			console.log('-> Write as boolean');
			buffer.writeInt8(val, result.pointer);
		break;
		case TYPE_FLOAT:
			buffer.writeFloatBE(val, result.pointer);
		break;
		case TYPE_OBJECT:
			val = JSON.stringify( val );
			writeString(buffer, result.pointer, val);
		break;
		case TYPE_ARRAY:
			val = JSON.stringify( val );
			writeString(buffer, result.pointer, val);
		break;
		case TYPE_BUFFER:
			for (var i = result.pointer, v=0; v < var_bytes; i++,v++) {
				if (v >= val.byteLength) {
					console.log('---	ERROR Can´t readfrom BUFFER OUT OF SIZE ---');
					console.log('Buffer Size: '+val.byteLength);
					console.log('Tring index: '+v);
					break;
				}
				if(i<buffer.byteLength){
					buffer[i] = val[v];
				}
				else{
					console.log('---	ERROR Can´t WRITE ON BUFFER OUT OF SIZE ---');
					console.log('Buffer Size: '+buffer.byteLength);
					console.log('Tring index: '+i);
					break;
				}
			}
		break;
		case TYPE_UNDEFINED:
			//buffer.writeInt8(val, result.pointer);
		break;
		default:
			console.log('--- ERROR UNDEFINED TYPE ---');
	}
	result.pointer += var_bytes;
	if (typeId == TYPE_INTEGER64) {
		console.log("Test qeui")
		console.log(readArgument(buffer, start));
	}

	return result.pointer;
}
function readFromBuffer(buffer) {
	//console.log('+++ Start reading buffer +++');
	//console.log('Size: '+buffer.byteLength);
	//console.log(buffer);
	var obj = {
		taskId:0,
		methodName: '',
		arguments: []
	};
	var tm_size, tm_type, tm_arg, pointer=0;

	// FIND OUT THE TASK ID
	tm_arg = readArgument(buffer, pointer);
	pointer = tm_arg.pointer;
	obj.taskId = tm_arg.value;

	// FIND OUT THE METHOD NAME
	tm_arg = readArgument(buffer, pointer);
	pointer = tm_arg.pointer;
	obj.methodName = tm_arg.value;

	//	START FETCHING THE ARGUMENTS FROM THE BUFFER
	while(pointer < buffer.byteLength){
		tm_arg = readArgument(buffer, pointer);
		pointer = tm_arg.pointer;
		obj.arguments.push(tm_arg.value);
	};
	return obj;
}
function createBuffer(obj) {
	/*
	*	[taskID, methodName, arguments]
	*/
	var buffer, buffer_size=0;
	var parameters = [obj.taskId, obj.methodName].concat(obj.arguments);

	//	SIZE OF THE ARGUMENTS.
	//console.log('* Calculating Buffer Size:'); //LV1
	parameters.map(function (parameter) {
		var size = bytesSize(parameter);
		//console.log('+++ Parameter');//LV2
		//console.log('	-> Value: '+ parameter);//LV2
		//console.log('	-> Size: '+ size);//LV2
		var param_size = bytesSize(size);
		if (param_size > Math.pow(2,(2+PARAM_LENGTH) ) ) {
			//console.log('---	ERROR MAX OF PARAMETER SIZE ---');
		}

		//	SIZE OF THE ARGUMENT + IT'S OWN TYPE SIZE.
		buffer_size += size + TYPE_SIZE +PARAM_LENGTH;
	});

	/*
	*	CREATE THE BUFFER.
	*/
	//console.log('+++ CREATING BUFFER +++');//LV2
	buffer = new Buffer(buffer_size);
	//console.log('Size: '+buffer_size);//LV2
	var pointer=0;

	/*
	*	START FILL IN THE BUFFER
	*/
	parameters.map(function (parameter) {
		pointer = writeOnBuffer(buffer, pointer, parameter);
	});

	return buffer;
}
function generateInterval(k) {
	var maxInterval = (Math.pow(2, k) - 1) * 1000;

	if (maxInterval > 30*1000) {
	maxInterval = 30*1000; // If the generated interval is more than 30 seconds, truncate it down to 30 seconds.
	}

	// generate the interval to a random number between 0 and the maxInterval determined from above
	return Math.random() * maxInterval; 
}
module.exports = {
	readFromBuffer: readFromBuffer,
	createBuffer: createBuffer,
	generateInterval: generateInterval
}