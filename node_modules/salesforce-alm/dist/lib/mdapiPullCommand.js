/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
const path = require('path');
const Promise = require('bluebird');
const util = require('util');
const messages = require(path.join(__dirname, 'messages'))();
const almError = require(path.join(__dirname, 'almError'));
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil.js'));
const MdapiPullApi = require(path.join(__dirname, 'mdapiPullApi'));
const syncCommandHelper = require(path.join(__dirname, 'syncCommandHelper'));
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const consts = require(path.join(__dirname, 'constants'));
const logger = require(path.join(__dirname, 'logApi'));
class MdapiPullCommand {
    constructor() {
        this.logger = logger.child('source:pull');
    }
    validate(context) {
        this.scratchOrg = context.org;
        this.force = this.scratchOrg.force;
        const fixedContext = srcDevUtil.fixCliContext(context);
        if (!util.isNullOrUndefined(fixedContext.wait)) {
            if (srcDevUtil.isInt(fixedContext.wait)) {
                fixedContext.wait = parseInt(fixedContext.wait);
                if (fixedContext.wait < consts.MIN_SRC_WAIT_MINUTES) {
                    return Promise.reject(almError('mdapiCliInvalidNumericParam', 'wait'));
                }
            }
            else {
                return Promise.reject(almError('mdapiCliInvalidNumericParam', 'wait'));
            }
        }
        return Promise.resolve(fixedContext);
    }
    getPreExecuteMessage({ orgId, username }) {
        return messages.getMessage('pullCommandCliPreExecute', [orgId, username]);
    }
    execute(context) {
        const rows = [];
        const projectPath = this.force.config.getProjectPath();
        let mdapiPull;
        return MetadataRegistry.initializeMetadataTypeInfos(this.scratchOrg)
            .then(() => {
            mdapiPull = new MdapiPullApi(this.scratchOrg);
            context.unsupportedMimeTypes = []; // for logging unsupported static resource mime types
            return mdapiPull.doPull(context);
        })
            .catch(e => {
            if (e.name === 'SourceConflict') {
                const error = almError('sourceConflictDetected');
                e.sourceConflictElements.forEach(sourceElement => syncCommandHelper.createConflictRows(rows, sourceElement, projectPath));
                error.columns = syncCommandHelper.getColumnMetaInfo(messages);
                error.result = rows;
                this.logger.error(messages.getMessage('pullCommandConflictMsg'));
                throw error;
            }
            else {
                throw e;
            }
        })
            .then((result) => {
            if (!util.isNullOrUndefined(result)) {
                result.inboundFiles.forEach((sourceItem) => syncCommandHelper.createDisplayRows(rows, sourceItem, projectPath, false));
            }
        })
            .then(() => this.logger.styledHeader(this.logger.color.blue(messages.getMessage('pullCommandHumanSuccess'))))
            .then(() => {
            srcDevUtil.logUnsupportedMimeTypeError(context.unsupportedMimeTypes, this.logger, this.force);
        })
            .then(() => (context.json ? { pulledSource: rows } : rows));
    }
    /**
     * this indicated to index.js this command should produce tabular output.
     * @returns {*[]}
     */
    getColumnData() {
        return syncCommandHelper.getColumnMetaInfo(messages);
    }
}
module.exports = MdapiPullCommand;

//# sourceMappingURL=mdapiPullCommand.js.map
