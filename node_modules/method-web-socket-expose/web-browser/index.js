/*
*   MODULE EVENTS HANDLER
*   OBJECT  -> jEvents {}
*   METHODS -> addEvent(HTMLElemet, eventName, function);
*/

function msToSeg(ms) {
  return (ms/1000);
}
var jWS = (function () {
  BufferStream();

  function generateInterval (k) {
    var maxInterval = (Math.pow(2, k) - 1) * 1000;

    if (maxInterval > 30*1000) {
      maxInterval = 30*1000; // If the generated interval is more than 30 seconds, truncate it down to 30 seconds.
    }

    // generate the interval to a random number between 0 and the maxInterval determined from above
    return Math.random() * maxInterval; 
  }
  function init () {
    //  ADD THE EVENTS
    this.ws.onopen = openController.bind(this);
    this.ws.onmessage = dataController.bind(this);
    this.ws.onclose = closeController.bind(this);
    this.ws.onerror = errorController.bind(this);
    return this;
  }
  function callMethod (name) {
    var _this = this;
    var toSend = {
      methodName:name,
      arguments:[]
    };
    if(arguments.length > 0){
      for (var i = 1; i < arguments.length; i++) {
        toSend.arguments.push(arguments[i]);
      }
    }
    return send.call(this, toSend);
  }
  function syncMethods () {
    return send.call(this,{
      methodName:'syncMethods'
    }).then(methodsR => {
      for (var i in methodsR) {
        var methodName = methodsR[i];

        // DEFINING THE REFLEC OF METHOD 
        this[methodName] = callMethod.bind(this, methodName);
      }
      return this;
    });
  }
  function extracData (data) {
    if (typeof data == 'string') {
      try{
        var data = JSON.parse(data);
        return data;
      }catch(err){
        //console.log(err);
        return null;
      }
    };
  }
  function send (dataObject) {
    if (typeof dataObject != 'object')
      return Promise.reject('Invalid data to send. Err: is not object.');

    return new Promise((resolve, reject)=>{
      dataObject['taskId'] = registerPromise({resolve,reject});
      var dataBuffer = createBuffer(dataObject);

      this.ws.send(dataBuffer, err=>{
        if (err) {
          console.log("## WS AREADY DISCONNECTED ##");
          console.log(err);
          console.trace("Error WebSocketClient")
          reject(err);
        }
      })
    }).catch(err=>{
      removePromise(dataObject.taskId);
      return Promise.reject(err);
    })
  }
  function dataController (data) {
    var _this = this;
    if (data instanceof MessageEvent) data = data.data;
    if (data instanceof Blob){
      var reader = new FileReader();
      reader.onloadend = function(){
        dataController.call(_this, reader.result);
      };
      reader.readAsArrayBuffer(data);
      return 0;
    }

    data = readFromBuffer(data);

    //IT'S IS THE SERVER CALLING FOR EXECUTE A FUNCTION ON THE CLIENT
    if (data.methodName && this[data.methodName]) {
      var work = this[data.methodName];
      var params = data.arguments || [];
      if (Array.isArray(work)) {
        work.forEach(function(_fn){
          _fn.apply(this, params);
        });
      }else if(typeof work == 'function'){
        work.apply(this, params);
      }else{
        console.log("Invalid registed method.");
      }
    }

    //ITÂ´S THE SERVER SENING THE RESULT OF AN EXECUTED FUNCTION
    else if (data.taskId) {
      responseHandler.call(this,data);
    }else{
      //console.log('Non register Function or task.');
    }
  }
  function connect (){
    console.log("***  WS CONNECT  ***");
    var state = this.status.state;
    //var this... AIM TO THE OBJECT WS.
    if (state == "close" || state == "error") {
      this.status.attempts++;
      try{
        this.ws = new WebSocket(this.url);
        this.status.state = "connecting";

        //  STARTING THE INIT METHOD.
        init.call(this);
        console.log('   > Connecting.');
        return this;
      }catch(err){
        console.log(err);
        return null;
      }
    }else{
      console.log('   > Already Connected.');
      return this;
    }
  }
  function reconnect (){
    console.log('-- Reconnecting --');
    return connect.call(this);// CREATE A NEW CONNECTION
  }
  /**
   * TASKS RESPONSE HANDLER
   *
   **/
  var _CACHE_PROMISES= {}, _CACHE_PROMISES_IDS=[];
  function responseHandler(response) {
    if (!response) {
      return 0;
    }
    if (typeof response != 'object') {
      return 0;
    }
    var id= response.taskId;
    var ret = getRegisterPromise(id);
    if (!ret) {
      return 0;
    }
    var argumentsR = response.arguments || [];
    /**
     *  EXECUTE ANY RESPONSE MIDDLEWARE
     **/
    var onResponseMiddleware = this._events.onResponseMiddleware;
    if(Array.isArray(onResponseMiddleware) && onResponseMiddleware.length > 0)
      for (var i = 0; i < onResponseMiddleware.length; i++) {
        var middleRs = onResponseMiddleware[i].apply(argumentsR);
        if (!middleRs) {
          return null;
        }
      }
    if (argumentsR[0]===null) {
      ret.reject(argumentsR[1]);
    }else{
      ret.resolve(argumentsR[0]);
    }
  }
  function guid() {
    return Math.floor((Math.random() * 1024) + 256);
  }
  function registerPromise(promise) {
    promise.createdAt = new Date();
    var id = guid();
    promise.id = id;
    if (_CACHE_PROMISES[id])
      return registerPromise(promise);
    else{
      _CACHE_PROMISES_IDS.push(id);
      _CACHE_PROMISES[id] = promise;
      return id;
    }
  }
  function getRegisterPromise(id) {
    var promise = _CACHE_PROMISES[id];
    if (!promise) {
      return null;
    }
    removePromise(promise);
    return promise;
  }
  function removePromise(promise) {
    var id = promise.id;
    var index = _CACHE_PROMISES_IDS.indexOf(id);
    _CACHE_PROMISES_IDS.splice(index, 1);
    delete _CACHE_PROMISES[id];
  }
  function collectorPromises() {
    var now = new Date();
    _CACHE_PROMISES_IDS.map(function(id, index){
      var promise = _CACHE_PROMISES[id];
      if (!promise)
        return 0;
      var restTime = msToSeg(now - promise.createdAt);

      if (restTime > 15) {
        console.log("## REMOVE PROMISE ##");
        promise.reject("Response timeout.");
        _CACHE_PROMISES_IDS.splice(index, 1);
        delete _CACHE_PROMISES[id];
      }
    });
  }
  setInterval(collectorPromises, 15000);

  /*
  *   EVENTS CONTROLLERS
  */
  function onReadyController () {
    var _this = this;
    if(this.parent && this.parent._events.onReady)
      this.parent._events.onReady.map(function (fn) {
        fn.call(_this);
      });
    if(this._events.onReady)
      this._events.onReady.map(function (fn) {
        fn.call(_this);
      });
  }
  function openController () {
    var _this = this;
    //console.log('WebSocket Opend.');
    syncMethods.call(this).then(onReadyController.bind(this));

    //  UPDATE THE STATE
    this.status.state = 'connected';

    if(this.parent && this.parent._events.onOpen)
      this.parent._events.onOpen.map(function (fn) {
        fn.call(_this);
      });
    if(this._events.onOpen)
      this._events.onOpen.map(function (fn) {
        fn.call(_this);
      });
  }
  function onStateChange (state) {
    var _this = this;
    if(this.parent && this.parent._events.onStateChange)
      this.parent._events.onStateChange.map(function (fn) {
        fn.call(_this, state);
      });
    if(this._events.onStateChange)
      this._events.onStateChange.map(function (fn) {
        fn.call(_this, state);
      });
  }
  function errorController (err) {
    var _this = this;
    //console.log('---  WebSocket Error  ---');
    //console.log(err);

    //  UPDATE THE STATE
    this.status.state = 'close';

    if(this.parent && this.parent._events.onError)
      this.parent._events.onError.map(function (fn) {
        fn.call(_this);
      });
    if(this._events.onError)
      this._events.onError.map(function (fn) {
        fn.call(_this);
      });
  }
  function closeController () {
    var _this = this;
    //console.log('---  WebSocket Closed  ---');

    var st=undefined;
    this.status.state = 'close';

    if(this.parent && this.parent._events.onClose)
      this.parent._events.onClose.map(function (fn) {
        fn.call(_this);
      });
    if(this._events.onClose)
      this._events.onClose.map(function (fn) {
        fn.call(_this);
      });

    if(st === undefined){
      var time = generateInterval(this.status.attempts);
      //  UPDATE THE STATE
      setTimeout(function () {
        if( reconnect.call(_this) ){

        }else{

        }
      },time);
    }
  }

  /*
  *   DEFINIG GETTERS & SETTER
  */
  function getState () {
    return this.status._state;
  }
  function setState (val) {
    this.status._state=val;

    onStateChange.call(this,val);
    return this.status._state;
  }
  function setParam(name, value){
    this.defaultParams[name]=value;
  }
  function setMethod (methodName, fn) {
    if (!this[methodName] || !Array.isArray(this[methodName]))
      this[methodName] = [];

    this[methodName].push(fn);
  }
  function isReady () {
    if (this.status.state == "ready")
      return true;
    else
        return false;
  }
  function removeMethod(methodName, workFn) {
    if (!this[methodName]) {
      return null;
    }
    if ( Array.isArray(this[methodName]) ) {
      var worksFn = this[methodName];
      var indexWork = worksFn.indexOf(workFn);
      worksFn.splice(indexWork, 1);
    }
    return worksFn;
  }
  /*
  *   FOR EVENTS
  */
  function addEventListener(name, fn) {
    switch(name){
      case 'open':
        if (!this._events.onOpen)
          this._events.onOpen = [];
        this._events.onOpen.push(fn);
      break;
      case 'connect':
        if (!this._events.onOpen)
          this._events.onOpen = [];
        this._events.onOpen.push(fn);
      break;
      case 'ready':
        if (!this._events.onReady)
          this._events.onReady = [];
        this._events.onReady.push(fn);
      break;
      case 'close':
        if (!this._events.onClose)
          this._events.onClose = [];
        this._events.onClose.push(fn);
      break;
      case 'error':
        if (!this._events.onError)
          this._events.onError = [];
        this._events.onError.push(fn);
      break;
      case 'data':
      
      break;
      case 'change':
        if (!this._events.onStateChange)
          this._events.onStateChange = [];
        this._events.onStateChange.push(fn);
      break;
      case 'response':
        if (!this._events.onResponseMiddleware)
          this._events.onResponseMiddleware = [];
        this._events.onResponseMiddleware.push(fn);
      break;
      default:
        if (!this._events[name])
          this._events[name] = [];
        this._events[name].push(fn);
    }
    return this;
  }
  function setOnOpen (fn) {
    return addEventListener.call(this, 'connect', fn);
  }
  function setOnReady (fn) {
    return addEventListener.call(this, 'ready', fn);
  }
  function setOnClose (fn) {
    return addEventListener.call(this, 'close', fn);
  }
  function setOnError (fn) {
    return addEventListener.call(this, 'error', fn);
  }
  function setOnStateChange (fn) {
    return addEventListener.call(this, 'change', fn);
  }

  function open (options, _callbackfn) {
    // var this... AIMS TO THE WS GENERATOR CLASS
    //  CREATE THE WS OBJECT
    var url;
    if(typeof options == "string") {
      url= options;
    }else{
      url= 'ws://localhost'
    }
    var protocol = !options.protocol ?
      typeof location==='undefined' ? 'ws' : location.protocol
      : options.protocol

    switch(protocol){
      case 'https:':
        protocol = "wss";
      default:
        protocol += '://'
    }
    var host = !options.host ?
      typeof location==='undefined' ? 'ws' : location.host
      : options.host
    var ws = {
      parent : this,
      url : url || protocol+host,
      defaultParams:{},
      ws : ws,
      registerTasks : {},
      _events:{},
      syncMethods : syncMethods,
      setParam : setParam,
      setMethod : setMethod,
      removeMethod: removeMethod,
      status: { 
        _state: 'close',
        attempts: 0
      }
    };
    //  ADDING GETTERS & SETTERS
    ws.status.__defineGetter__('state',getState.bind(ws));
    ws.status.__defineSetter__('state',setState.bind(ws));
    ws.status.__defineSetter__('isReady',isReady.bind(ws));
    ws.__defineSetter__('onOpen' , setOnOpen);
    ws.__defineSetter__('onReady' , setOnReady);
    ws.__defineSetter__('onCose' , setOnClose);
    ws.__defineSetter__('onError' , setOnError);
    ws.__defineSetter__('onStateChange' , setOnStateChange);
    ws.on = addEventListener;

    ws.reconnect = reconnect;
    ws.isReady = isReady;
    if (_callbackfn && typeof _callbackfn == 'function')
      ws.onOpen(_callbackfn);

    connect.call(ws);// ESTABLISH THE CONNECTION

    //  ADD/REGISTER THE NEW WS TO THE ARRAY.
    this.ws.push(ws);
    return ws;
  }

  /*
  *   PROTOTYPE THE METHODS
  */
  window.jSockets.open = open;
  window.jSockets._events = {};
  window.jSockets.ws = [];
  window.jSockets.__defineSetter__('onOpen' , setOnOpen);
  window.jSockets.__defineSetter__('onReady' , setOnReady);
  window.jSockets.__defineSetter__('onCose' , setOnClose);
  window.jSockets.__defineSetter__('onError' , setOnError);
  window.jSockets.__defineSetter__('onStateChange' , setOnStateChange);
  window.jSockets.readFromBuffer = readFromBuffer;
  window.jSockets.createBuffer = createBuffer;

  window.jSockets.test=()=>{
    const buf= createBuffer({
      taskId:999999, 
      methodName:'testMethod', 
      arguments:[true, false, 0, 1,30000,60000, 999999, 'hello work']
    });

    const res = readFromBuffer(buf);
    console.log(res);
  }
})();
function BufferStream() {
  window.jSockets = typeof window.jSockets=='undefined'?{}:window.jSockets;

  DataView.prototype.setInt64 = function(pointer, value) {
    var bigNumberAsBinaryStr = value.toString(2); // '100000000000000000000000000000000000000000000000000000'
    // Convert the above binary str to 64 bit (actually 52 bit will work) by padding zeros in the left
    var bigNumberAsBinaryStr2 = ''; 
    for (var i = 0; i < 64 - bigNumberAsBinaryStr.length; i++) {
      bigNumberAsBinaryStr2 += '0'; 
    }; 

    bigNumberAsBinaryStr2 += bigNumberAsBinaryStr;

    var lowInt = parseInt(bigNumberAsBinaryStr2.substring(0, 32), 2);
    var highInt = parseInt(bigNumberAsBinaryStr2.substring(32), 2);

    this.setUint32(pointer, lowInt);
    this.setUint32(pointer+4, highInt);
  };
  DataView.prototype.getInt64 = function(pointer) {
    var lowInt = this.getUint32(pointer);
    var highInt = this.getUint32(pointer+4);

    return  (lowInt * Math.pow(2, 32) + highInt);
  };

  const TYPE_STRING = 10,
    TYPE_INTEGER = 20,
    TYPE_INTEGER64 = 21,
    TYPE_BOOL = 22,
    TYPE_FLOAT = 25,
    TYPE_OBJECT = 30,
    TYPE_ARRAY = 40,
    TYPE_BUFFER = 50,
    TYPE_UNDEFINED = 70,
    TYPE_NULL = 75;

  const CHAR_SIZE =2, TYPE_SIZE = 1, PARAM_LENGTH = 4;

  const config = {
    buffer:{
      length:254
    }
  }

  function isType(value) {
    if (value === undefined) {
      return TYPE_UNDEFINED;
    }
    if ( value === null) {
      return TYPE_NULL;
    }
    if(typeof value == 'object'){
      if (Array.isArray(value)) {
        return TYPE_ARRAY;
      }else if(typeof File != 'undefined' && value instanceof File){
        return TYPE_BUFFER;
      }else{
        return TYPE_OBJECT;
      }
    }else if (typeof value == 'number') {
      if (Number.isInteger(value))
        if ( bytesSizeInt(value) === 8 )
          return TYPE_INTEGER64;
        else
          return TYPE_INTEGER;
      else
        return TYPE_FLOAT;
    }else if (typeof value == 'string') {
      return TYPE_STRING;
    }else if (typeof value == 'boolean') {
      return TYPE_BOOL;
    }
    return TYPE_UNDEFINED;
  }
  const Buff_Nums = {
    dv8: new DataView( new ArrayBuffer(8) ),
    dv16: new DataView( new ArrayBuffer(16) ),
    dv32: new DataView( new ArrayBuffer(32) ),
    dv64: new DataView( new ArrayBuffer(64) ),
  }
  function bytesSizeInt(value){
    var sizes = ['Int8', 'Int16', 'Int32', 'Int64'];
    var numberType = sizes.find(s=>{
      try{
        Buff_Nums.dv64[`set${s}`](0, value);
        return Buff_Nums.dv64[`get${s}`](0) == value;
      }catch(er){
        return false
      }
    })
    switch(numberType){
      case 'Int8':
        return 1
      break;
      case 'Int16':
        return 2
      break;
      case 'Int32':
        return 4
      break;

      case 'Int64':
        return 8
      break;
    }
  }

  function bytesSize(value) {
    var typeId = isType(value);
    switch(typeId){
      case TYPE_UNDEFINED:
        return 0;
      break;
      case TYPE_NULL:
        return 0;
      break;
      case TYPE_STRING:
        return value.length * CHAR_SIZE;
      break;
      case TYPE_BOOL:
        return 1;
      break;
      case TYPE_INTEGER:
        return bytesSizeInt(value);
      break;
      case TYPE_INTEGER64:
        return 8;
      break;
      case TYPE_FLOAT:
        return 4;
      break;
      case TYPE_OBJECT:
        value = JSON.stringify( value );
        if (value) return value.length * CHAR_SIZE;
        else return 0;
      break;
      case TYPE_ARRAY:
        value = JSON.stringify( value );
        if (value) return value.length * CHAR_SIZE;
        else return 0;
      break;
      case TYPE_BUFFER:
        return value.byteLength;
      break;
      default:
        console.log('--- ERROR UNDEFINED TYPE ---');
        return 0;
    }
    return 0;
  }

  function readString(dataView, pointer, size) {
    var end = pointer + size;
    var val = '';
    for (pointer; pointer < end; pointer+=CHAR_SIZE) {
      switch(CHAR_SIZE){
        case 1:
          val += String.fromCharCode( dataView.getInt8(pointer) );
        break;
        case 2:
          val += String.fromCharCode( dataView.getInt16(pointer) );
        break;
      }
    }
    return val;
  }
  function writeString(dataView, pointer, val) {
    for (pointer, s=0; s < val.length; pointer+=CHAR_SIZE, s++) {
      if(pointer < dataView.byteLength && s < val.length){
        try{
          switch(CHAR_SIZE){
            case 1:
              dataView.setInt8(pointer, val.charCodeAt(s));
            break;
            case 2:
              dataView.setInt16(pointer, val.charCodeAt(s));
            break;
          }
        }catch(err){
          //console.log('--- Error writing on buffer ---');
          //console.log('* Char Code: '+val.charCodeAt(s));
          //console.log('* Pointer: '+pointer);
          //console.log(err);
        }
      }
      else{
        //console.log('---  ERROR CanÂ´t WRITE ON BUFFER OUT OF SIZE ---');
        //console.log('Buffer Size: '+dataView.byteLength);
        //console.log('Tring index: '+pointer);
        //console.log('---  ERROR CanÂ´t READ FROM STRING OUT OF SIZE ---');
        //console.log('String Size: '+val.length);
        //console.log('Tring index: '+s);
        break;
      }
    }
    return pointer;
  }

  function readArgument(dataView, start) {
    //console.log('* Fetching argument.');
    //console.log('* pointer: '+start);

    var typeId, var_bytes;
    var result={
      pointer: start
    };
    if (result.pointer+PARAM_LENGTH >= dataView.byteLength ) 
      return dataView.byteLength;

    switch(PARAM_LENGTH){
      case 1:
        var_bytes = dataView.getInt8(result.pointer);
      break;
      case 2:
        var_bytes = dataView.getInt16(result.pointer);
      break;
      case 4:
        var_bytes = dataView.getInt32(result.pointer);
      break;
    }
    var_bytes = parseInt(var_bytes);

    result.pointer += PARAM_LENGTH;
    //console.log('* Var bytes: '+var_bytes);

    typeId = dataView.getInt8(result.pointer); result.pointer++;
    //console.log('* TypeId: '+typeId);

    if (typeId == TYPE_UNDEFINED || typeId == TYPE_NULL ) {
      //console.log('* Value: '+ result.value);
      result.value = typeId == TYPE_UNDEFINED? undefined:null;
      return result;
    }

    switch(typeId){
      case TYPE_STRING:
        result.value = readString(dataView, result.pointer, var_bytes);
      break;
      case TYPE_INTEGER:
        switch(var_bytes){
          case 1:
            result.value = dataView.getInt8(result.pointer);
          break;
          case 2:
            result.value = dataView.getInt16(result.pointer);
          break;
          case 4:
            result.value = dataView.getInt32(result.pointer);
          break;
          case 8:
            result.value = dataView.getInt64(result.pointer);
          break;
        }
      break;
      case TYPE_INTEGER64:
        result.value = dataView.getInt64(result.pointer);
      break;
      case TYPE_BOOL:
        //console.log('-> Read as boolean');
        result.value = dataView.getInt8(result.pointer) === 1? true:false;
      break;

      case TYPE_FLOAT:
        result.value = dataView.getFloat32(result.pointer);
      break;
      case TYPE_OBJECT:
        try{
          result.value = JSON.parse( readString(dataView, result.pointer, var_bytes) );
        }catch(err){
          //console.log('--- Error parsing string to object ---');
          //console.log(err)
        }    
      break;
      case TYPE_ARRAY:
        try{
          result.value = JSON.parse( readString(dataView, result.pointer, var_bytes) );
        }catch(err){
          //console.log('--- Error parsing string to Array ---');
          //console.log(err)
        }    
      break;
      case TYPE_BUFFER:
        try{
          result.value = dataView.buffer.slice(result.pointer, result.pointer+(var_bytes-1) );
        }catch(er){
          //console.log('--- ERROR SPLICE BUFFER ---');
          //console.log(er);
        }
      break;
      default:
        //console.log('--- ERROR UNDEFINED TYPE ---');
    }
    result.pointer += var_bytes;

    //console.log('* Value: '+ result.value);
    return result;
  }
  function writeOnView(dataView, start, val, var_bytes) {
    //console.log('+++ WRITING PARAMETER +++');
    //console.log('* Value: '+val);

    var typeId = isType(val);
    var result = {
      pointer: start
    }
    //console.log('* TypeId: '+typeId);
    //console.log('* Pointer: '+result.pointer);

    //  WRITE THE SIZE
    var_bytes = var_bytes == undefined? bytesSize(val) : var_bytes;
    //console.log('* Var bytes: '+var_bytes);
    switch(PARAM_LENGTH){
      case 1:
        dataView.setInt8(result.pointer, var_bytes);
      break;
      case 2:
        dataView.setInt16(result.pointer, var_bytes);
      break;
      case 4:
        dataView.setInt32(result.pointer, var_bytes);
      break;
    }
    result.pointer += PARAM_LENGTH;

    //  WRITE THE TYPE
    dataView.setInt8(result.pointer, typeId); result.pointer ++;

    if (typeId == TYPE_UNDEFINED || typeId == TYPE_NULL) {
      //console.log('* Undefined parameter.');
      return result.pointer;
    }

    switch(typeId){
      case TYPE_STRING:
        writeString(dataView, result.pointer, val);
      break;
      case TYPE_INTEGER:
        switch(var_bytes){
          case 1:
            dataView.setInt8(result.pointer, val);
            //console.log('-> Write as Int8');
            //console.log('-> Pointer: '+result.pointer);
          break;
          case 2:
            dataView.setInt16(result.pointer, val);
            //console.log('-> Write as Int16');
            //console.log('-> Pointer: '+result.pointer);
          break;
          case 4:
            dataView.setInt32(result.pointer, val);
            //console.log('-> Write as Int32');
            //console.log('-> Pointer: '+result.pointer);
          break;
          case 8:
            dataView.setInt64(result.pointer, val);
            //console.log('-> Write as Int32');
            //console.log('-> Pointer: '+result.pointer);
          break;
        }
      break;
      case TYPE_INTEGER64:
        dataView.setInt64(result.pointer, val);
      break;
      case TYPE_BOOL:
        //console.log('-> Write as boolean');
        dataView.setInt8(result.pointer, val);
      break;
      case TYPE_FLOAT:
        dataView.setFloat32(result.pointer, val);
      break;
      case TYPE_OBJECT:
        if (val.toJSON)
          val = val.toJSON();
        else
          val = JSON.stringify( val );
        writeString(dataView, result.pointer, val);
      break;
      case TYPE_ARRAY:
        val = JSON.stringify( val );
        writeString(dataView, result.pointer, val);
      break;
      case TYPE_BUFFER:
        val = new DataView(val); 
        for (var i = result.pointer, v=0; v < var_bytes; i++,v++) {
          if (i >= dataView.byteLength) {
            //console.log('---  ERROR CanÂ´t WRITE ON BUFFER OUT OF SIZE ---');
            //console.log('Buffer Size: '+dataView.byteLength);
            //console.log('Tring index: '+i);
            break;
          }
          if (v >= val.byteLength) {
            //console.log('---  ERROR CanÂ´t readfrom BUFFER OUT OF SIZE ---');
            //console.log('Buffer Size: '+val.byteLength);
            //console.log('Tring index: '+v);
            break;
          }
          dataView.setUint8(i, val.getUint8(v));
        }
      break;
      default:
        //console.log('--- ERROR UNDEFINED TYPE ---');
    }
    result.pointer += var_bytes;

    return result.pointer;
  }
  function readFromBuffer(buffer, start) {
    //console.log('+++ Start reading buffer +++');
    //console.log('Size: '+buffer.byteLength);
    var dataView = new DataView(buffer);
    var obj = {
      taskId:0,
      methodName: '',
      arguments: []
    };
    var tm_size, typeId, tm_arg, pointer=0;

    // FIND OUT THE TASK ID
    tm_arg = readArgument(dataView, pointer);
    pointer = tm_arg.pointer;
    obj.taskId = tm_arg.value;

    // FIND OUT THE METHOD NAME
    tm_arg = readArgument(dataView, pointer);
    pointer = tm_arg.pointer;
    obj.methodName = tm_arg.value;

    //  START FETCHING THE ARGUMENTS FROM THE BUFFER
    while(pointer < dataView.byteLength){
      tm_arg = readArgument(dataView, pointer);
      pointer = tm_arg.pointer;
      obj.arguments.push(tm_arg.value);
    };
    return obj;
  }
  function createBuffer(obj) {
    /*
    *   [taskID, methodName, arguments]
    */
    var buffer, buffer_size=0;
    var parameters = [obj.taskId, obj.methodName].concat(obj.arguments);

    //  SIZE OF THE ARGUMENTS.
    parameters.map(function (parameter) {
      var size = bytesSize(parameter);
      var param_size = bytesSize(size);
      if (param_size > Math.pow(2,(2+PARAM_LENGTH) ) ) {
        //console.log('---  ERROR MAX OF PARAMETER SIZE ---');
      }

      //  SIZE OF THE ARGUMENT + IT'S OWN TYPE SIZE.
      buffer_size += size + TYPE_SIZE + PARAM_LENGTH;
    });

    /*
    *   CREATE THE BUFFER.
    */
    //console.log('+++ CREATING BUFFER +++');
    buffer = new ArrayBuffer(buffer_size);
    //console.log('Size: '+buffer_size);
    var dataView = new DataView(buffer), pointer=0;

    /*
    *   START FILL IN THE BUFFER
    */
    parameters.map(function (parameter) {
      pointer = writeOnView(dataView, pointer, parameter);
    });

    return buffer;
  }
}