/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const optional = require('optional-js');
const _ = require('lodash');
const logger = require(path.join(__dirname, 'logApi'));
const Force = require(path.join(__dirname, 'force')); // eslint-disable-line global-require
const OrgPrefRegistry = require(path.join(__dirname, 'orgPrefRegistry'));
const almError = require(path.join(__dirname, 'almError'));
const messages = require(path.join(__dirname, 'messages'))();
/**
 * Shape API object, for all of your ShapeRepresentation needs
 * @constructor
 * @param forceApi The force api
 * @param shapeOrg The org we'll be querying against
 */
class ShapeRepresentationApi {
    constructor(forceApi, shapeOrg) {
        this.force = optional.ofNullable(forceApi).orElse(new Force());
        this.shapeOrg = shapeOrg;
    }
    create(description = "") {
        return __awaiter(this, void 0, void 0, function* () {
            return this.force.create(this.shapeOrg, 'ShapeRepresentation', { "Description": description })
                .catch((err) => {
                return Promise.reject(err);
            });
        });
    }
    /**
     * Delete all ShapeRepresentation records for the shapeOrg.
     * @return List of SR IDs that were deleted
     */
    deleteAll() {
        return __awaiter(this, void 0, void 0, function* () {
            let shapeIds = [];
            try {
                const result = yield this.force.query(this.shapeOrg, "SELECT Id FROM ShapeRepresentation");
                shapeIds = result.records.map((shape) => {
                    return shape.Id;
                });
            }
            catch (err) {
                if (err.errorCode && err.errorCode === 'INVALID_TYPE') {
                    // ShapeExportPref is not enabled, or user does not have CRUD access
                    return Promise.reject(new almError({ keyName: 'noAccess', bundle: 'org_shape_delete' }, []));
                }
                // non-access error
                return Promise.reject(err);
            }
            return Promise.all(shapeIds.map((id) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const delResult = yield this.force.delete(this.shapeOrg, 'ShapeRepresentation', id);
                    if (delResult.success) {
                        return delResult.id;
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            })));
        });
    }
    /**
     * Find all ShapeRepresentation records with a state of Active or InProgress.
     * @return SOQL response or null
     */
    findShapesOrNull() {
        return __awaiter(this, void 0, void 0, function* () {
            const query = "SELECT Id, Status, CreatedBy.Username, CreatedDate FROM ShapeRepresentation WHERE Status IN ( 'Active', 'InProgress' )";
            return this.force.query(this.shapeOrg, query)
                .catch((err) => {
                if (err.errorCode && err.errorCode === 'INVALID_TYPE') {
                    // ShapeExportPref is not enabled
                    return Promise.resolve();
                }
                // some important error
                return Promise.reject(err);
            });
        });
    }
    /**
     * Check if the ShapeExportPilot preference is enabled.
     */
    isFeatureEnabled() {
        return __awaiter(this, void 0, void 0, function* () {
            const prefValue = this.force.toolingQuery(this.shapeOrg, `SELECT SettingValue FROM ${OrgPrefRegistry.ORGANIZATION_SETTINGS_DETAIL_API} WHERE SettingName = 'ShapeExportPref'`);
            // no records are returned if ShapeExportPilot perm is disabled
            return prefValue.then((value) => {
                const enabled = (_.get(value, 'size', 0) > 0 && _.get(value, 'records[0].SettingValue', false));
                return Promise.resolve(enabled);
            });
        });
    }
}
module.exports = ShapeRepresentationApi;

//# sourceMappingURL=shapeRepApi.js.map
