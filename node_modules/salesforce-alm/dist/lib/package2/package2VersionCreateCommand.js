/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// Node
const path = require('path');
const Promise = require('bluebird');
const fs = Promise.promisifyAll(require('fs-extra'));
const util = require('util');
const os = require('os');
const crypto = require('crypto');
const _ = require('lodash');
// Third party
const xml2js = require('xml2js');
// Promisify
const fsReaddir = Promise.promisify(fs.readdir);
const fsReadFile = Promise.promisify(fs.readFile);
const fsUnlink = Promise.promisify(fs.unlink);
// Local
const messages = require(path.join(__dirname, '..', 'messages'))();
const MetadataRegistry = require(path.join(__dirname, '..', 'metadataRegistry'));
const logApi = require(path.join(__dirname, '..', 'logApi'));
const SourceWorkspaceAdapter = require(path.join(__dirname, '..', 'sourceWorkspaceAdapter'));
const ManifestCreateApi = require(path.join(__dirname, '..', 'manifestCreateApi'));
const srcDevUtil = require(path.join(__dirname, '..', 'srcDevUtil'));
const Package2VersionCreateRequestApi = require(path.join(__dirname, 'package2VersionCreateRequestApi'));
const SourceConvertCommand = require(path.join(__dirname, '..', 'sourceConvertCommand'));
const pkg2Utils = require(path.join(__dirname, 'package2Utils'));
const Config = require(path.join(__dirname, '..', 'configApi')).Config;
const ProfileApi = require(path.join(__dirname, 'profileApi'));
const STATUS_ERROR = 'Error';
const STATUS_SUCCESS = 'Success';
const STATUS_UNKNOWN = 'Unknown';
const DESCRIPTOR_FILE = 'package2-descriptor.json';
let logger;
const POLL_INTERVAL_SECONDS = 30;
class Package2VersionCreateCommand {
    constructor() {
        this.pollInterval = POLL_INTERVAL_SECONDS;
        this.maxRetries = 0;
        logger = logApi.child('package2:version:create');
    }
    // convert source to mdapi format and copy to tmp dir packaging up
    _generateMDFolderForArtifact(options) {
        const convertCmd = new SourceConvertCommand();
        const context = {
            flags: {
                rootdir: options.sourcedir,
                outputdir: options.deploydir
            }
        };
        return Promise.resolve()
            .then(() => convertCmd.validate(context))
            .then((fixedcontext) => {
            fixedcontext.beforePopulateMdDirHook = this.profileApi.beforePopulateMdDirHook.bind(this.profileApi);
            return convertCmd.execute(fixedcontext);
        });
    }
    _validateDependencyValues(dependency) {
        if (dependency.subscriberPackageVersionId) {
            pkg2Utils.validateId(pkg2Utils.BY_LABEL.SUBSCRIBER_PACKAGE2_VERSION_ID, dependency.subscriberPackageVersionId);
            return Promise.resolve();
        }
        if (!dependency.packageId || !dependency.versionNumber) {
            throw new Error(messages.getMessage('errorDependencyPair', [JSON.stringify(dependency)], 'package2_version_create'));
        }
        pkg2Utils.validateId(pkg2Utils.BY_LABEL.PACKAGE2_ID, dependency.packageId);
        pkg2Utils.validateVersionNumber(dependency.versionNumber);
        // validate that the package2 id exists on the server
        const query = `SELECT Id FROM Package2 WHERE Id = '${dependency.packageId}'`;
        return this.force.toolingQuery(this.org, query)
            .then((pkgQueryResult) => {
            const subRecords = pkgQueryResult.records;
            if (!subRecords || subRecords.length !== 1) {
                throw new Error(messages.getMessage('errorNoIdInHub', [dependency.packageId], 'package2_version_create'));
            }
        });
    }
    /**
     *  A dependency in the workspace config file may be specified using either a subscriber package version id (04t)
     *  or a package Id (0Ho) + a version number.  Additionally, a build number may be the actual build number, or the
     *  LATEST keyword (meaning the latest build number for a given major.minor.patch).  This method resolves a
     *  package Id + version number to a subscriber package version id (04t) and adds it as a SubscriberPackageVersionId
     *  parameter in the dependency object.
     */
    _retrieveSubscriberPackageVersionId(dependency, branch) {
        return Promise.resolve().then(() => this._validateDependencyValues(dependency)
            .then(() => {
            if (dependency.subscriberPackageVersionId) {
                // if an 04t id is specified just use it.
                return dependency;
            }
            const versionNumber = dependency.versionNumber.split('.');
            return this._resolveBuildNumber(versionNumber, dependency.packageId, branch)
                .then((queryResult) => {
                const records = queryResult.records;
                if (!records || records.length === 0 || records[0].expr0 == null) {
                    throw new Error(`No version number was found in Dev Hub for package id ${dependency.packageId} and branch ${branch} and version number ${versionNumber.join('.')}`);
                }
                const buildNumber = records[0].expr0;
                const branchString = _.isNil(branch) ? 'null' : `'${branch}'`;
                const query = `SELECT SubscriberPackageVersionId FROM Package2Version WHERE Package2Id = '${dependency.packageId}' AND MajorVersion = ${versionNumber[0]} AND MinorVersion = ${versionNumber[1]} AND PatchVersion = ${versionNumber[2]} AND BuildNumber = ${buildNumber} AND Branch = ${branchString}`;
                return this.force.toolingQuery(this.org, query)
                    .then((pkgVerQueryResult) => {
                    const subRecords = pkgVerQueryResult.records;
                    if (!subRecords || subRecords.length !== 1) {
                        throw new Error(`No version number was found in Dev Hub for package2 id ${dependency.packageId} and branch ${branch} and version number ${versionNumber.join('.')} that resolved to build number ${buildNumber}`);
                    }
                    dependency.subscriberPackageVersionId = pkgVerQueryResult.records[0].SubscriberPackageVersionId;
                    delete dependency.packageId;
                    delete dependency.versionNumber;
                    return dependency;
                });
            });
        }));
    }
    _resolveBuildNumber(versionNumber, package2Id, branch) {
        return Promise.resolve().then(() => {
            if (versionNumber[3] === pkg2Utils.LATEST_BUILD_NUMBER_TOKEN) {
                // branch?
                const branchString = _.isNil(branch) ? 'null' : `'${branch}'`;
                const query = `SELECT MAX(BuildNumber) FROM Package2Version WHERE Package2Id = '${package2Id}' AND MajorVersion = ${versionNumber[0]} AND MinorVersion = ${versionNumber[1]} AND PatchVersion = ${versionNumber[2]} AND branch=${branchString}`;
                return this.force.toolingQuery(this.org, query);
            }
            else {
                // The build number is already specified so just return it using the tooling query result obj structure
                const results = { record: [{ expr0: versionNumber[3] }] };
                return results;
            }
        });
    }
    _createRequestObject(package2Id, context, preserveFiles, package2VersTmpRoot, package2VersBlobZipFile) {
        const zipFileBase64 = fs.readFileSync(package2VersBlobZipFile).toString('base64');
        const requestObject = {
            Package2Id: package2Id,
            VersionInfo: zipFileBase64,
            Tag: context.flags.tag,
            Branch: context.flags.branch,
            InstallKey: context.flags.installationkey
        };
        if (preserveFiles) {
            logger.log(messages.getMessage('tempFileLocation', [package2VersTmpRoot], 'package2_version_create'));
            return requestObject;
        }
        else {
            return fs.removeAsync(package2VersTmpRoot)
                .then(() => requestObject);
        }
    }
    /*
     * Delete the metadata files for flow that are for inactive versions.
     * The activeFlow record contains a 'name' & 'version' for the active flow.
     *
     * 1) Remove any flows with the same name and a different version.
     * 2) Return an array of all the flows that were removed so they can also be excluded
     *    later when the manifest is built.
     */
    _deleteInactiveFlows(activeFlow, flowFiles, package2VersMetadataFolder) {
        const flowDir = path.join(package2VersMetadataFolder, 'flows');
        const inactiveFlows = [];
        const unlinkPromises = [];
        flowFiles.forEach((file) => {
            const name = file.substring(0, file.lastIndexOf('-'));
            if (activeFlow.name === name) {
                const version = file.substring(file.lastIndexOf('-') + 1, file.lastIndexOf('.'));
                if (version !== activeFlow.version) {
                    // found an inactive version, remove it so it will be excluded from the MD zip
                    unlinkPromises.push(fsUnlink(path.join(flowDir, file)));
                    inactiveFlows.push({ name: `${name}-${version}`, type: 'Flow' });
                }
            }
        });
        return { promises: Promise.all(unlinkPromises), flows: inactiveFlows };
    }
    /*
     * Only active flow versions should be passed in the metadata zip.
     * - Flow definitions are in the 'flowDefinitions' metadata folder and contain xml that indicates the active version
     *   (<activeVersionNumber>)
     * - Flows are contained in the 'flows' metadata folder.  Each flow has a name formatted as:
     *   <Flow Name>-<Version Number>  (e.g. MyTestFlow-2)
     *
     * This method:
     *  1) Reads all the Flow Definitions metadata files and extracts the version number for each one.
     *  2) Finds all the Flow version files.
     *  3) Iterates through each Flow Definition and calls _deleteInactiveFlows to find & delete any inactive flow vers.
     *
     */
    _filterOutInactiveFlows(package2VersMetadataFolder) {
        const flowDefinitionDir = path.join(package2VersMetadataFolder, 'flowDefinitions');
        const flowsDir = path.join(package2VersMetadataFolder, 'flows');
        const inactiveFlows = [];
        const activeFlows = [];
        return fsReaddir(flowDefinitionDir)
            .then((files) => {
            const promises = [];
            files.forEach((file) => {
                promises.push(fsReadFile(path.join(flowDefinitionDir, file), 'utf8'));
            });
            return [Promise.all(promises), files];
        })
            .spread((metadataXmls, files) => {
            const parser = new xml2js.Parser();
            // const promises = [];
            metadataXmls.forEach((metadataXml, i) => {
                parser.parseString(metadataXml, (err, result) => {
                    const json = JSON.parse(JSON.stringify(result));
                    const activeVersionNumber = json.FlowDefinition.activeVersionNumber[0];
                    const flowName = files[i].split('.')[0];
                    // save the flow name & active version in an array for each flow definition
                    activeFlows.push({ name: flowName, version: activeVersionNumber });
                });
            });
            return fsReaddir(flowsDir)
                .then((flows) => {
                const deleteInactiveFlowsPromises = [];
                // for each flow find and delete any inactive versions
                activeFlows.forEach((activeFlow) => {
                    const result = this._deleteInactiveFlows(activeFlow, flows, package2VersMetadataFolder);
                    deleteInactiveFlowsPromises.push(result);
                    Array.prototype.push.apply(deleteInactiveFlowsPromises, result.promises);
                    Array.prototype.push.apply(inactiveFlows, result.flows);
                });
                return [Promise.all(deleteInactiveFlowsPromises), inactiveFlows];
            })
                .catch((err) => {
                if (err.code === 'ENOENT') {
                    throw new Error('flowDefinition directory exists with flows directory: ${err.cause.message}');
                }
                throw new Error(err.message);
            });
        })
            .catch((err) => {
            if (err.code === 'ENOENT') {
                // If there is no flow metadata. This is a no-op.
                return;
            }
            throw new Error(err.message);
        });
    }
    /**
     * Convert the list of command line options to a JSON object that can be used to create an Package2VersionCreateRequest entity.
     * @param context
     * @returns {{Package2Id: (*|p|boolean), Package2VersionMetadata: *, Tag: *, Branch: number}}
     * @private
     */
    _createPackage2VersionCreateRequestFromOptions(context) {
        const artDir = context.flags.directory;
        const package2Id = context.flags.package2id;
        const preserveFiles = !util.isNullOrUndefined(context.flags.preserve || process.env.SFDX_PACKAGE2_VERSION_CREATE_PRESERVE);
        const uniqueHash = crypto.createHash('sha1').update(`${Date.now()}${Math.random()}`).digest('hex');
        const package2VersTmpRoot = path.join(os.tmpdir(), `${package2Id}-${uniqueHash}`);
        const package2VersMetadataFolder = path.join(package2VersTmpRoot, 'md-files');
        const package2VersProfileFolder = path.join(package2VersMetadataFolder, 'profiles');
        const package2VersBlobDirectory = path.join(package2VersTmpRoot, 'package2-version-info');
        const metadataZipFile = path.join(package2VersBlobDirectory, 'package.zip');
        const package2VersBlobZipFile = path.join(package2VersTmpRoot, 'package2-version-info.zip');
        const sourceBaseDir = path.join(context.org.force.getConfig().getProjectPath(), artDir);
        const mdOptions = {
            deploydir: package2VersMetadataFolder,
            sourcedir: sourceBaseDir
        };
        let metadataExclusions = [];
        // Copy all of the metadata from the workspace to a tmp folder
        return this._generateMDFolderForArtifact(mdOptions)
            .then(() => {
            const packageDescriptorJson = this.packageDirs.find((packageDir) => (!_.isNil(packageDir.path) && packageDir.path === artDir ? packageDir : null));
            if (!packageDescriptorJson) {
                throw new Error(`${Config.WorkspaceConfigFileName} does not contain a packaging directory for ${artDir}`);
            }
            return [this._filterOutInactiveFlows(package2VersMetadataFolder), packageDescriptorJson];
        })
            .spread((exclusions, packageDescriptorJson) => {
            if (exclusions) {
                metadataExclusions = exclusions[1];
            }
            // All dependencies for the packaging dir should be resolved to an 04t id to be passed to the server.
            // (see _retrieveSubscriberPackageVersionId for details)
            const dependencies = packageDescriptorJson.dependencies;
            const operations = _.isNil(dependencies) ? [] : dependencies.map((dependency) => this._retrieveSubscriberPackageVersionId(dependency, context.flags.branch));
            return [Promise.all(operations), pkg2Utils.getAncestorId(packageDescriptorJson, this.force, this.org), packageDescriptorJson];
        })
            .spread((resultValues, ancestorId, packageDescriptorJson) => {
            // If dependencies exist, the resultValues array will contain the dependencies populated with a resolved
            // subscriber pkg version id.
            if (resultValues.length > 0) {
                packageDescriptorJson.dependencies = resultValues;
            }
            if (packageDescriptorJson.default) {
                delete packageDescriptorJson.default; // for client-side use only, not needed
            }
            srcDevUtil.ensureDirectoryExistsSync(package2VersTmpRoot);
            srcDevUtil.ensureDirectoryExistsSync(package2VersBlobDirectory);
            if (Object.prototype.hasOwnProperty.call(packageDescriptorJson, 'ancestorVersion')) {
                delete packageDescriptorJson.ancestorVersion;
                packageDescriptorJson.ancestorId = ancestorId;
            }
            return fs.writeJSON(path.join(package2VersBlobDirectory, DESCRIPTOR_FILE), packageDescriptorJson);
        })
            .then(() => new ManifestCreateApi(this.org, this.profileApi.beforeManifestGenerationHook.bind(this.profileApi)).execute({
            sourcedir: sourceBaseDir,
            outputdir: mdOptions.deploydir,
            exclusions: metadataExclusions
        }))
            .then((manifestCreateResult) => {
            srcDevUtil.ensureDirectoryExistsSync(package2VersMetadataFolder);
            srcDevUtil.ensureDirectoryExistsSync(package2VersProfileFolder);
            const excludedProfiles = this.profileApi.generateProfiles(package2VersProfileFolder, manifestCreateResult.manifest);
            const manifest = manifestCreateResult.manifest;
            if (excludedProfiles.length > 0) {
                const profileIdx = manifest.Package.types.findIndex((e) => e.name === 'Profile');
                const manifestCreate = new ManifestCreateApi(this.org, this.profileApi.beforeManifestGenerationHook.bind(this.profileApi));
                manifest.Package.types[profileIdx].members = manifest.Package.types[profileIdx].members.filter((e) => excludedProfiles.indexOf(e) === -1);
                // flatten types array
                const typeNamePairs = [];
                manifest.Package.types.forEach((typeObj) => typeObj.members.forEach((member) => typeNamePairs.push({ type: typeObj.name, name: member })));
                manifestCreate.createManifest({
                    outputdir: mdOptions.deploydir,
                    sourceApiVersion: this.profileApi.apiVersion
                }, context.packageName, typeNamePairs);
            }
            return null;
        })
            .then(() => 
        // Zip the package2VersMetadataFolder folder and put the zip in {package2VersBlobDirectory}/package.zip
        srcDevUtil.zipDir(package2VersMetadataFolder, metadataZipFile))
            .then(() => srcDevUtil.zipDir(package2VersBlobDirectory, package2VersBlobZipFile))
            .then(() => this._createRequestObject(package2Id, context, preserveFiles, package2VersTmpRoot, package2VersBlobZipFile));
    }
    /**
     * Return true if the queryResult.records[0].Status is equal to one of the values in statuses.
     * @param results to examine
     * @param statuses array of statuses to look for
     * @returns {boolean} if one of the values in status is found.
     * @private
     */
    _isStatusEqualTo(results, statuses) {
        if (!results || results.length <= 0) {
            return false;
        }
        const record = results[0];
        for (let i = 0, len = statuses.length; i < len; i++) {
            const status = statuses[i];
            if (record.Status === status) {
                return true;
            }
        }
        return false;
    }
    _pollForStatus(id, retries) {
        return this.package2VersionCreateRequestApi.byId(id)
            .then((results) => {
            if (this._isStatusEqualTo(results, [STATUS_SUCCESS, STATUS_ERROR])) {
                if (this._isStatusEqualTo(results, [STATUS_SUCCESS])) {
                    return results[0];
                }
                else {
                    let status = 'Unknown Error';
                    if (results && results.length > 0 && results[0].Error.length > 0) {
                        status = results[0].Error;
                    }
                    throw new Error(status);
                }
            }
            else {
                if (retries > 0) {
                    let currentStatus = STATUS_UNKNOWN;
                    if (results && results.length > 0) {
                        currentStatus = results[0].Status;
                    }
                    logger.log(`Request in progress. Sleeping ${this.pollInterval} seconds. Will wait a total of ${this.pollInterval * retries} more seconds before timing out. Current Status='${currentStatus}'`);
                    return Promise.delay(this.pollInterval * 1000)
                        .then(() => this._pollForStatus(id, retries - 1));
                }
                else {
                    // Timed out
                }
            }
            return results;
        });
    }
    _getConfigPackageDirectoriesValue(context, packageDirs, propertyToLookup, knownProperty, knownValue, knownFlag) {
        let value;
        let packageDir = packageDirs.find(x => x[knownProperty] === knownValue);
        if (!packageDir && knownFlag.name === 'directory' && knownValue.endsWith(path.sep)) {
            // if this is the directory flag, try removing the trailing slash added by CLI auto-complete
            const dirWithoutTrailingSlash = knownValue.slice(0, -1);
            packageDir = packageDirs.find(x => x[knownProperty] === dirWithoutTrailingSlash);
            if (packageDir) {
                context.flags.directory = dirWithoutTrailingSlash;
            }
        }
        if (packageDir) {
            value = packageDir[propertyToLookup];
        }
        else {
            throw new Error(messages.getMessage('errorNoMatchingPackageDirectory', [`--${knownFlag.name} (-${knownFlag.char})`,
                knownValue, knownProperty], 'package2_version_create'));
        }
        return value;
    }
    execute(context) {
        return this._execute(context)
            .catch((err) => {
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw pkg2Utils.applyErrorAction(err);
        });
    }
    _execute(context) {
        this.org = context.org;
        this.force = this.org.force;
        this.package2VersionCreateRequestApi = new Package2VersionCreateRequestApi(this.force, this.org);
        this.profileApi = new ProfileApi(this.org);
        if (context.flags.wait) {
            this.maxRetries = (60 / POLL_INTERVAL_SECONDS) * context.flags.wait;
        }
        // This command requires either the ID flag or directory flag. The
        // other needed value can be looked up from sfdx-project.json. As
        // this concept is not supported by the framework, manually check if
        // we have at least one of the flags
        const directoryFlag = context.command.flags.find(x => x.name === 'directory');
        const package2IdFlag = context.command.flags.find(x => x.name === 'package2id');
        if (!context.flags.package2id && !context.flags.directory) {
            const errorString = messages.getMessage('errorMissingFlags', [
                `--${package2IdFlag.name} (-${package2IdFlag.char})`,
                `--${directoryFlag.name} (-${directoryFlag.char})`
            ], 'package2_version_create');
            const error = new Error(errorString);
            error.name = 'requiredFlagMissing';
            return Promise.reject(error);
        }
        // For the first rollout of validating sfdx-project.json data against schema, make it optional and defaulted
        // to false. Validation only occurs if the hidden -j (--validateschema) flag has been specified.
        let configContentPromise;
        if (context.flags.validateschema) {
            configContentPromise = context.org.force.config.getConfigContentWithValidation();
        }
        else {
            configContentPromise = Promise.resolve(context.org.force.config.getConfigContent());
        }
        // Look up the missing value or confirm a match
        return configContentPromise
            .then((configContent) => {
            this.packageDirs = configContent.packageDirectories;
            if (!context.flags.package2id) {
                context.flags.package2id = this._getConfigPackageDirectoriesValue(context, this.packageDirs, 'id', 'path', context.flags.directory, directoryFlag);
            }
            else if (!context.flags.directory) {
                context.flags.directory = this._getConfigPackageDirectoriesValue(context, this.packageDirs, 'path', 'id', context.flags.package2id, package2IdFlag);
            }
            else {
                const expectedPackage2Id = this._getConfigPackageDirectoriesValue(context, this.packageDirs, 'id', 'path', context.flags.directory, directoryFlag);
                this._getConfigPackageDirectoriesValue(context, this.packageDirs, 'path', 'id', context.flags.package2id, package2IdFlag); // just a lookup to throw error if ID is invalid
                if (context.flags.package2id !== expectedPackage2Id) {
                    throw new Error(messages.getMessage('errorDirectoryIdMismatch', [`--${directoryFlag.name} (-${directoryFlag.char})`,
                        context.flags.directory, `--${package2IdFlag.name} (-${package2IdFlag.char})`, context.flags.package2id], 'package2_version_create'));
                }
            }
            pkg2Utils.validateId(pkg2Utils.BY_LABEL.PACKAGE2_ID, context.flags.package2id);
            pkg2Utils.validateVersionNumber(this._getConfigPackageDirectoriesValue(context, this.packageDirs, 'versionNumber', 'id', context.flags.package2id, package2IdFlag), true);
            try {
                fs.statSync(path.join(process.cwd(), context.flags.directory));
            }
            catch (err) {
                throw new Error(`Directory '${context.flags.directory}' does not exist`);
            }
            return MetadataRegistry.initializeMetadataTypeInfos(this.org)
                .then(() => {
                this.swa = new SourceWorkspaceAdapter(this.org, this.force.getConfig().getAppConfig().defaultPackagePath, true, MetadataRegistry);
                return this._createPackage2VersionCreateRequestFromOptions(context)
                    .then((request) => this.force.toolingCreate(this.org, 'Package2VersionCreateRequest', request))
                    .then((createResult) => {
                    if (createResult.success) {
                        return createResult.id;
                    }
                    else {
                        const errStr = createResult.errors && createResult.errors.length ?
                            createResult.errors.join(', ') : createResult.errors;
                        throw new Error(`Failed to create request${createResult.id ? ` [${createResult.id}]` : ''}: ${errStr}`);
                    }
                })
                    .then((id) => {
                    if (context.flags.wait) {
                        return this._pollForStatus(id, this.maxRetries);
                    }
                    else {
                        return this.package2VersionCreateRequestApi.byId(id);
                    }
                })
                    .then((result) => (util.isArray(result) ? result[0] : result));
            });
        });
    }
    /**
     * returns a human readable message for a cli output
     * @param result - the data representing the Package2 Version
     * @returns {string}
     */
    getHumanSuccessMessage(result) {
        const args = result.Status === 'Success' ?
            [result.Id, result.Package2VersionId, result.SubscriberPackageVersionId] : [result.Id];
        return messages.getMessage(result.Status, args, 'package2_version_create');
    }
}
module.exports = Package2VersionCreateCommand;

//# sourceMappingURL=package2VersionCreateCommand.js.map
