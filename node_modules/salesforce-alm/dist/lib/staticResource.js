/*
 * Copyright, 1999-2016, salesforce.com
 * All Rights Reserved
 * Company Confidential
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const process = require('process');
const fs = require('fs-extra');
const os = require('os');
const path = require('path');
const util = require('util');
const mime = require('mime');
const mimeTypeExtensions = require('mime/types.json');
const fallBackMimeTypeExtensions = require(path.join(__dirname, 'mimeTypes'));
const AdmZip = require('adm-zip');
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const messages = require(path.join(__dirname, 'messages'))();
const Promise = require('bluebird');
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const logger = require(path.join(__dirname, 'logApi'));
const xmlMetadataDocument_1 = require("./xmlMetadataDocument");
const typeDefUtil_1 = require("./typeDefUtil");
/**
 * Encapsulates logic for handling of static resources.
 *
 * Static resources differ in the following ways from default mdapi expectations:
 * 1. The file name has a normal extension reflecting the mime type (zip, jar, jpeg) rather than "resource"
 * 2. A zip or jar archive can be exploded into a directory, and will be by default on pull. Only if an
 * archive file with the resource full name exists in the resources directory will it remain zipped.
 *
 * Note that when an archive is expanded on pull no attempt is made to avoid redundant updates of unmodified files
 * (as would happen in some other metadata decompositions).
 */
class StaticResource {
    constructor(metadataPath, typeDef, workspaceVersion, retrievedMetadataFilePath, unsupportedMimeTypes) {
        this.metadataPath = metadataPath;
        this.typeDef = typeDef;
        this.usingGAWorkspace = !util.isNullOrUndefined(workspaceVersion); // TODO - once we know what the version looks like
        this.retrievedMetadataFilePath = retrievedMetadataFilePath;
        this.resourcesDir = path.dirname(metadataPath);
        this.fullName = StaticResource.getFullName(metadataPath, typeDef);
        const effectiveMetadataFilePath = util.isNullOrUndefined(retrievedMetadataFilePath) ? metadataPath : retrievedMetadataFilePath;
        this.mimeType = StaticResource.getMimeType(effectiveMetadataFilePath);
        this.fileExtensions = this.getMimeTypeExtension(unsupportedMimeTypes);
        this.multiVersionHackUntilWorkspaceVersionsAreSupported = true; // sigh
    }
    getResource(metadataRegistry) {
        if (this.multiVersionHackUntilWorkspaceVersionsAreSupported) {
            if (this.isExplodedArchive()) {
                return StaticResource.zipDir(this.getExplodedFolderPath());
            }
            else if (srcDevUtil.pathExistsSync(this.getLegacyFilePath())) {
                return Promise.resolve(this.getLegacyFilePath());
            }
            else if (srcDevUtil.pathExistsSync(this.getSingleFilePathPreferExisting())) {
                return Promise.resolve(this.getSingleFilePathPreferExisting());
            }
            else {
                return Promise.resolve(typeDefUtil_1.TypeDefUtil.getContentPathWithNonStdExtFromMetadataPath(metadataRegistry, this.typeDef, this.metadataPath));
            }
        }
        else {
            if (this.usingGAWorkspace) {
                if (this.isExplodedArchive()) {
                    return StaticResource.zipDir(this.getExplodedFolderPath());
                }
                else {
                    return Promise.resolve(this.getSingleFilePathPreferExisting());
                }
            }
            else {
                return Promise.resolve(this.getLegacyFilePath());
            }
        }
    }
    saveResource(sourcePath, createDuplicates) {
        const updatedPaths = [];
        const duplicatePaths = [];
        if (this.multiVersionHackUntilWorkspaceVersionsAreSupported) {
            if (this.isExplodedArchive()) {
                return this.expandArchive(sourcePath, createDuplicates);
            }
            else if (srcDevUtil.pathExistsSync(this.getLegacyFilePath())) {
                return this.handleLegacyPath(sourcePath, createDuplicates);
            }
            else {
                return this.handleResource(sourcePath, createDuplicates);
            }
        }
        else {
            if (this.usingGAWorkspace) {
                if (this.isExplodedArchive()) {
                    return this.expandArchive(sourcePath, createDuplicates);
                }
                else {
                    fs.copySync(sourcePath, this.getSingleFilePathPreferExisting());
                    updatedPaths.push(this.getSingleFilePathPreferExisting());
                }
            }
            else {
                return this.handleResource(sourcePath, createDuplicates);
            }
        }
        return [updatedPaths, duplicatePaths];
    }
    isExplodedArchive() {
        if (this.multiVersionHackUntilWorkspaceVersionsAreSupported) {
            const singleFileArchiveExists = srcDevUtil.pathExistsSync(this.getSingleFilePath()) || srcDevUtil.pathExistsSync(this.getLegacyFilePath());
            return this.isArchiveMimeType() && !singleFileArchiveExists;
        }
        else {
            const singleFileArchiveExists = srcDevUtil.pathExistsSync(this.getSingleFilePath());
            return this.isArchiveMimeType() && !singleFileArchiveExists;
        }
    }
    getContentPaths() {
        let contentPaths = [];
        if (this.multiVersionHackUntilWorkspaceVersionsAreSupported) {
            if (this.isExplodedArchive()) {
                if (srcDevUtil.pathExistsSync(this.getExplodedFolderPath())) {
                    contentPaths = contentPaths.concat(this.getFiles(this.getExplodedFolderPath()));
                }
            }
            else if (srcDevUtil.pathExistsSync(this.getLegacyFilePath())) {
                contentPaths.push(this.getLegacyFilePath());
            }
            else {
                const contentPath = this.getSingleFilePathPreferExisting();
                if (srcDevUtil.pathExistsSync(contentPath)) {
                    contentPaths.push(contentPath);
                }
            }
        }
        else {
            if (this.usingGAWorkspace) {
                if (this.isExplodedArchive()) {
                    if (srcDevUtil.pathExistsSync(this.getExplodedFolderPath())) {
                        contentPaths = contentPaths.concat(this.getFiles(this.getExplodedFolderPath()));
                    }
                }
                else {
                    const contentPath = this.getSingleFilePathPreferExisting();
                    if (srcDevUtil.pathExistsSync(contentPath)) {
                        contentPaths.push(contentPath);
                    }
                }
            }
            else if (srcDevUtil.pathExistsSync(this.getLegacyFilePath())) {
                contentPaths.push(this.getLegacyFilePath());
            }
        }
        return contentPaths;
    }
    static getFullName(filePath, typeDef) {
        if (filePath.endsWith(`${typeDef.ext}${MetadataRegistry.getMetadataFileExt()}`)) {
            return path.basename(StaticResource.removeExtensions(filePath));
        }
        const filePathArray = filePath.split(path.sep);
        const indexOfDefaultDir = filePathArray.indexOf(typeDef.defaultDirectory);
        const staticResource = filePathArray[indexOfDefaultDir + 1];
        return StaticResource.removeExtensions(staticResource);
    }
    static getMetadataFilePathFor(filePath, typeDef) {
        const filePathArray = filePath.split(path.sep);
        const indexOfDefaultDir = filePathArray.indexOf(typeDef.defaultDirectory);
        const pathToStaticResourceDir = filePathArray.slice(0, indexOfDefaultDir + 1).join(path.sep);
        const fullName = StaticResource.getFullName(filePath, typeDef);
        return path.join(pathToStaticResourceDir, `${fullName}.${typeDef.ext}${MetadataRegistry.getMetadataFileExt()}`);
    }
    static zipDir(dir) {
        const zipFile = path.join((os.tmpdir() || '.'), `sdx_srzip_${process.hrtime()[0]}${process.hrtime()[1]}.zip`);
        return srcDevUtil.zipDir(dir, zipFile, { level: 9 });
    }
    /**
     * Get the mime type from the npm mime library file.
     * If the mime type is not supported there, use our backup manually added mime types file
     * If the mime type is not supported there, throw an error
     * @param unsupportedMimeTypes - an array of unsupported mime types for the purpose of logging
     * @returns {string[]} the mime type extension(s)
     */
    getMimeTypeExtension(unsupportedMimeTypes) {
        let ext = mimeTypeExtensions[this.mimeType];
        if (!ext) {
            ext = fallBackMimeTypeExtensions[this.mimeType];
        }
        if (ext) {
            return ext;
        }
        if (unsupportedMimeTypes) {
            unsupportedMimeTypes.push(this.mimeType);
        }
        return [this.typeDef.ext];
    }
    getFiles(file) {
        let found = [];
        found.push(file);
        const stat = fs.statSync(file);
        if (stat.isDirectory()) {
            const nestedFiles = fs.readdirSync(file);
            nestedFiles.forEach((nestedFile) => {
                const nestedPath = path.join(file, nestedFile);
                const nestedStat = fs.statSync(nestedPath);
                if (nestedStat.isDirectory()) {
                    found = found.concat(this.getFiles(nestedPath));
                }
                else {
                    found.push(nestedPath);
                }
            });
        }
        return found;
    }
    static getMimeType(metadataPath) {
        if (srcDevUtil.pathExistsSync(metadataPath)) {
            const doc = new xmlMetadataDocument_1.XmlMetadataDocument();
            doc.setRepresentation(fs.readFileSync(metadataPath, 'utf8'));
            const nodeTypeElement = 1;
            let child = doc.data.documentElement.firstChild;
            while (child !== null) {
                if (child.nodeType === nodeTypeElement && child.nodeName === 'contentType') {
                    return child.firstChild.nodeValue;
                }
                child = child.nextSibling;
            }
        }
        return mime.lookup(''); // this defaults to bin -- is this correct? 
    }
    static removeExtensions(filePath) {
        if (path.extname(filePath) === '') {
            return filePath;
        }
        else {
            return StaticResource.removeExtensions(path.join(path.dirname(filePath), path.basename(filePath, path.extname(filePath))));
        }
    }
    getLegacyFilePath() {
        return path.join(this.resourcesDir, `${this.fullName}.${this.typeDef.ext}`);
    }
    getSingleFilePath(ext) {
        let extension = ext;
        if (!ext) {
            const mimeLib = mime.extension(this.mimeType);
            extension = mimeLib ? mimeLib : this.getMimeTypeExtension();
        }
        return path.join(this.resourcesDir, `${this.fullName}.${extension}`);
    }
    getSingleFilePathPreferExisting() {
        const ext = this.fileExtensions.find((ext) => srcDevUtil.pathExistsSync(this.getSingleFilePath(ext)));
        return this.getSingleFilePath(ext);
    }
    getExplodedFolderPath() {
        return path.join(this.resourcesDir, this.fullName);
    }
    isArchiveMimeType() {
        const fallBackExtension = fallBackMimeTypeExtensions[this.mimeType];
        let isZip = false;
        if (fallBackExtension) {
            isZip = fallBackExtension[0] === 'zip';
        }
        return this.mimeType === mime.lookup('zip') || this.mimeType === mime.lookup('jar') || isZip;
    }
    expandArchive(sourcePath, createDuplicates) {
        let updatedPaths = [];
        const duplicatePaths = [];
        // expand the archive into a temp directory
        const tempDir = path.join(os.tmpdir(), `sfdx_staticresource_${this.fullName}_${Date.now()}`);
        srcDevUtil.ensureDirectoryExistsSync(tempDir);
        new AdmZip(sourcePath).extractAllTo(tempDir);
        // compare exploded directories if needed
        let isUpdatingExistingStaticResource = srcDevUtil.pathExistsSync(this.getExplodedFolderPath());
        if (isUpdatingExistingStaticResource && createDuplicates) {
            this.compareExplodedDirs(tempDir, duplicatePaths, updatedPaths);
        }
        // now copy all the files in the temp dir into the workspace
        srcDevUtil.deleteDirIfExistsSync(this.getExplodedFolderPath());
        fs.copySync(tempDir, this.getExplodedFolderPath()); // override new file with existing
        // if this is a new static resource then simply report all files as changed
        if (!isUpdatingExistingStaticResource) {
            srcDevUtil.actOn(tempDir, file => {
                updatedPaths.push(file.replace(tempDir, this.getExplodedFolderPath()));
            });
        }
        return [updatedPaths, duplicatePaths];
    }
    // if an exploded directory structure exists in the workspace then loop through each new file and see if a file
    // with same name exists in the workspace. If that file exists then compare the hashes. If hashes are different
    // then create a duplicate file.
    compareExplodedDirs(tempDir, duplicatePaths, updatedPaths) {
        srcDevUtil.actOn(tempDir, (file) => {
            if (!fs.statSync(file).isDirectory()) {
                const relativePath = file.substring(file.indexOf(tempDir) + tempDir.length);
                const workspaceFile = path.join(this.getExplodedFolderPath(), relativePath);
                if (srcDevUtil.pathExistsSync(workspaceFile)) {
                    if (!srcDevUtil.areFilesEqual(workspaceFile, file)) {
                        fs.copySync(file, file + '.dup'); // copy newFile to .dup
                        duplicatePaths.push(workspaceFile + '.dup'); // keep track of dups
                        fs.copySync(workspaceFile, file); // override new file with existing
                    }
                    // if file exists and contents are the same then don't report it as updated
                }
                else {
                    updatedPaths.push(workspaceFile); // this is a net new file
                }
            }
        });
    }
    handleResource(sourcePath, createDuplicates) {
        const updatedPaths = [];
        const duplicatePaths = [];
        const destFile = this.getSingleFilePathPreferExisting();
        if (!srcDevUtil.pathExistsSync(destFile)) {
            fs.copySync(sourcePath, this.getSingleFilePathPreferExisting());
            updatedPaths.push(this.getSingleFilePathPreferExisting());
        }
        else if (!srcDevUtil.areFilesEqual(sourcePath, destFile) && createDuplicates) {
            fs.copySync(sourcePath, `${this.getSingleFilePathPreferExisting()}.dup`);
            duplicatePaths.push(`${this.getSingleFilePathPreferExisting()}.dup`);
        }
        return [updatedPaths, duplicatePaths];
    }
    handleLegacyPath(sourcePath, createDuplicates) {
        const updatedPaths = [];
        const duplicatePaths = [];
        const legacyFilePath = this.getLegacyFilePath();
        if (createDuplicates) {
            if (!srcDevUtil.areFilesEqual(sourcePath, legacyFilePath)) {
                fs.copySync(sourcePath, legacyFilePath + '.dup');
                duplicatePaths.push(legacyFilePath + '.dup');
            }
            // if contents are equal and we are doing a mdapi:convert (createDuplicates=true) then ignore this file
        }
        else {
            fs.copySync(sourcePath, legacyFilePath);
            updatedPaths.push(legacyFilePath);
        }
        return [updatedPaths, duplicatePaths];
    }
}
exports.StaticResource = StaticResource;

//# sourceMappingURL=staticResource.js.map
