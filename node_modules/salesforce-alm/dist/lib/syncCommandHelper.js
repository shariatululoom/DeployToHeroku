/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
const util = require('util');
const path = require('path');
const sourceState = require(path.join(__dirname, 'sourceState'));
const AggregateSourceElement = require(path.join(__dirname, 'aggregateSourceElement')).AggregateSourceElement;
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const _createRowsForConflictStatus = function (rows, createDisplayRowData, outpuFileInfo, projectPath, thisSelf, isStatus) {
    const row = createDisplayRowData(outpuFileInfo, thisSelf.trimParentFromPath(projectPath, outpuFileInfo.filePath));
    if (isStatus && outpuFileInfo.isConflict) {
        row.state += ' (Conflict)';
    }
    rows.push(row);
};
const _getState = function (state, isNotDeleteable) {
    const calcState = !util.isNullOrUndefined(state) ? state : sourceState.DELETED;
    return isNotDeleteable && calcState === sourceState.DELETED ? `${sourceState.toString(sourceState.DELETED)} (local file)` : sourceState.toString(calcState);
};
const _getSourceElement = function (componentFailure, aggregateSourceElements) {
    let fullName = componentFailure.fullName;
    let sourceElementKey;
    if (componentFailure.componentType === 'AuraDefinitionBundle') {
        // check to see if it's an aura-related error in which case the fullame is the name of the file within the bundle without any extension
        // for example for a bundle with fullname=testbundle and an error in the helper the MD API response will contain:
        // "fileName": "metadataPackage_1497651865666/aura/testbundle/testbundleHelper.js",
        // "fullName": "testbundleHelper",
        const fileNameParts = componentFailure.fileName.split('/');
        const indexOfAuraDir = fileNameParts.indexOf('aura');
        fullName = fileNameParts[indexOfAuraDir + 1];
        sourceElementKey = AggregateSourceElement.getKeyFromMetadataNameAndFullName(componentFailure.componentType, fullName);
        return aggregateSourceElements.get(sourceElementKey);
    }
    sourceElementKey = AggregateSourceElement.getKeyFromMetadataNameAndFullName(componentFailure.componentType, fullName);
    let sourceElement = aggregateSourceElements.get(sourceElementKey);
    if (util.isNullOrUndefined(sourceElement)) {
        // couldn't find any sourceElement with the fullName returned by the MD API so inspect the fullname to
        // see if it looks something like classes/DreamHouseSampleDataController.cls-meta.xml
        // remove everything leading up and including the last /
        if (fullName.includes('/')) {
            fullName = fullName.substring(fullName.lastIndexOf('/') + 1);
        }
        sourceElementKey = AggregateSourceElement.getKeyFromMetadataNameAndFullName(componentFailure.componentType, fullName);
        sourceElement = aggregateSourceElements.get(sourceElementKey);
        // remove the -meta.xml extension
        if (util.isNullOrUndefined(sourceElement) && fullName.endsWith(MetadataRegistry.getMetadataFileExt())) {
            fullName = fullName.substring(0, fullName.indexOf(MetadataRegistry.getMetadataFileExt()));
            sourceElementKey = AggregateSourceElement.getKeyFromMetadataNameAndFullName(componentFailure.componentType, fullName);
            sourceElement = aggregateSourceElements.get(sourceElementKey);
        }
        // finally remove the type extension
        if (util.isNullOrUndefined(sourceElement) && fullName.includes('.')) {
            fullName = fullName.substring(0, fullName.indexOf('.'));
            sourceElementKey = AggregateSourceElement.getKeyFromMetadataNameAndFullName(componentFailure.componentType, fullName);
            sourceElement = aggregateSourceElements.get(sourceElementKey);
        }
    }
    return sourceElement;
};
const _parseComponentFailure = function (componentFailure, sourceElements) {
    // see if we can map the error to a local sourceElement
    const aggregateSourceElement = _getSourceElement(componentFailure, sourceElements);
    // does the error reference the -meta file or the content file?
    const isMeta = componentFailure.fileName.endsWith(MetadataRegistry.getMetadataFileExt());
    let filePath;
    if (!util.isNullOrUndefined(aggregateSourceElement)) {
        if (isMeta || !aggregateSourceElement.typeDef.hasContent) {
            filePath = aggregateSourceElement.getMetadataFilePath();
        }
        else {
            const workspaceElements = aggregateSourceElement.getWorkspaceElements();
            const matchingWorkspaceElement = workspaceElements.find(element => path.basename(element.getSourcePath()) === path.basename(componentFailure.fileName));
            filePath = matchingWorkspaceElement.getSourcePath();
        }
    }
    else {
        filePath = '';
    }
    // if the error cannot be mapped then use the fullName returns in the MD API response. Isn't this an edge case?
    const fullName = !util.isNullOrUndefined(aggregateSourceElement) ? aggregateSourceElement.getAggregateFullName() : componentFailure.fullName;
    return {
        columnNumber: componentFailure.columnNumber,
        lineNumber: componentFailure.lineNumber,
        error: componentFailure.problem,
        fullName,
        type: componentFailure.componentType,
        filePath
    };
};
const self = {
    getDeployFailures(resp, aggregateSourceElements) {
        const deployFailures = [];
        // look into component details assemble deployment failure message
        if (resp.details && resp.details.componentFailures) {
            if (resp.details.componentFailures.length > 0) {
                // Array of failures
                for (let i = 0, len = resp.details.componentFailures.length; i < len; i++) {
                    const comp = resp.details.componentFailures[i];
                    deployFailures.push(_parseComponentFailure(comp, aggregateSourceElements));
                }
            }
            else {
                // Single failure
                const comp = resp.details.componentFailures;
                deployFailures.push(_parseComponentFailure(comp, aggregateSourceElements));
            }
        }
        else if (!util.isNullOrUndefined(resp.ErrorMsg)) {
            deployFailures.push({ error: resp.ErrorMsg });
        }
        else {
            deployFailures.push({ error: 'Unknown' });
        }
        return deployFailures;
    },
    /**
     * report formatting for retrieve failures.
     * @param resp - the result of toolingRetrieve
     * @param detailProperty - the name of the property with the deploy details. Defaults to 'DeployDetails'.
     * @returns {string} represents reported deployment errors
     * @private
     */
    getRetrieveFailureMessage(resp, messages) {
        let msg = '';
        if (!util.isNullOrUndefined(resp.messages)) {
            if (resp.messages instanceof Array && resp.messages.length > 0) {
                for (let i = 0, len = resp.messages.length; i < len; ++i) {
                    msg += resp.messages[i].problem;
                    if (i < len - 1) {
                        msg += '\n';
                    }
                }
            }
            else {
                msg = resp.messages.problem;
            }
        }
        else if (!util.isNullOrUndefined(resp.errorMessage)) {
            msg = resp.errorMessage;
        }
        else if (util.isNullOrUndefined(resp.fileProperties) || !Array.isArray(resp.fileProperties)) {
            msg = messages.getMessage('mdapiPullCommandNoDataReturned');
        }
        else {
            msg = 'Unknown';
        }
        return msg;
    },
    /**
     * helper method used by the sync commands to retrieve status of a container async request.
     * @param force - the force api
     * @param api - scratch org api
     * @param sobjectId - id of the container async request
     * @param messages - L10N access obeject
     * @param callback - callback that resolves a value once the ContainerAsyncRequest is complete.
     * @param resolve - outer promise resolve function
     * @param reject - outer promise reject handler
     * @returns {Promise}
     */
    retrieveContainerStatus(force, api, sobjectId, messages, callback, resolve, reject) {
        return force.toolingRetrieve(api, 'ContainerAsyncRequest', sobjectId).then((resp) => {
            switch (resp.State) {
                case 'Completed':
                    return resolve(callback());
                case 'Failed':
                    {
                        const deployFailed = new Error(self.getDeployFailureMessage(resp));
                        deployFailed.name = 'ContainerDeployFailed';
                        return reject(deployFailed);
                    }
                case 'Invalidated':
                    {
                        const invalidatedError = 
                        // @todo re-label message
                        new Error(messages.getMessage('pushCommandAsyncRequestInvalidated'));
                        invalidatedError.name = 'ContainerDeployInvalidated';
                        return reject(invalidatedError);
                    }
                default:
                    {
                        let deployErrMsg = messages.getMessage('pushCommandAsyncRequestUnexpected');
                        const respError = self.getDeployFailureMessage(resp);
                        if (!util.isNullOrUndefined(respError)) {
                            deployErrMsg += `  ${respError}.`;
                        }
                        const deployError = new Error(deployErrMsg);
                        deployError.name = 'ContainerDeployError';
                        return reject(deployError);
                    }
            }
        });
    },
    /**
     * Removes a parent path to make a relative path.
     *
     * @param parent - the parent path (usually a project directory)
     * @param elementPath - the full path that contains the parent.
     * @returns {*}
     */
    trimParentFromPath(parent, elementPath) {
        if (util.isNullOrUndefined(elementPath) || elementPath.indexOf(parent) !== 0) {
            return null;
        }
        if (util.isNullOrUndefined(parent)) {
            return null;
        }
        const trimmedParent = parent.trim();
        if (trimmedParent.length < 1) {
            return null;
        }
        let newParent = trimmedParent;
        if (!parent.endsWith(path.sep)) {
            newParent = `${trimmedParent}${path.sep}`;
        }
        const paths = elementPath.trim().split(newParent);
        const element = paths[paths.length - 1];
        // handle the case where both the parent and elementPath are the same.
        if (element === elementPath) {
            return '';
        }
        return element;
    },
    getColumnMetaInfo(messages) {
        return [
            { key: 'state', label: messages.getMessage('stateTableColumn') },
            { key: 'fullName', label: messages.getMessage('fullNameTableColumn') },
            { key: 'type', label: messages.getMessage('typeTableColumn') },
            { key: 'filePath', label: messages.getMessage('workspacePathTableColumn') }
        ];
    },
    createDeployFailureRow(rows, failure, projectPath) {
        if (!util.isNullOrUndefined(failure.filePath)) {
            if (failure.filePath === '') {
                failure.filePath = 'N/A';
            }
            else {
                failure.filePath = self.trimParentFromPath(projectPath, failure.filePath);
            }
        }
        const columnNumber = failure.columnNumber || 0; // sometimes we only get the line number
        if (failure.lineNumber) {
            failure.error += ` (${failure.lineNumber}:${columnNumber})`;
        }
        rows.push(failure);
    },
    createConflictRows(rows, conflictFileInfo, projectPath) {
        const _createDisplayRowData = (fileInfo, filePath) => ({
            state: 'Conflict',
            fullName: fileInfo.fullName,
            type: fileInfo.type,
            filePath
        });
        _createRowsForConflictStatus(rows, _createDisplayRowData, conflictFileInfo, projectPath, self, false);
    },
    createStatusLocalRows(rows, outputFileInfo, projectPath) {
        const _createDisplayRowData = (fileInfo, filePath) => ({
            state: `Local ${_getState(fileInfo.state, fileInfo.isStandardMember)}`,
            fullName: fileInfo.fullName,
            type: fileInfo.type,
            filePath
        });
        _createRowsForConflictStatus(rows, _createDisplayRowData, outputFileInfo, projectPath, self, true);
    },
    // displays a row based on information pulled from a SourceMember row
    createStatusRemoteRows(rows, sourceMember, projectPath) {
        const _createDisplayRowData = (sm, filePath) => ({
            state: `Remote ${sourceState.toString(sm.state)}`,
            fullName: sm.fullName,
            type: sm.type,
            filePath
        });
        _createRowsForConflictStatus(rows, _createDisplayRowData, sourceMember, projectPath, self, true);
    },
    createDisplayRows(rows, outputFileInfo, projectPath) {
        if (util.isNullOrUndefined(rows)) {
            const error = new Error('Row collection not specified.');
            error.name = 'MissingRowCollection';
            throw error;
        }
        if (util.isNullOrUndefined(outputFileInfo)) {
            const error = new Error('Output file info not found.');
            error.name = 'SourceElementNotFound';
            throw error;
        }
        if (util.isNullOrUndefined(projectPath)) {
            const error = new Error('Can\'t display row without the projectPath');
            error.name = 'MissingProjectPathForDisplay';
            throw error;
        }
        const _createDisplayRowData = (element, filePath) => ({
            state: _getState(element.state, element.isStandardMember),
            fullName: element.fullName,
            type: element.type,
            filePath
        });
        const filePath = outputFileInfo.filePath;
        rows.push(_createDisplayRowData(outputFileInfo, self.trimParentFromPath(projectPath, filePath)));
    }
};
module.exports = self;

//# sourceMappingURL=syncCommandHelper.js.map
