/*
 * Copyright, 1999-2017, salesforce.com
 * All Rights Reserved
 * Company Confidential
 */
"use strict";
// Node
const path = require('path');
const util = require('util');
const fs = require('fs');
// 3PP
const Promise = require('bluebird');
const optional = require('optional-js');
// Local
const srcDevUtil = require(path.join(__dirname, 'srcDevUtil'));
const MetadataRegistry = require(path.join(__dirname, 'metadataRegistry'));
const SourceConvertApi = require(path.join(__dirname, 'sourceConvertApi'));
const messages = require(path.join(__dirname, 'messages'))();
const Org = require(path.join(__dirname, 'scratchOrgApi'));
const logger = require(path.join(__dirname, 'logApi'));
const COMMAND_TEMP_ORG = 'sourceConvertTempOrg@org.org';
class SourceConvertCommand {
    constructor() {
        this.logger = logger.child('source:convert');
    }
    validate(context) {
        const fixedContext = srcDevUtil.fixCliContext(context);
        this.scratchOrg = new Org();
        this.scratchOrg.setName(COMMAND_TEMP_ORG);
        const defaultOutputDir = `metadataPackage_${Date.now()}`;
        this.outputDir = optional.ofNullable(fixedContext.outputdir).orElse(defaultOutputDir);
        this.packagename = optional.ofNullable(fixedContext.packagename).orElse(null);
        if (util.isNullOrUndefined(fixedContext.rootdir)) {
            this.rootDir = path.resolve(this.scratchOrg.config.getAppConfig().defaultPackagePath);
        }
        else {
            this.rootDir = path.resolve(fixedContext.rootdir);
            const rootDirParentPath = path.dirname(this.rootDir);
            const filenames = fs.readdirSync(rootDirParentPath);
            if (filenames.indexOf(path.basename(this.rootDir)) === -1) {
                const error = new Error(messages.getMessage('invalidRootDirectory', this.rootDir, 'sourceConvertCommand'));
                return Promise.reject(error);
            }
        }
        fixedContext.outputDir = this.outputDir;
        fixedContext.rootDir = this.rootDir;
        fixedContext.packagename = this.packagename;
        return Promise.resolve(fixedContext);
    }
    execute(context) {
        return MetadataRegistry.initializeMetadataTypeInfos(this.scratchOrg)
            .then(() => {
            const sourceConvertApi = new SourceConvertApi(this.scratchOrg);
            context.unsupportedMimeTypes = []; // for logging unsupported static resource mime types
            return sourceConvertApi.doConvert(context)
                .then(() => {
                srcDevUtil.logUnsupportedMimeTypeError(context.unsupportedMimeTypes, this.logger, this.scratchOrg.force);
            })
                .then(() => Promise.resolve({ location: path.resolve(this.outputDir) }));
        }).finally(() => this.scratchOrg.cleanData());
    }
    getHumanSuccessMessage() {
        return messages.getMessage('success', path.resolve(this.outputDir), 'sourceConvertCommand');
    }
    static getCommandTempOrg() {
        return COMMAND_TEMP_ORG;
    }
}
module.exports = SourceConvertCommand;

//# sourceMappingURL=sourceConvertCommand.js.map
